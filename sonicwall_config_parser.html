<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SonicWall Config Parser | Homelab Playground</title>
    <link rel="icon" type="image/png" href="favicon.png">

    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <!-- Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        obsidian: {
                            bg: '#1e1e1e',
                            pane: '#252526',
                            border: '#3c3c3c',
                            accent: '#7c3aed',
                            accentHover: '#6d28d9',
                            text: '#cccccc',
                            textMuted: '#9ca3af',
                            success: '#10b981',
                            warning: '#f59e0b',
                            danger: '#ef4444'
                        }
                    },
                    fontFamily: {
                        mono: ['"Fira Code"', 'monospace'],
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3c3c3c;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-btn.active {
            border-bottom-color: #7c3aed;
            color: #7c3aed;
        }
    </style>
</head>

<body class="flex flex-col h-screen overflow-hidden bg-obsidian-bg text-obsidian-text font-sans">

    <!-- Header -->
    <header
        class="h-14 bg-obsidian-pane border-b border-obsidian-border flex items-center justify-between px-6 shrink-0 z-20">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-shield-halved text-obsidian-accent text-lg"></i>
            <h1 class="font-semibold text-white tracking-tight">SonicWall Config Parser</h1>
        </div>
        <div class="flex items-center gap-4">
            <!-- File Input hidden -->
            <input type="file" id="fileInput" accept=".txt,.exp" class="hidden">

            <button onclick="document.getElementById('fileInput').click()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors">
                <i class="fa-solid fa-upload mr-2 text-obsidian-accent"></i>
                Upload
            </button>

            <button onclick="togglePasteModal()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors">
                <i class="fa-solid fa-paste mr-2 text-obsidian-accent"></i>
                Paste Text
            </button>

            <span id="fileName" class="text-sm text-obsidian-textMuted italic max-w-[200px] truncate ml-2">No file
                chosen</span>

            <button onclick="copyToClipboard()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors ml-4">
                <i class="fa-regular fa-copy mr-2 text-obsidian-accent"></i>
                Copy JSON
            </button>
        </div>
    </header>

    <!-- Paste Modal -->
    <div id="pasteModal"
        class="fixed inset-0 bg-black/80 hidden z-50 flex items-center justify-center backdrop-blur-sm">
        <div
            class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl w-full max-w-4xl flex flex-col h-[80vh]">
            <div class="flex items-center justify-between px-6 py-4 border-b border-obsidian-border bg-obsidian-pane">
                <h3 class="text-lg font-semibold text-white"><i
                        class="fa-solid fa-clipboard mr-2 text-obsidian-accent"></i>Paste Configuration</h3>
                <button onclick="togglePasteModal()" class="text-obsidian-textMuted hover:text-white transition-colors">
                    <i class="fa-solid fa-xmark text-xl"></i>
                </button>
            </div>
            <div class="p-0 flex-1 flex flex-col min-h-0">
                <textarea id="pasteArea"
                    class="w-full h-full bg-obsidian-bg border-none p-4 font-mono text-xs text-obsidian-text focus:ring-0 outline-none resize-none"
                    placeholder="Paste SonicWall configuration text here..."></textarea>
            </div>
            <div class="px-6 py-4 border-t border-obsidian-border bg-obsidian-pane flex justify-end space-x-3">
                <button onclick="togglePasteModal()"
                    class="px-4 py-2 text-obsidian-textMuted hover:text-white transition-colors text-sm font-medium">Cancel</button>
                <button onclick="processPaste()"
                    class="bg-obsidian-accent hover:bg-obsidian-accentHover text-white px-6 py-2 rounded-md font-medium transition-colors shadow-lg shadow-obsidian-accent/20">
                    <i class="fa-solid fa-bolt mr-2"></i>Parse Text
                </button>
            </div>
        </div>
    </div>


    <!-- Main Layout -->
    <div class="flex flex-1 overflow-hidden">
        <!-- Sidebar -->
        <aside id="sidebar"
            class="w-64 bg-obsidian-pane border-r border-obsidian-border flex flex-col shrink-0 transition-all duration-300 transform">
            <div class="p-4 border-b border-obsidian-border">
                <div class="relative">
                    <i
                        class="fa-solid fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-obsidian-textMuted text-xs"></i>
                    <input type="text" id="navSearch" placeholder="Search sections..."
                        class="w-full bg-obsidian-bg border border-obsidian-border rounded-md py-1.5 pl-8 pr-3 text-xs text-obsidian-text focus:outline-none focus:border-obsidian-accent transition-colors">
                </div>
            </div>
            <nav id="sidebarNav" class="flex-1 overflow-y-auto py-2 space-y-0.5 px-2">
                <!-- Nav items injected by JS -->
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="flex-1 overflow-auto bg-obsidian-bg relative flex flex-col" id="mainContent">

            <!-- Empty State -->
            <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center opacity-60 z-0">
                <i class="fa-solid fa-file-code text-7xl text-obsidian-border mb-6"></i>
                <h3 class="mt-2 text-xl font-medium text-white">No configuration parsed</h3>
                <p class="mt-2 text-sm text-obsidian-textMuted max-w-sm text-center">Upload a SonicWall configuration
                    file (.txt or .exp) to view the parsed details organized by section.</p>
                <button onclick="document.getElementById('fileInput').click()"
                    class="mt-6 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-obsidian-accent hover:bg-obsidian-accentHover focus:outline-none transition-colors">
                    <i class="fa-solid fa-upload mr-2"></i> Upload File
                </button>
            </div>

            <!-- Content Area -->
            <div id="resultsArea" class="hidden relative z-10 min-h-full flex flex-col">
                <header id="contentHeader"
                    class="bg-obsidian-bg border-b border-obsidian-border px-8 py-5 flex items-center justify-between sticky top-0 z-20 shadow-sm">
                    <div>
                        <h2 id="currentSectionTitle" class="text-2xl font-semibold text-white tracking-tight">Overview
                        </h2>
                        <p id="currentSectionCount" class="text-sm text-obsidian-textMuted mt-1 hidden">0 items</p>
                    </div>
                </header>

                <div id="tabsContent" class="p-8 flex-1">
                    <!-- Tab panes injected by JS -->
                </div>
            </div>

        </main>
    </div>

    <!-- Footer -->
    <footer class="bg-obsidian-pane border-t border-obsidian-border py-3 text-center shrink-0">
        <a href="index.html"
            class="text-obsidian-textMuted hover:text-obsidian-accent text-xs transition-colors no-underline">
            HomeLab Playground
        </a>
    </footer>

    <script>
        /* =========================================
           1. CONSTANTS & CONFIGURATION
           ========================================= */

        // CONFIG_MAP defines the structure and mapping of the SonicWall config
        const CONFIG_MAP = {
            "Summary": {
                "firewallName": "Hostname",
                "shortProdName": "Model",
                "buildNum": "Firmware Version",
                "serialNum": "Serial Number",
                "localeVersionStr": "Language"
            },
            "Zones": {
                "_array": "zoneObjId",
                "zoneObjId": "Name",
                "zoneObjZoneType": "Zone Type",
                "zoneObjIntraZoneCom": "Interface Trust",
                "zoneObjGavProfile": "GAV Enabled",
                "zoneObjASProfile": "AS Enabled",
                "zoneObjMyIDPProfile": "IPS Enabled",
                "zoneObjACProfile": "App Control Enabled",
                "zoneObjDPISSLSProfile": "DPI SSL Server Enabled",
                "zoneObjDPISSLCProfile": "DPI Client Enabled",
                "zoneObjEnableContentFiltering": "CFS Enabled",
                // Computed fields
                "computed_MemberInterfaces": "Member Interfaces"
            },
            "Interfaces": {
                "_array": "iface_ifnum",
                "iface_name": "Name",
                "interface_Zone": "Zone",
                "iface_comment": "Comment",
                "iface_lan_ip": "IP Address",
                "iface_wan_ip": "IP Address",
                "iface_static_ip": "IP Address",
                "iface_lan_mask": "Subnet Mask",
                "iface_static_mask": "Subnet Mask",
                "iface_static_gateway": "Gateway",
                "iface_lan_default_gw": "Gateway",
                "iface_wan_default_gw": "Gateway",
                "iface_https_mgmt": "HTTPS Mgmt",
                "iface_ping_mgmt": "Ping Mgmt",
                "iface_ssh_mgmt": "SSH Mgmt",
                "iface_snmp_mgmt": "SNMP Mgmt",
                "iface_port_disabled": "Enabled"
            },
            "Access Rules": {
                "_array": "policyAction",
                "policyName": "Name",
                "policyAction": "Action",
                "policySrcZone": "Source Zone",
                "policyDstZone": "Dest Zone",
                "policySrcNet": "Source Address",
                "policyDstNet": "Destination Address",
                "policyDstSvc": "Service",
                "policyComment": "Comment"
            },
            "NAT Rules": {
                "_array": "natPolicyOrigSrc",
                "natPolicyName": "Name",
                "natPolicyOrigSrc": "Original Source",
                "natPolicyOrigDst": "Original Dest",
                "natPolicyOrigSvc": "Original Service",
                "natPolicyTransSrc": "Translated Source",
                "natPolicyTransDst": "Translated Dest",
                "natPolicyTransSvc": "Translated Service",
                "natPolicySrcIface": "Ingress Interface",
                "natPolicyDstIface": "Egress Interface",
                "natPolicyComment": "Comment",
                "natPolicyEnabled": "Status",
                "natPolicyReflexive": "Reflexive",
                "natPolicyDnsDoctorEnable": "DNS Doctoring"
            },
            "Routing Policies": {
                "_array": "pbrObjId",
                "pbrPolicyName": "Name",
                "pbrObjSrc": "Source",
                "pbrObjDst": "Destination",
                "pbrObjSvc": "Service",
                "pbrObjIface": "Interface",
                "pbrObjGw": "Gateway",
                "pbrObjMetric": "Metric",
                "pbrObjType": "Class",
                "pbrObjPriority": "Priority",
                "pbrObjProbe": "Probe",
                "pbrObjDisableOnProbeFail": "Disable on Fail"
            },
            "Address Objects": {
                "_array": "addrObjId",
                "addrObjId": "ID",
                "addrObjIdDisp": "Name",
                "addrObjType": "Type",
                "addrObjIp1": "IP/Start",
                "addrObjIp2": "Mask/End",
                "addrObjZone": "Zone",
                "addrObjProperties": "Properties",
                // Computed/Enriched
                "Members": "Group Members",
                "addrObjCustom": "Custom/Default"
            },
            "Service Objects": {
                "_array": "svcObjId",
                "svcObjId": "Name",
                "svcObjIpType": "Protocol",
                "svcObjType": "Protocol",
                "svcObjPort1": "Port Start",
                "svcObjPort2": "Port End",
                "svcObjProperties": "Properties",
                "svcObjGuiClass": "Custom/Default",
                "Members": "Group Members"
            },
            "Service Group Mappings": {
                "_array": "so_atomToGrp",
                "so_atomToGrp": "Member",
                "so_grpToGrp": "Group"
            },
            "Security Services": {
                "GAV": {
                    "gavEnableScanning": "Enable GAV Scanning",
                    "gavEnableInbound": "Enable Inbound",
                    "gavEnableOutbound": "Enable Outbound"
                },
                "IPS": {
                    "isIDPEnabled": "Enable IPS",
                    "idpPreventHighPriority": "Prevent High Pri",
                    "idpDetectHighPriority": "Detect High Pri",
                    "idpPreventMediumPriority": "Prevent Med Pri",
                    "idpDetectMediumPriority": "Detect Med Pri"
                },
                "Geo-IP": {
                    "geoIpBlkMode": "Block Mode",
                    "geoIpLoggingEnabled": "Logging Enabled",
                    "geoEnforcement": "Enable Enforcement",
                    "blockUnknownGeo": "Block Unknown"
                },
                "Botnet": {
                    "botnetBlock": "Block Botnet",
                    "botnetLoggingEnabled": "Logging Enabled"
                },
                "AS": {
                    "asEnableScanning": "Enable Anti-Spyware",
                    "asEnableInbound": "Enable Inbound",
                    "asEnableOutbound": "Enable Outbound"
                }
            },
            "DNS": {
                "dns_server_one": "DNS Server 1",
                "dns_server_two": "DNS Server 2",
                "dns_server_three": "DNS Server 3",
                "dnsProxyEnable": "Enable Proxy",
                "enforceDnsProxy_enable": "Enforce All",
                "dnsCache_enable": "Enable Cache",
                "dnsProxySplit_enable": "Enable Split DNS"
            },
            "DHCP": {
                "Settings": {
                    "enableDHCP": "Enable DHCP Server",
                    "dhcpPersEnable": "Persistence",
                    "DHCP_CONFLICT_DETECT": "Conflict Detection"
                },
                "Static Scopes": {
                    "_array": "prefs_dhstaticip",
                    "prefs_dhstaticscopeactive": "Enabled",
                    "prefs_dhstaticname": "Name",
                    "prefs_dhstaticip": "IP Address",
                    "prefs_dhstatichw": "MAC Address",
                    "prefs_dhstaticsubnetmask": "Subnet Mask",
                    "prefs_dhstaticrouter": "Gateway",
                    "prefs_dhstaticdns0": "DNS 1"
                },
                "Dynamic Scopes": {
                    "_array": "prefs_dhdynstart",
                    "prefs_dhdynscopeactive": "Enabled",
                    "prefs_dhdynstart": "Range Start",
                    "prefs_dhdynend": "Range End",
                    "prefs_dhdynrouter": "Gateway",
                    "prefs_dhdynsubnetmask": "Subnet Mask",
                    "prefs_dhdynlease": "Lease (min)",
                    "prefs_dhdyndns0": "DNS 1",
                    "prefs_dhdyndns1": "DNS 2",
                    "prefs_dhdynComment": "Comment"
                }
            },
            "IP Helper": {
                "_array": "iphAppName",
                "iphAppName": "Application",
                "iphAppUdp1": "Port 1",
                "iphAppUdp2": "Port 2",
                "iphAppTimeout": "Timeout",
                "iphAppEnabled": "Enabled"
            }
        };

        const COLUMN_ORDER = {
            "Interfaces": ["Name", "Zone", "IP Address", "Subnet Mask", "Enabled", "Comment"],
            "Zones": ["Name", "Zone Type", "Member Interfaces", "Interface Trust", "GAV Enabled", "AS Enabled", "IPS Enabled", "App Control Enabled", "DPI SSL Server Enabled", "DPI Client Enabled"],
            "Access Rules": ["Name", "Action", "Source Zone", "Dest Zone", "Source Address", "Destination Address", "Service", "Comment"],
            "Address Objects": ["Name", "IP/Start", "Mask/End", "Type", "Zone", "Custom/Default"],
            "Address Groups": ["Name", "Group Members", "Custom/Default"],
            "Service Objects": ["Name", "Protocol", "Port Start", "Port End", "Custom/Default"],
            "Service Groups": ["Name", "Group Members", "Custom/Default"],
            "Routing Policies": ["Name", "Source", "Destination", "Service", "Interface", "Gateway", "Metric", "Class"],
            "NAT Rules": ["Name", "Status", "Ingress Interface", "Egress Interface", "Original Source", "Original Dest", "Original Service", "Translated Source", "Translated Dest", "Translated Service"],
            "IP Helper": ["Application", "Port 1", "Port 2", "Timeout", "Enabled"]
        };

        const ZONE_TYPE_MAP = {
            "1": "Trusted", "0": "Untrusted", "2": "Public", "5": "Encrypted", "8": "SSL VPN", "4": "Wireless", "6": "Untrusted"
        };
        // ... (skip lines 363-1017, using separate chunks or assuming I must replace contiguous block?
        // I will just replace COLUMN_ORDER and renderServiceObjectsTabs separately.
        // This replacement only covers COLUMN_ORDER. I'll use multi check below.)
        const ACTION_MAP = {
            "2": "ALLOW", "0": "DENY", "1": "DISCARD"
        };
        const ADDRESS_OBJ_TYPE_MAP = {
            "1": "Host", "2": "Range", "4": "Network", "8": "Group", "9": "MAC", "10": "FQDN", "0": "Host"
        };
        const SERVICE_PROTOCOL_MAP = {
            "1": "TCP",
            "0": "UDP",
            "6": "TCP",
            "17": "UDP",
            "2": "Group"
        };
        const ROUTING_TYPE_MAP = {
            "1": "Custom", "0": "Default"
        };

        const ANY_INTERFACE_ID = "4294967295";
        const ANY_VALUE = "Any";

        /* =========================================
           2. GLOBAL STATE & DOM ELEMENTS
           ========================================= */

        let PARSED_DATA = {};
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');

        if (fileInput) {
            fileInput.addEventListener('change', handleFileSelect);
        }

        /* =========================================
           3. EVENT HANDLERS
           ========================================= */

        function togglePasteModal() {
            const modal = document.getElementById('pasteModal');
            modal.classList.toggle('hidden');
            if (!modal.classList.contains('hidden')) {
                const area = document.getElementById('pasteArea');
                area.value = '';
                area.focus();
            }
        }

        function processPaste() {
            const text = document.getElementById('pasteArea').value;
            if (text && text.trim().length > 0) {
                updateFileNameDisplay("Pasted Configuration");
                parseConfig(text);
                togglePasteModal();
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                updateFileNameDisplay(file.name);
                const reader = new FileReader();
                reader.onload = function (e) {
                    const text = e.target.result;
                    parseConfig(text);
                };
                reader.readAsText(file);
            } else {
                clearInput();
            }
        }

        function updateFileNameDisplay(name) {
            fileNameDisplay.textContent = name;
            fileNameDisplay.classList.remove('italic', 'text-obsidian-textMuted');
            fileNameDisplay.classList.add('font-semibold', 'text-white');
        }

        function clearInput() {
            fileInput.value = '';
            fileNameDisplay.textContent = 'No file chosen';
            fileNameDisplay.classList.add('italic', 'text-obsidian-textMuted');
            fileNameDisplay.classList.remove('font-semibold', 'text-white');

            document.getElementById('resultsArea').classList.add('hidden');
            document.getElementById('emptyState').classList.add('hidden'); // Ensure empty state is hidden when clearing
            PARSED_DATA = {};
        }

        function copyToClipboard() {
            if (Object.keys(PARSED_DATA).length === 0) return;
            const json = JSON.stringify(PARSED_DATA, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                alert('Parsed JSON copied to clipboard!');
            });
        }

        function switchTab(tabId) {
            // Hide all contents
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            // Deactivate all nav items
            document.querySelectorAll('.nav-item').forEach(el => {
                el.classList.remove('bg-obsidian-accent/10', 'text-obsidian-accent', 'border-r-2', 'border-obsidian-accent');
                el.classList.add('text-obsidian-textMuted', 'hover:bg-obsidian-border/50', 'hover:text-obsidian-text');

                // Reset icons
                const icon = el.querySelector('i');
                if (icon) icon.className = icon.dataset.originalClass || icon.className;
            });

            // Show target content
            const targetContent = document.getElementById(tabId);
            if (targetContent) {
                targetContent.classList.add('active');

                // Update Header Title
                const titleEl = document.getElementById('currentSectionTitle');
                if (titleEl) titleEl.textContent = targetContent.dataset.title || "Section";

                // Scroll top
                document.getElementById('mainContent').scrollTop = 0;
            }

            // Activate target nav item
            const activeLink = document.querySelector(`.nav-item[data-target="${tabId}"]`);
            if (activeLink) {
                activeLink.classList.remove('text-obsidian-textMuted', 'hover:bg-obsidian-border/50', 'hover:text-obsidian-text');
                activeLink.classList.add('bg-obsidian-accent/10', 'text-obsidian-accent', 'border-r-2', 'border-obsidian-accent');
            }
        }

        // Search Filter for Sidebar
        const navSearch = document.getElementById('navSearch');
        if (navSearch) {
            navSearch.addEventListener('input', (e) => {
                const term = e.target.value.toLowerCase();
                document.querySelectorAll('.nav-item').forEach(el => {
                    const text = el.innerText.toLowerCase();
                    el.style.display = text.includes(term) ? 'flex' : 'none';
                });
            });
        }

        /* =========================================
           4. PARSING LOGIC
           ========================================= */

        function parseConfig(configText) {
            // 1. Build lookup maps
            const interfaceMap = buildInterfaceMap(configText);
            const addressObjectMap = buildAddressObjectMap(configText);
            const groupMemberMap = buildAddressGroupMemberMap(configText);

            // 2. Parse the text map
            PARSED_DATA = parseConfigText(configText, interfaceMap, addressObjectMap, groupMemberMap);

            // 3. Render
            renderView(PARSED_DATA);

            // 4. Update UI state
            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('emptyState').classList.add('hidden');
        }

        function parseConfigText(configText, interfaceMap, addressObjectMap, groupMemberMap) {
            const results = {};
            const lines = configText.split('\n');

            // Helper to collect Interfaces for Zone calculation
            let allInterfaces = [];

            for (const [sectionName, sectionMap] of Object.entries(CONFIG_MAP)) {

                const firstKey = Object.keys(sectionMap)[0];
                const isNested = (typeof sectionMap[firstKey] === 'object' && sectionMap[firstKey] !== null);

                if (isNested) {
                    results[sectionName] = {};
                    for (const [subSectionName, subMap] of Object.entries(sectionMap)) {
                        if (subMap._array) {
                            results[sectionName][subSectionName] = parseGenericArray(lines, subMap, interfaceMap, addressObjectMap);
                        } else {
                            results[sectionName][subSectionName] = parseGenericKV(lines, subMap);
                        }
                    }
                } else {
                    if (sectionMap._array) {
                        let parsedArray = parseGenericArray(lines, sectionMap, interfaceMap, addressObjectMap);

                        if (sectionName === "Interfaces") {
                            parsedArray.sort((a, b) => {
                                const nameA = a["Name"] || "";
                                const nameB = b["Name"] || "";
                                return nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
                            });

                            // Fix WAN IP or missing IP by looking up Address Object "Xn IP"
                            const addressObjects = results["Address Objects"] || [];
                            parsedArray.forEach(iface => {
                                // 1. Check for 0.0.0.0 or missing IP
                                const currentIP = iface["IP Address"];
                                if (!currentIP || currentIP === "0.0.0.0" || currentIP === "(DHCP)") {
                                    const ifaceName = iface["Name"];
                                    // Try to find Address Object "Xn IP"
                                    const targetName = `${ifaceName} IP`;

                                    const addrObj = addressObjects.find(obj =>
                                        obj["Display Name"] === targetName || obj["Name"] === targetName
                                    );

                                    if (addrObj && addrObj["IP/Start"] && addrObj["IP/Start"] !== "0.0.0.0") {
                                        iface["IP Address"] = addrObj["IP/Start"];
                                        // Optional: Update mask if available and missing
                                        if (addrObj["Mask/End"] && (!iface["Subnet Mask"] || iface["Subnet Mask"] === "0.0.0.0")) {
                                            iface["Subnet Mask"] = addrObj["Mask/End"];
                                        }
                                    } else {
                                        // If still not found and valid WAN/X1, mark as DHCP
                                        if ((iface["Zone"] === "WAN" || (ifaceName && ifaceName.startsWith("X1"))) && (currentIP === "0.0.0.0" || !currentIP)) {
                                            iface["IP Address"] = "(DHCP)";
                                        }
                                    }
                                }
                            });
                            allInterfaces = parsedArray;
                        }

                        if (sectionName === "Address Objects" && groupMemberMap) {
                            parsedArray.forEach(obj => {
                                if (obj["Name"] && groupMemberMap[obj["Name"]]) {
                                    obj["Group Members"] = groupMemberMap[obj["Name"]];
                                }
                            });
                        }
                        results[sectionName] = parsedArray;
                    } else {
                        results[sectionName] = parseGenericKV(lines, sectionMap);
                    }
                }
            }

            // Post-Process: Calculate Member Interfaces for Zones
            if (results["Zones"] && Array.isArray(results["Zones"])) {
                results["Zones"].forEach(zone => {
                    const zoneName = zone["Name"];
                    if (zoneName) {
                        const members = allInterfaces.filter(iface => iface["Zone"] === zoneName).map(iface => iface["Name"]);
                        if (members.length > 0) {
                            zone["Member Interfaces"] = members;
                        }
                    }
                });
            }

            // Post-Process: Service Groups Enrichment
            if (results["Service Group Mappings"] && results["Service Objects"]) {
                const serviceGroupMap = {};
                results["Service Group Mappings"].forEach(mapping => {
                    const group = mapping["Group"];
                    const member = mapping["Member"];
                    if (group && member) {
                        if (!serviceGroupMap[group]) serviceGroupMap[group] = [];
                        serviceGroupMap[group].push(member);
                    }
                });

                results["Service Objects"].forEach(obj => {
                    if (obj["Name"] && serviceGroupMap[obj["Name"]]) {
                        obj["Group Members"] = serviceGroupMap[obj["Name"]];
                    }
                });
            }

            return results;
        }

        function buildInterfaceMap(text) {
            const map = {};
            const lines = text.split('\n');
            const ifNumRegex = /^iface_ifnum_(\d+)=(\d+)/;
            const ifNameRegex = /^iface_name_(\d+)=(.*)/;
            const temp = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match = trimmed.match(ifNumRegex);
                if (match) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].id = match[2];
                    continue;
                }
                match = trimmed.match(ifNameRegex);
                if (match) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].name = decodeURIComponent(match[2]);
                }
            }

            Object.values(temp).forEach(obj => {
                if (obj.id && obj.name) {
                    map[obj.id] = obj.name;
                }
            });

            map["-1"] = "Any";
            map[ANY_INTERFACE_ID] = "Any";
            return map;
        }

        function buildAddressObjectMap(text) {
            const map = {};
            const lines = text.split('\n');
            const idRegex = /^addrObjId_(\d+)=(.*)/;
            const ip1Regex = /^addrObjIp1_(\d+)=(.*)/;
            const ip2Regex = /^addrObjIp2_(\d+)=(.*)/;
            const typeRegex = /^addrObjType_(\d+)=(.*)/;
            const fqdnIdRegex = /^addrObjFqdnId_(\d+)=(.*)/;
            const fqdnValRegex = /^addrObjFqdn_(\d+)=(.*)/;

            const temp = {};
            const tempFqdn = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match;
                if ((match = trimmed.match(idRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].name = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(ip1Regex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].ip1 = match[2];
                } else if ((match = trimmed.match(ip2Regex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].ip2 = match[2];
                } else if ((match = trimmed.match(typeRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].type = match[2];
                } else if ((match = trimmed.match(fqdnIdRegex))) {
                    const idx = match[1];
                    if (!tempFqdn[idx]) tempFqdn[idx] = {};
                    tempFqdn[idx].name = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(fqdnValRegex))) {
                    const idx = match[1];
                    if (!tempFqdn[idx]) tempFqdn[idx] = {};
                    tempFqdn[idx].fqdn = match[2];
                }
            }

            Object.values(temp).forEach(obj => {
                if (obj.name) {
                    let desc = "";
                    if (obj.type === "8") {
                        desc = "Group";
                    } else if (obj.ip1) {
                        desc = obj.ip1;
                        if (obj.type === "4" && obj.ip2 && obj.ip2 !== "0.0.0.0") {
                            desc = `${obj.ip1}/${obj.ip2}`;
                        } else if (obj.type === "2" && obj.ip2 && obj.ip2 !== "0.0.0.0") {
                            desc = `${obj.ip1}-${obj.ip2}`;
                        }
                    }
                    if (desc) map[obj.name] = desc;
                }
            });

            Object.values(tempFqdn).forEach(obj => {
                if (obj.name && obj.fqdn) {
                    map[obj.name] = obj.fqdn;
                }
            });

            return map;
        }

        function buildAddressGroupMemberMap(text) {
            const map = {};
            const lines = text.split('\n');
            const atomRegex = /^addro_atomToGrp_(\d+)=(.*)/;
            const grpRegex = /^addro_grpToGrp_(\d+)=(.*)/;
            const temp = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match;
                if ((match = trimmed.match(atomRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].atom = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(grpRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].grp = decodeURIComponent(match[2]);
                }
            }

            Object.values(temp).forEach(item => {
                if (item.atom && item.grp) {
                    if (!map[item.grp]) map[item.grp] = [];
                    map[item.grp].push(item.atom);
                }
            });

            return map;
        }

        function parseGenericKV(lines, map) {
            const result = {};
            // Pre-seed with all known keys
            Object.values(map).forEach(label => result[label] = "");

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                for (const [key, label] of Object.entries(map)) {
                    if (trimmed.startsWith(key + '=')) {
                        let value = trimmed.substring(key.length + 1);
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (key === 'dns_use_static_servers') {
                            if (value === '1' || value.toLowerCase() === 'on') value = 'True';
                            else if (value === '0' || value.toLowerCase() === 'off') value = 'False';
                        }

                        result[label] = value;
                        break;
                    }
                }
            }
            return result;
        }

        function parseGenericArray(lines, map, interfaceMap, addressObjectMap) {
            const tempMap = {};

            for (const line of lines) {
                const trimmed = line.trim();
                for (const [key, label] of Object.entries(map)) {
                    if (key === '_array') continue;

                    const regex = new RegExp(`^${key}_(\\d+)=(.*)`);
                    const match = trimmed.match(regex);

                    if (match) {
                        const index = match[1];
                        let value = match[2];
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (!tempMap[index]) tempMap[index] = {};

                        if (key === 'zoneObjZoneType') value = ZONE_TYPE_MAP[value] || value;
                        if (key === 'addrObjType') value = ADDRESS_OBJ_TYPE_MAP[value] || value;
                        if (key === 'policyAction') value = ACTION_MAP[value] || value;
                        if (key === 'svcObjType' || key === 'svcObjIpType') value = SERVICE_PROTOCOL_MAP[value] || value;
                        if (key === 'pbrObjType') value = ROUTING_TYPE_MAP[value] || "Default";

                        if (key === 'iface_port_disabled') {
                            // Invert: port_disabled=off means Enabled=true
                            // AND must have a Zone assigned (otherwise it's Unassigned/Disabled)
                            const isPortDisabled = value === "1" || value.toLowerCase() === "on" || value.toLowerCase() === "true";
                            const zone = tempMap[index]["Zone"];
                            const hasZone = zone && zone.trim() !== "";

                            value = (!isPortDisabled && hasZone) ? "Enabled" : "Disabled";
                        }

                        if (key === 'policySrcIf' || key === 'policyDstIf' ||
                            key === 'natPolicySrcIface' || key === 'natPolicyDstIface' ||
                            key === 'pbrObjIface') {
                            value = interfaceMap[value] || value;
                        }

                        if ((key === 'policySrcNet' || key === 'policyDstNet' ||
                            key === 'policySrcSvc' || key === 'policyDstSvc' ||
                            key === 'natPolicyOrigSrc' || key === 'natPolicyOrigDst' ||
                            key === 'natPolicyOrigSvc' ||
                            key === 'pbrObjSrc' || key === 'pbrObjDst' ||
                            key === 'pbrObjSvc' || key === 'pbrObjGw' || key === 'pbrObjIface'
                        ) && value === "") {
                            value = ANY_VALUE;
                        }

                        if ((key === 'natPolicyTransSrc' || key === 'natPolicyTransDst' || key === 'natPolicyTransSvc') && value === "") {
                            value = "Original";
                        }

                        if ((key === 'policySrcNet' || key === 'policyDstNet' ||
                            key === 'natPolicyOrigSrc' || key === 'natPolicyOrigDst' ||
                            key === 'natPolicyTransSrc' || key === 'natPolicyTransDst' ||
                            key === 'pbrObjSrc' || key === 'pbrObjDst' || key === 'pbrObjGw'
                        ) && value !== ANY_VALUE) {
                            if (addressObjectMap && addressObjectMap[value]) {
                                value = `${value} <span class="text-obsidian-textMuted text-xs">(${addressObjectMap[value]})</span>`;
                            }
                        }

                        // Prevent overwriting valid IP with 0.0.0.0 or empty
                        const currentValue = tempMap[index][label];
                        const isZeroIP = (value === "0.0.0.0" || value === "");

                        if ((label === "IP Address" || label === "Gateway") && currentValue && currentValue !== "0.0.0.0" && currentValue !== "(DHCP)" && isZeroIP) {
                            // Skip overwriting a valid IP or Gateway with 0.0.0.0
                        } else {
                            tempMap[index][label] = value;
                        }
                        break;
                    }
                }
            }
            // Post-process for missing default values (specifically for Routing Class)
            Object.values(tempMap).forEach(obj => {
                if (obj.hasOwnProperty("Gateway") && obj.hasOwnProperty("Metric")) {
                    // User feedback indicates "Auto-named" policies without type are considered "Custom"
                    // and "Default" policies (standard routing table) are not in this file.
                    // So default to "Custom" if missing.
                    if (!obj["Class"]) obj["Class"] = "Custom";
                }

                // Address Object Logic: Fallback Name & Custom/Default Detection
                if (obj.hasOwnProperty("ID") && obj.hasOwnProperty("Type") && obj.hasOwnProperty("Zone")) {
                    // Fallback Name
                    if (!obj["Name"] || obj["Name"] === "") {
                        obj["Name"] = obj["ID"];
                    }

                    // Custom/Default Logic based on Properties (793 = Default/System Objects, 29 = Default/System Groups)
                    // If properties are missing, fallback to heuristic or default to Custom.
                    if (obj.hasOwnProperty("Properties")) {
                        obj["Custom/Default"] = (obj["Properties"] === "793" || obj["Properties"] === "29") ? "Default" : "Custom";
                    } else {
                        // Heuristic Fallback (legacy/safety)
                        const name = obj["Name"] || "";
                        const id = obj["ID"] || "";
                        const isDefault = /^(X\d+\s+(IP|Subnet)|All\s+|WAN\s+|LAN\s+|DMZ\s+)/i.test(name) ||
                            /^(X\d+\s+(IP|Subnet)|All\s+|WAN\s+|LAN\s+|DMZ\s+)/i.test(id);
                        obj["Custom/Default"] = isDefault ? "Default" : "Custom";
                    }
                }

                // Service Object Logic: Custom/Default
                if (obj.hasOwnProperty("Properties") && obj.hasOwnProperty("Protocol")) {
                    // 14 = Custom, others (e.g. 11293) = Default
                    if (obj["Properties"] === "14") {
                        obj["Custom/Default"] = "Custom";
                    } else {
                        obj["Custom/Default"] = "Default";
                    }
                }
            });

            return Object.values(tempMap);
        }

        /* =========================================
           5. RENDERING LOGIC
           ========================================= */

        function renderView(data) {
            const sidebarNav = document.getElementById('sidebarNav');
            const tabsContent = document.getElementById('tabsContent');

            sidebarNav.innerHTML = '';
            tabsContent.innerHTML = '';

            // Define icons for known sections
            const sectionIcons = {
                "Zones": "fa-vector-square",
                "Interfaces": "fa-network-wired",
                "Access Rules": "fa-shield-alt",
                "NAT Rules": "fa-exchange-alt",
                "Routing Policies": "fa-route",
                "Address Objects": "fa-map-marker-alt",
                "Service Objects": "fa-cube",
                "Service Group Mappings": "fa-layer-group",
                "Security Services": "fa-user-shield",
                "DNS": "fa-server",
                "DHCP": "fa-sitemap",
                "Summary": "fa-info-circle"
            };

            let firstTabId = null;

            // Sort sections: Critical ones first
            const sectionOrder = ["Summary", "Interfaces", "Zones", "Address Objects", "Service Objects", "Access Rules", "NAT Rules", "Routing Policies", "DHCP", "DNS"];
            const sortedKeys = Object.keys(data).sort((a, b) => {
                const idxA = sectionOrder.indexOf(a);
                const idxB = sectionOrder.indexOf(b);
                if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                if (idxA !== -1) return -1;
                if (idxB !== -1) return 1;
                return a.localeCompare(b);
            });

            for (const sectionName of sortedKeys) {
                const sectionData = data[sectionName];
                if (sectionName === 'CLI' || sectionName === 'Service Group Mappings') continue;

                const tabId = sectionName.replace(/\s+/g, '-').toLowerCase();
                if (!firstTabId) firstTabId = tabId;

                // Create Sidebar Item
                const btn = document.createElement('button');
                btn.className = `nav-item w-full flex items-center px-3 py-2 text-sm font-medium rounded-md transition-all duration-200 group text-obsidian-textMuted hover:bg-obsidian-border/50 hover:text-obsidian-text mb-1`;
                btn.dataset.target = tabId;
                btn.onclick = () => switchTab(tabId);

                const iconClass = sectionIcons[sectionName] || "fa-circle";

                // Count items if array
                let countBadge = '';
                if (Array.isArray(sectionData)) {
                    countBadge = `<span class="ml-auto bg-obsidian-border text-obsidian-textMuted text-xs py-0.5 px-2 rounded-full group-hover:bg-obsidian-bg group-hover:text-white transition-colors">${sectionData.length}</span>`;
                }

                btn.innerHTML = `
                    <i class="fa-solid ${iconClass} w-5 text-center mr-3 text-obsidian-textMuted group-hover:text-obsidian-accent transition-colors" data-original-class="fa-solid ${iconClass}"></i>
                    <span class="truncate">${sectionName}</span>
                    ${countBadge}
                `;
                sidebarNav.appendChild(btn);

                // Create Content Pane
                const contentDiv = document.createElement('div');
                contentDiv.id = tabId;
                contentDiv.dataset.title = sectionName;
                contentDiv.className = `tab-content hidden space-y-6 animate-fade-in`; // Add animation class if available, or straight standard

                const isNested = !Array.isArray(sectionData) && Object.values(sectionData).some(v => typeof v === 'object');

                if (isNested) {
                    renderNestedSection(contentDiv, sectionData);
                } else if (sectionName === "Address Objects" && Array.isArray(sectionData)) {
                    renderAddressObjectsTabs(contentDiv, sectionData);
                } else if (sectionName === "Service Objects" && Array.isArray(sectionData)) {
                    renderServiceObjectsTabs(contentDiv, sectionData);
                } else if (Array.isArray(sectionData)) {
                    renderArrayTableSorted(contentDiv, sectionData, sectionName);
                } else {
                    renderKVTable(contentDiv, sectionData);
                }

                tabsContent.appendChild(contentDiv);
            }

            // Select first tab
            if (firstTabId) {
                switchTab(firstTabId);
            }
        }

        function renderNestedSection(container, data) {
            for (const [subTitle, subData] of Object.entries(data)) {
                const h3 = document.createElement('h3');
                h3.className = "text-lg font-medium leading-6 text-white mb-2 pb-1 border-b border-obsidian-border";
                h3.innerText = subTitle;
                container.appendChild(h3);

                const subContainer = document.createElement('div');
                subContainer.className = "mb-8";
                if (Array.isArray(subData)) {
                    renderArrayTableSorted(subContainer, subData, subTitle);
                } else {
                    renderKVTable(subContainer, subData);
                }
                container.appendChild(subContainer);
            }
        }

        function renderAddressObjectsTabs(container, data) {
            const groups = [], custom = [], checkDefault = [], all = [];

            data.forEach(item => {
                const type = item["Type"];
                // Check if it's a group: explicit Type "Group", numerical "8", or has Group Members populated
                const isGroup = type === "Group" || type === "8" || (item["Group Members"] && item["Group Members"].length > 0);

                if (isGroup) {
                    groups.push(item);
                } else {
                    // Normalize Mask/End for display consistency
                    if (!item["Mask/End"] || item["Mask/End"] === "0.0.0.0") {
                        // For hosts (Type 1), mask is usually implied 32 or 255.255.255.255, 
                        // but 0.0.0.0 in dump usually means single IP if it's a Host.
                        // Let's leave it blank or strict checked if needed.
                        // Actually existing logic set it to 255.255.255.255 if missing.
                        if (type === "Host" || type === "1") {
                            item["Mask/End"] = "255.255.255.255";
                        }
                    }
                    all.push(item);

                    if (item["Custom/Default"] === "Custom") {
                        custom.push(item);
                    } else {
                        checkDefault.push(item);
                    }
                }
            });

            // Sub-Tabs Header
            const subNav = document.createElement('div');
            subNav.className = "flex space-x-2 mb-4 border-b border-obsidian-border";
            const subContent = document.createElement('div');

            // Categories matching Service Objects style
            const categories = [
                { name: "Address Objects", data: all, section: "Address Objects" },
                { name: "Address Groups", data: groups, section: "Address Groups" }, // Use specific col order for groups
                { name: "Custom", data: custom, section: "Address Objects" }, // Fallback to generic cols? Or maybe we need dynamic cols?
                { name: "Default", data: checkDefault, section: "Address Objects" }
            ];

            categories.forEach((cat, idx) => {
                const btn = document.createElement('button');
                btn.className = `px-3 py-2 text-sm font-medium transition-colors border-b-2 ${idx === 0 ? 'border-obsidian-accent text-obsidian-accent' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text'}`;
                btn.innerText = `${cat.name} (${cat.data.length})`;

                btn.onclick = (e) => {
                    subNav.querySelectorAll('button').forEach(b => {
                        b.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-transparent text-obsidian-textMuted hover:text-obsidian-text";
                    });
                    e.target.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-obsidian-accent text-obsidian-accent";

                    subContent.innerHTML = '';
                    // For "Groups" tab, verify if we should use "Address Groups" column order (less cols) or standard.
                    // For "Custom" and "Default", items are mixed. 
                    // renderArrayTableSorted uses the passed sectionName to look up COLUMN_ORDER.
                    // If we pass "Address Objects", it uses that order. 
                    // If "Address Groups", it uses that order.

                    // Ideally, Custom/Default views might need a union of columns or just standard "Address Objects" columns.
                    // "Address Groups" col order excludes IP/Start, Mask/End usually.

                    renderArrayTableSorted(subContent, cat.data, cat.section);
                };
                subNav.appendChild(btn);
            });

            container.appendChild(subNav);
            container.appendChild(subContent);

            // Default render first tab
            renderArrayTableSorted(subContent, all, "Address Objects");
        }

        function renderServiceObjectsTabs(container, data) {
            const groups = [], custom = [], checkDefault = [], all = [];

            data.forEach(item => {
                // Determine if item is a group: Protocol is Group OR it has populated members
                const isGroup = (item["Protocol"] === "Group") || (item["Group Members"] && item["Group Members"].length > 0);

                if (isGroup) {
                    groups.push(item);
                } else {
                    // Only add non-groups to the main list (or should main list show all? Usually Objects only)
                    // Let's keep "Services" as "All Individual Objects"
                    all.push(item);

                    if (item["Custom/Default"] === "Custom") {
                        custom.push(item);
                    } else {
                        checkDefault.push(item);
                    }
                }
            });

            // Sub-Tabs Header
            const subNav = document.createElement('div');
            subNav.className = "flex space-x-2 mb-4 border-b border-obsidian-border";
            const subContent = document.createElement('div');

            const categories = [
                { name: "Services", data: all, section: "Service Objects" },
                { name: "Groups", data: groups, section: "Service Groups" },
                { name: "Custom", data: custom, section: "Service Objects" },
                { name: "Default", data: checkDefault, section: "Service Objects" }
            ];

            categories.forEach((cat, idx) => {
                const btn = document.createElement('button');
                btn.className = `px-3 py-2 text-sm font-medium transition-colors border-b-2 ${idx === 0 ? 'border-obsidian-accent text-obsidian-accent' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text'}`;
                btn.innerText = `${cat.name} (${cat.data.length})`;

                btn.onclick = (e) => {
                    subNav.querySelectorAll('button').forEach(b => {
                        b.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-transparent text-obsidian-textMuted hover:text-obsidian-text";
                    });
                    e.target.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-obsidian-accent text-obsidian-accent";

                    subContent.innerHTML = '';
                    renderArrayTableSorted(subContent, cat.data, cat.section);
                };
                subNav.appendChild(btn);
            });

            container.appendChild(subNav);
            container.appendChild(subContent);

            // Default view: Services (Individual Objects)
            renderArrayTableSorted(subContent, all, "Service Objects");
        }


        function renderKVTable(container, data) {
            if (Object.keys(data).length === 0) {
                container.innerHTML += '<p class="text-obsidian-textMuted text-sm italic">No data found.</p>';
                return;
            }
            const table = document.createElement('table');
            table.className = "min-w-full divide-y divide-obsidian-border";
            const tbody = document.createElement('tbody');
            tbody.className = "divide-y divide-obsidian-border";

            for (const [key, value] of Object.entries(data)) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="px-6 py-3 whitespace-nowrap text-sm font-medium text-obsidian-text w-1/3 border-r border-obsidian-border bg-obsidian-pane/50">${key}</td>
                    <td class="px-6 py-3 text-sm text-obsidian-textMuted font-mono break-all">${renderValue(value, key)}</td>
                `;
                tbody.appendChild(tr);
            }
            table.appendChild(tbody);

            const shadowWrapper = document.createElement('div');
            shadowWrapper.className = "shadow ring-1 ring-obsidian-border rounded-lg overflow-hidden bg-obsidian-bg overflow-x-auto";
            shadowWrapper.appendChild(table);
            container.appendChild(shadowWrapper);
        }



        function renderValue(val, key = "") {
            // Priority: Boolean/Icon Columns for Zones, DHCP, & DNS
            // This must come first to override generic "Enabled" text matching
            const booleanCols = ["Interface Trust", "GAV Enabled", "AS Enabled", "IPS Enabled", "App Control Enabled", "DPI SSL Server Enabled", "DPI Client Enabled", "CFS Enabled", "Enable DHCP Server", "Enabled", "Enable Proxy", "Enforce All", "Enable Cache", "Enable Split DNS", "Persistence", "Conflict Detection"];
            if (booleanCols.includes(key)) {
                // Check common truthy values
                const isTrue = val === "1" || String(val).toLowerCase() === "true" || String(val).toLowerCase() === "enabled" || String(val).toLowerCase() === "on";
                if (isTrue) {
                    return '<div class="text-center"><i class="fa-solid fa-check text-obsidian-success"></i></div>';
                } else {
                    return '<div class="text-center"><i class="fa-solid fa-xmark text-obsidian-danger"></i></div>';
                }
            }

            if (Array.isArray(val)) {
                return val.map(v => `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-obsidian-pane border border-obsidian-border text-obsidian-text mr-1 mb-1">${v}</span>`).join('');
            }

            // Generic "Yes/No" Text Logic for other boolean-like keys
            const booleanKeys = ["Enabled", "Status", "Ready", "Active", "IPS", "GAV", "Anti-Spyware", "App Control", "Botnet", "Geo-IP", "DPI-SSL", "DPI-SSL Client", "DPI-SSL Server", "Multicast"];
            const isBooleanKey = booleanKeys.some(k => key.includes(k) || key === k);

            if (isBooleanKey) {
                // Special case for "Status" -> Enabled/Disabled
                if (key === "Status" || key.includes("Status")) {
                    if (val === "1" || String(val).toLowerCase() === "on" || val === "True") {
                        return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">Enabled</span>';
                    }
                    if (val === "0" || String(val).toLowerCase() === "off" || val === "False") {
                        return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-obsidian-pane text-obsidian-textMuted border border-obsidian-border">Disabled</span>';
                    }
                }

                if (val === "1" || String(val).toLowerCase() === "on" || val === "True") {
                    return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">Yes</span>';
                }
                if (val === "0" || String(val).toLowerCase() === "off" || val === "False") {
                    return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">No</span>';
                }
            } else {
                // For non-boolean keys, if value is explicitly "True"/"False" string (Python bools), render them.
                if (String(val).toLowerCase() === "true") return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">Yes</span>';
                if (String(val).toLowerCase() === "false") return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">No</span>';
            }

            if (val === "ALLOW") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">ALLOW</span>';
            }
            if (val === "DENY") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">DENY</span>';
            }
            if (val === "DISCARD" || val === "DROP") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-orange-900/30 text-orange-400 border border-orange-800">DISCARD</span>';
            }
            if (val === ANY_VALUE) {
                return '<span class="italic text-obsidian-textMuted">Any</span>';
            }

            return val;
        }
        function renderArrayTableSorted(container, data, sectionIdentifier = "") {
            if (!data || data.length === 0) {
                container.innerHTML = '<p class="text-obsidian-textMuted text-sm italic">No items found.</p>';
                return;
            }

            // Determine columns
            const customOrder = COLUMN_ORDER[sectionIdentifier];
            let colArray = [];
            if (customOrder) {
                colArray = [...customOrder];
            } else {
                const columns = new Set();
                data.forEach(item => Object.keys(item).forEach(k => columns.add(k)));
                colArray = Array.from(columns);
                const priorityCols = ["Name", "Action", "Zone Type", "IP Address", "Source Zone"];
                colArray.sort((a, b) => {
                    const idxA = priorityCols.indexOf(a);
                    const idxB = priorityCols.indexOf(b);
                    if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                    if (idxA !== -1) return -1;
                    if (idxB !== -1) return 1;
                    return a.localeCompare(b);
                });
                colArray = colArray.filter(col => data.some(row => row[col] && row[col] !== ""));
            }

            // State for sorting and filtering
            let currentData = [...data];
            let sortCol = null;
            let sortAsc = true;
            let filterTerm = "";

            // Filter UI
            const searchContainer = document.createElement('div');
            searchContainer.className = "mb-4 sticky left-0";
            const searchInput = document.createElement('input');
            searchInput.type = "text";
            searchInput.placeholder = `Filter ${sectionIdentifier}...`;
            searchInput.className = "w-full max-w-sm px-4 py-2 bg-obsidian-pane border border-obsidian-border rounded-md text-sm text-obsidian-text focus:outline-none focus:border-obsidian-accent focus:ring-1 focus:ring-obsidian-accent placeholder-obsidian-textMuted transition-colors";

            searchContainer.appendChild(searchInput);
            container.appendChild(searchContainer);

            // Container Wrapper
            const wrapper = document.createElement('div');
            wrapper.className = "shadow ring-1 ring-obsidian-border rounded-lg overflow-hidden bg-obsidian-bg flex flex-col max-h-[calc(100vh-12rem)]"; // Max height
            const scrollContainer = document.createElement('div');
            scrollContainer.className = "overflow-auto table-container flex-1";

            const table = document.createElement('table');
            table.className = "min-w-full divide-y divide-obsidian-border relative";
            const thead = document.createElement('thead');
            thead.className = "bg-obsidian-pane";
            const tbody = document.createElement('tbody');
            tbody.className = "divide-y divide-obsidian-border";

            table.appendChild(thead);
            table.appendChild(tbody);
            scrollContainer.appendChild(table);
            wrapper.appendChild(scrollContainer);
            container.appendChild(wrapper);

            // Render Function
            const render = () => {
                // 1. Filter
                let filtered = currentData;
                if (filterTerm) {
                    filtered = currentData.filter(item => {
                        return colArray.some(col => {
                            const val = item[col] || "";
                            return String(val).toLowerCase().includes(filterTerm);
                        });
                    });
                }

                // 2. Sort
                if (sortCol) {
                    filtered.sort((a, b) => {
                        let valA = a[sortCol] || "";
                        let valB = b[sortCol] || "";

                        // Numeric Sort Attempt
                        const numA = parseFloat(valA);
                        const numB = parseFloat(valB);
                        if (!isNaN(numA) && !isNaN(numB) &&
                            String(numA) === String(valA) && String(numB) === String(valB)) { // strict numeric check
                            return sortAsc ? numA - numB : numB - numA;
                        }

                        // IP Address Sort
                        if (sortCol.includes("IP") || sortCol.includes("Address")) {
                            const ipA = valA.split('.').map(Number);
                            const ipB = valB.split('.').map(Number);
                            if (ipA.length === 4 && ipB.length === 4) {
                                for (let i = 0; i < 4; i++) {
                                    if (ipA[i] !== ipB[i]) return sortAsc ? ipA[i] - ipB[i] : ipB[i] - ipA[i];
                                }
                                return 0;
                            }
                        }

                        // String Sort
                        return sortAsc
                            ? String(valA).localeCompare(String(valB))
                            : String(valB).localeCompare(String(valA));
                    });
                }

                // 3. Render Header
                let thHtml = '<tr>';
                colArray.forEach(col => {
                    let sortIcon = 'fa-sort text-obsidian-border';
                    if (col === sortCol) {
                        sortIcon = sortAsc ? 'fa-sort-up text-obsidian-accent' : 'fa-sort-down text-obsidian-accent';
                    }
                    thHtml += `
                        <th scope="col" data-col="${col}" class="cursor-pointer group hover:bg-obsidian-pane/80 sticky top-0 z-10 bg-obsidian-pane px-4 py-3 text-left text-xs font-semibold text-white uppercase tracking-wider whitespace-nowrap border-b border-obsidian-border shadow-sm select-none">
                            <div class="flex items-center gap-2">
                                ${col}
                                <i class="fa-solid ${sortIcon} text-[10px] transition-colors"></i>
                            </div>
                        </th>`;
                });
                thHtml += '</tr>';
                thead.innerHTML = thHtml;

                // Bind Header Click
                thead.querySelectorAll('th').forEach(th => {
                    th.addEventListener('click', () => {
                        const col = th.dataset.col;
                        if (sortCol === col) {
                            sortAsc = !sortAsc;
                        } else {
                            sortCol = col;
                            sortAsc = true;
                        }
                        render();
                    });
                });

                // 4. Render Body
                tbody.innerHTML = '';
                if (filtered.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="' + colArray.length + '" class="px-6 py-4 text-center text-sm text-obsidian-textMuted italic">No matches found.</td></tr>';
                    return;
                }

                filtered.forEach((item, idx) => {
                    const tr = document.createElement('tr');
                    tr.className = idx % 2 === 0 ? 'bg-transparent' : 'bg-[#2a2a2c]';
                    tr.className += ' hover:bg-[#323234] transition-colors';

                    let tdHtml = '';
                    colArray.forEach(col => {
                        let val = item[col] || "";
                        let content = renderValue(val, col);
                        if (col === "Name" && val.includes && val.includes(":")) {
                            content = `<span class="ml-4 border-l-2 border-obsidian-border pl-2 text-obsidian-textMuted">${content}</span>`;
                        }
                        tdHtml += `<td class="px-4 py-3 text-sm text-obsidian-text whitespace-nowrap">${content}</td>`;
                    });
                    tr.innerHTML = tdHtml;
                    tbody.appendChild(tr);
                });
            };

            // Initial Render
            render();

            // Filter Event
            searchInput.addEventListener('input', (e) => {
                filterTerm = e.target.value.toLowerCase();
                render();
            });
        }
    </script>
</body>

</html>