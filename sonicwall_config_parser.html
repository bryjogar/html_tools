<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SonicWall Config Parser | Homelab Playground</title>
    <link rel="icon" type="image/png" href="favicon.png">

    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <!-- Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        obsidian: {
                            bg: '#1e1e1e',
                            pane: '#252526',
                            border: '#3c3c3c',
                            accent: '#7c3aed',
                            accentHover: '#6d28d9',
                            text: '#cccccc',
                            textMuted: '#9ca3af',
                            success: '#10b981',
                            warning: '#f59e0b',
                            danger: '#ef4444'
                        }
                    },
                    fontFamily: {
                        mono: ['"Fira Code"', 'monospace'],
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3c3c3c;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-btn.active {
            border-bottom-color: #7c3aed;
            color: #7c3aed;
        }
    </style>
</head>

<body class="flex flex-col h-screen overflow-hidden bg-obsidian-bg text-obsidian-text font-sans">

    <!-- Header -->
    <header
        class="h-14 bg-obsidian-pane border-b border-obsidian-border flex items-center justify-between px-6 shrink-0 z-20">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-shield-halved text-obsidian-accent text-lg"></i>
            <h1 class="font-semibold text-white tracking-tight">SonicWall Config Parser</h1>
        </div>
        <div class="flex items-center gap-4">
            <!-- File Input hidden -->
            <input type="file" id="fileInput" accept=".txt,.exp" class="hidden">

            <button onclick="document.getElementById('fileInput').click()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors">
                <i class="fa-solid fa-upload mr-2 text-obsidian-accent"></i>
                Upload
            </button>

            <button onclick="togglePasteModal()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors">
                <i class="fa-solid fa-paste mr-2 text-obsidian-accent"></i>
                Paste Text
            </button>

            <span id="fileName" class="text-sm text-obsidian-textMuted italic max-w-[200px] truncate ml-2">No file
                chosen</span>

            <button onclick="copyToClipboard()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors ml-4">
                <i class="fa-regular fa-copy mr-2 text-obsidian-accent"></i>
                Copy JSON
            </button>
        </div>
    </header>

    <!-- Paste Modal -->
    <div id="pasteModal"
        class="fixed inset-0 bg-black/80 hidden z-50 flex items-center justify-center backdrop-blur-sm">
        <div
            class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl w-full max-w-4xl flex flex-col h-[80vh]">
            <div class="flex items-center justify-between px-6 py-4 border-b border-obsidian-border bg-obsidian-pane">
                <h3 class="text-lg font-semibold text-white"><i
                        class="fa-solid fa-clipboard mr-2 text-obsidian-accent"></i>Paste Configuration</h3>
                <button onclick="togglePasteModal()" class="text-obsidian-textMuted hover:text-white transition-colors">
                    <i class="fa-solid fa-xmark text-xl"></i>
                </button>
            </div>
            <div class="p-0 flex-1 flex flex-col min-h-0">
                <textarea id="pasteArea"
                    class="w-full h-full bg-obsidian-bg border-none p-4 font-mono text-xs text-obsidian-text focus:ring-0 outline-none resize-none"
                    placeholder="Paste SonicWall configuration text here..."></textarea>
            </div>
            <div class="px-6 py-4 border-t border-obsidian-border bg-obsidian-pane flex justify-end space-x-3">
                <button onclick="togglePasteModal()"
                    class="px-4 py-2 text-obsidian-textMuted hover:text-white transition-colors text-sm font-medium">Cancel</button>
                <button onclick="processPaste()"
                    class="bg-obsidian-accent hover:bg-obsidian-accentHover text-white px-6 py-2 rounded-md font-medium transition-colors shadow-lg shadow-obsidian-accent/20">
                    <i class="fa-solid fa-bolt mr-2"></i>Parse Text
                </button>
            </div>
        </div>
    </div>


    <!-- Main Layout -->
    <div class="flex flex-1 overflow-hidden">
        <!-- Sidebar -->
        <aside id="sidebar"
            class="w-64 bg-obsidian-pane border-r border-obsidian-border flex flex-col shrink-0 transition-all duration-300 transform">
            <div class="p-4 border-b border-obsidian-border">
                <div class="relative">
                    <i
                        class="fa-solid fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-obsidian-textMuted text-xs"></i>
                    <input type="text" id="navSearch" placeholder="Search sections..."
                        class="w-full bg-obsidian-bg border border-obsidian-border rounded-md py-1.5 pl-8 pr-3 text-xs text-obsidian-text focus:outline-none focus:border-obsidian-accent transition-colors">
                </div>
            </div>
            <nav id="sidebarNav" class="flex-1 overflow-y-auto py-2 space-y-0.5 px-2">
                <!-- Nav items injected by JS -->
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="flex-1 overflow-auto bg-obsidian-bg relative flex flex-col" id="mainContent">

            <!-- Empty State -->
            <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center opacity-60 z-0">
                <i class="fa-solid fa-file-code text-7xl text-obsidian-border mb-6"></i>
                <h3 class="mt-2 text-xl font-medium text-white">No configuration parsed</h3>
                <p class="mt-2 text-sm text-obsidian-textMuted max-w-sm text-center">Upload a SonicWall configuration
                    file (.txt or .exp) to view the parsed details organized by section.</p>
                <button onclick="document.getElementById('fileInput').click()"
                    class="mt-6 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-obsidian-accent hover:bg-obsidian-accentHover focus:outline-none transition-colors">
                    <i class="fa-solid fa-upload mr-2"></i> Upload File
                </button>
            </div>

            <!-- Content Area -->
            <div id="resultsArea" class="hidden relative z-10 min-h-full flex flex-col">
                <header id="contentHeader"
                    class="bg-obsidian-bg border-b border-obsidian-border px-8 py-5 flex items-center justify-between sticky top-0 z-20 shadow-sm">
                    <div>
                        <h2 id="currentSectionTitle" class="text-2xl font-semibold text-white tracking-tight">Overview
                        </h2>
                        <p id="currentSectionCount" class="text-sm text-obsidian-textMuted mt-1 hidden">0 items</p>
                    </div>
                </header>

                <div id="tabsContent" class="p-8 flex-1">
                    <!-- Tab panes injected by JS -->
                </div>
            </div>

        </main>
    </div>

    <!-- Footer -->
    <footer class="bg-obsidian-pane border-t border-obsidian-border py-3 text-center shrink-0">
        <a href="index.html"
            class="text-obsidian-textMuted hover:text-obsidian-accent text-xs transition-colors no-underline">
            HomeLab Playground
        </a>
    </footer>

    <script>
        /* =========================================
           1. CONSTANTS & CONFIGURATION
           ========================================= */

        // CONFIG_MAP defines the structure and mapping of the SonicWall config
        const CONFIG_MAP = {
            "System": {
                "General": {
                    "firewallName": "Hostname",
                    "shortProdName": "Model",
                    "buildNum": "Firmware Version",
                    "serial": "Serial Number",
                    "localeVersionStr": "Language",
                    "timezone": "Time Zone (ID)",
                    "cloudBkupEnable": "Cloud Backup Enabled",
                    "enableTLS12": "TLS 1.1 or Greater Enabled",
                    "adminLoginTimeout": "Admin Login Timeout",
                    "adminAuthMethod": "Administrator Auth Method"
                },
                "SNMP Settings": {
                    "snmp_Enable": "SNMP Enabled",
                    "snmp_Mib2SysName": "System Name",
                    "snmp_Mib2SysContact": "System Contact",
                    "snmp_Mib2SysLocation": "System Location",
                    "snmp_GetCommunity": "Get Community",
                    "snmp_TrapCommunity": "Trap Community"
                },
                "SNMP Views": {
                    "_array": "Snmp3_View_Name",
                    "Snmp3_View_Name": "View Name",
                    "Snmp3_OID": "OID",
                    "Snmp3_isDefOID": "Default OID"
                }
            },
            "Network": {
                "WAN Load Balancing": {
                    "wlb_Enable": "Enable",
                    "wlb_IsResponder": "Responder Enabled",
                    "wlb_AnyTcpSyn": "Any TCP SYN",
                    "wlb_PriWanIf": "Primary Interface",
                    "wlb_SecWanIf": "Secondary Interface",
                    "wlb_PriProbeMethod1": "Primary Probe Method",
                    "wlb_PriWanProbeHost1": "Probe Target"
                }
            },
            "DNS": {
                "dns_server_one": "DNS Server 1",
                "dns_server_two": "DNS Server 2",
                "dns_server_three": "DNS Server 3",
                "dnsRebind_enable": "DNS Rebinding Attack Prevention",
                "dnsRebind_action": "DNS Rebinding Action",
                "dnsProxySplit_enable": "Split DNS Enabled",
                "dnsOverTCP_enable": "DNS over TCP Enabled"
            },
            "DHCP": {
                "Settings": {
                    "enableDHCP": "Enable DHCP Server",
                    "dhcpPersEnable": "Persistence",
                    "dhcpPersMonitorTime": "Persistence Monitoring Interval (min)",
                    "DHCP_CONFLICT_DETECT": "Conflict Detection"
                },
                "Static Scopes": {
                    "_array": "prefs_dhstaticname",
                    "prefs_dhstaticscopeactive": "Enabled",
                    "prefs_dhstaticname": "Name",
                    "prefs_dhstaticip": "IP Address",
                    "prefs_dhstaticsubnetmask": "Subnet Mask",
                    "prefs_dhstaticrouter": "Gateway",
                    "prefs_dhstaticdns0": "DNS 1",
                    "prefs_dhstaticdns1": "DNS 2"
                },
                "Dynamic Scopes": {
                    "_array": "prefs_dhdynstart",
                    "prefs_dhdynscopeactive": "Enabled",
                    "prefs_dhdynstart": "Range Start",
                    "prefs_dhdynend": "Range End",
                    "prefs_dhdynrouter": "Gateway",
                    "prefs_dhdynsubnetmask": "Subnet Mask",
                    "prefs_dhdynlease": "Lease (min)",
                    "prefs_dhdyndns0": "DNS 1",
                    "prefs_dhdyndns1": "DNS 2",
                    "prefs_dhdynComment": "Comment"
                }
            },
            "IP Helper": {
                "_array": "iphAppName",
                "iphAppName": "Application",
                "iphAppUdp1": "Port 1",
                "iphAppUdp2": "Port 2",
                "iphAppTimeout": "Timeout",
                "iphAppEnabled": "Enabled"
            },
            "Zones": {
                "_array": "zoneObjId",
                "zoneObjId": "Name",
                "zoneObjZoneType": "Zone Type",
                "zoneObjIntraZoneCom": "Interface Trust",
                "zoneObjGavProfile": "GAV Enabled",
                "zoneObjASProfile": "AS Enabled",
                "zoneObjMyIDPProfile": "IPS Enabled",
                "zoneObjACProfile": "App Control Enabled",
                "zoneObjDPISSLSProfile": "DPI SSL Server Enabled",
                "zoneObjDPISSLCProfile": "DPI Client Enabled",
                "zoneObjEnableContentFiltering": "CFS Enabled",
                "computed_MemberInterfaces": "Member Interfaces"
            },
            "Interfaces": {
                "_array": "iface_ifnum",
                "iface_name": "Name",
                "interface_Zone": "Zone",
                "iface_lan_ip": "IP Address",
                "iface_wan_ip": "IP Address",
                "iface_static_ip": "IP Address",
                "iface_lan_mask": "Subnet Mask",
                "iface_static_mask": "Subnet Mask",
                "iface_lan_default_gw": "Gateway",
                "iface_wan_default_gw": "Gateway",
                "iface_static_gateway": "Gateway",
                "iface_comment": "Comment",
                "iface_http_mgmt": "HTTP Mgmt",
                "iface_https_mgmt": "HTTPS Mgmt",
                "iface_ping_mgmt": "Ping Mgmt",
                "iface_ssh_mgmt": "SSH Mgmt",
                "iface_snmp_mgmt": "SNMP Mgmt",
                "iface_port_disabled": "Enabled"
            },
            "Access Rules": {
                "_array": "policyAction",
                "policyName": "Name",
                "policyAction": "Action",
                "policySrcZone": "Source Zone",
                "policyDstZone": "Dest Zone",
                "policySrcNet": "Source Address",
                "policyDstNet": "Destination Address",
                "policyDstSvc": "Service",
                "policyGeoIpBlock": "Geo-IP Filter",
                "policyComment": "Comment"
            },
            "NAT Rules": {
                "_array": "natPolicyOrigSrc",
                "natPolicyName": "Name",
                "natPolicyEnabled": "Enabled",
                "natPolicyOrigSrc": "Orig Source",
                "natPolicyTransSrc": "Trans Source",
                "natPolicyOrigDst": "Orig Dest",
                "natPolicyTransDst": "Trans Dest",
                "natPolicyOrigSvc": "Orig Service",
                "natPolicyTransSvc": "Trans Service",
                "natPolicySrcIface": "Inbound If",
                "natPolicyDstIface": "Outbound If",
                "natPolicyComment": "Comment"
            },
            "Content Filter": {
                "Settings": {
                    "cfsEnabled": "Content Filter Enabled",
                    "cfsEnableHttpsFlting": "HTTPS Filtering Enabled"
                },
                "Profiles": {
                    "_array": "cfsProfileObjId",
                    "cfsProfileObjId": "Profile Name",
                    "cfsProfileEnableSafeSearch": "Safe Search"
                }
            },
            "Firewall": {
                "Settings": {
                    "enableStealthMode": "Stealth Mode Enabled",
                    "randomizeIds": "Randomize IP ID Enabled",
                    "secServicesDPISetting": "Enhanced Security (DPI)",
                    "activeDpiCpuThresh": "DPI CPU Threshold"
                }
            },
            "VPN": {
                "Settings": {
                    "ipsecEnable": "Global VPN Enabled",
                    "vpnPolicyGroup": "Default Group"
                },
                "Policies": {
                    "_array": "vpnPolicyName",
                    "vpnPolicyName": "Name",
                    "vpnPolicyIkeIpAddr": "Gateway",
                    "vpnPolicyIkePresharedKey": "Shared Secret",
                    "vpnPolicyEnabled": "Enabled"
                }
            },
            "SSLVPN": {
                "Settings": {
                    "bandOptSslVpnEnable": "SSLVPN Enabled",
                    "sslvpn_server_gateway": "Server Gateway",
                    "sslvpnIp": "SSLVPN IP",
                    "sslvpnPort": "SSLVPN Port",
                    "sslvpnPubInterface": "Public Interface"
                }
            },
            "Users": {
                "Local Users": {
                    "_array": "userObjId",
                    "userObjId": "Username",
                    "userObjType": "Type",
                    "userObjPrune": "Prune Settings"
                },
                "Local Groups": {
                    "_array": "userGroupObjId",
                    "userGroupObjId": "Group Name"
                },
                "Settings": {
                    "userAuthMethod": "Auth Method",
                    "userSsoEnable": "SSO Enabled"
                }
            },
            "Security Services": {
                "Geo-IP Filter": {
                    "geoEnforcement": "Enable Geo-IP Filter",
                    "geoIpBlkMode": "Block Mode",
                    "geoIpLoggingEnabled": "Enable Logging",
                    "geoIpExcludeObjectName": "Exclusion Object"
                },
                "Botnet Filter": {
                    "botnetBlock": "Enable Botnet Filter",
                    "botnetLoggingEnabled": "Enable Logging",
                    "botnetBlkMode": "Block Mode",
                    "botnetExcludeObjectName": "Exclusion Object"
                },
                "Botnet Exclusions": {
                    "_array": "botnetFilterExcludeObj",
                    "botnetFilterExcludeObj": "Exclusion Object (List)"
                },
                "Gateway Anti-Virus": {
                    "gavCloudEnableScanning": "Enable Cloud Anti-Virus Database",
                    "gavEnableExcludeList": "Enable Gateway AV Exclusion List",
                    "gavExclusionObj": "Exclusion List Address Object",
                    "Settings": {
                        "gavSuppressSMTPResponse": "Disable SMTP Responses",
                        "gavDisableEicarTest": "Disable detection of EICAR test virus",
                        "gavHTTPAcceptRangeBytesKeep": "Enable HTTP Byte-Range requests",
                        "gavFTPPartDownEnable": "Enable FTP REST request"
                    },
                    "Inbound Inspection Protocols": {
                        "gavEnableHTTP": "HTTP",
                        "gavEnableFTP": "FTP",
                        "gavEnableIMAP": "IMAP",
                        "gavEnableSMTP": "SMTP",
                        "gavEnablePOP3": "POP3",
                        "gavEnableTCPStream": "TCP Stream"
                    },
                    "Outbound Inspection Protocols": {
                        "gavEnableOutboundSMTP": "SMTP",
                        "gavEnableOutboundHTTP": "HTTP",
                        "gavEnableOutboundFTP": "FTP",
                        "gavEnableOutTCPStream": "TCP Stream"
                    }
                },
                "Intrusion Prevention": {
                    "idpEnableExcludeList": "Enable IPS Exclusion List",
                    "idpExclusionObj": "Exclusion List Address Object",
                    "isIDPBidirectional": "Apply IPS Signatures Bidirectionally",
                    "High Priority": {
                        "idpPreventHighPriority": "Prevent",
                        "idpDetectHighPriority": "Detect",
                        "idpLRTHigh": "Log Redundancy"
                    },
                    "Medium Priority": {
                        "idpPreventMediumPriority": "Prevent",
                        "idpDetectMediumPriority": "Detect",
                        "idpLRTMedium": "Log Redundancy"
                    },
                    "Low Priority": {
                        "idpPreventLowPriority": "Prevent",
                        "idpDetectLowPriority": "Detect",
                        "idpLRTLow": "Log Redundancy"
                    }
                },
                "Anti-Spyware": {
                    "asEnableExcludeList": "Enable Anti-Spyware Exclusion List",
                    "asExclusionObj": "Exclusion List Address Object",
                    "asSuppressSMTPResponse": "Disable SMTP Responses",
                    "High Priority": {
                        "asPreventHighPriority": "Prevent",
                        "asDetectHighPriority": "Detect",
                        "asLRTHigh": "Log Redundancy"
                    },
                    "Medium Priority": {
                        "asPreventMediumPriority": "Prevent",
                        "asDetectMediumPriority": "Detect",
                        "asLRTMedium": "Log Redundancy"
                    },
                    "Low Priority": {
                        "asPreventLowPriority": "Prevent",
                        "asDetectLowPriority": "Detect",
                        "asLRTLow": "Log Redundancy"
                    }
                }
            },
            "Appflow": {
                "Settings": {
                    "appflowToCollector": "Send to Collector",
                    "appflowToLocal": "Log to Local",
                    "appflowMonitor": "Real-time Data Collection"
                },
                "Flow Reporting": {
                    "_array": "appflowServerAddress",
                    "appflowServerAddress": "Collector IP",
                    "appflowServerPort": "Collector Port"
                }
            },
            "Log": {
                "Settings": {
                    "logNameResolution": "Name Resolution Method"
                }
            },
            "Address Objects": {
                "_array": "addrObjId",
                "addrObjId": "ID",
                "addrObjIdDisp": "Name",
                "addrObjType": "Type",
                "addrObjIp1": "IP/Start",
                "addrObjIp2": "Mask/End",
                "addrObjZone": "Zone",
                "addrObjProperties": "Properties",
                "Members": "Group Members",
                "addrObjCustom": "Custom/Default"
            },
            "Service Objects": {
                "_array": "svcObjId",
                "svcObjId": "Name",
                "svcObjIpType": "Protocol",
                "svcObjType": "Protocol",
                "svcObjPort1": "Port Start",
                "svcObjPort2": "Port End",
                "svcObjProperties": "Properties",
                "svcObjGuiClass": "Custom/Default",
                "Members": "Group Members"
            },
            "Service Group Mappings": {
                "_array": "so_atomToGrp",
                "so_atomToGrp": "Member",
                "so_grpToGrp": "Group"
            }
        };

        const COLUMN_ORDER = {
            "Interfaces": ["Name", "Zone", "IP Address", "Subnet Mask", "Gateway", "Comment", "HTTP Mgmt", "HTTPS Mgmt", "Ping Mgmt", "SNMP Mgmt", "SSH Mgmt", "Enabled"],
            "Zones": ["Name", "Zone Type", "Member Interfaces", "Interface Trust", "GAV Enabled", "AS Enabled", "IPS Enabled", "App Control Enabled", "DPI SSL Server Enabled", "DPI Client Enabled", "CFS Enabled"],
            "Access Rules": ["Name", "Action", "Source Zone", "Dest Zone", "Source Address", "Destination Address", "Service", "Geo-IP Filter", "Comment"],
            "NAT Rules": ["Name", "Enabled", "Inbound If", "Outbound If", "Orig Source", "Orig Dest", "Orig Service", "Trans Source", "Trans Dest", "Trans Service", "Comment"],
            "Address Objects": ["Name", "IP/Start", "Mask/End", "Type", "Zone", "Custom/Default"],
            "Service Objects": ["Name", "Protocol", "Port Start", "Port End", "Custom/Default"],
            "SNMP Views": ["View Name", "OID", "Default OID"],
            "DNS": ["DNS Server 1", "DNS Server 2", "DNS Rebinding Attack Prevention", "Split DNS Enabled"],
            "DHCP Dynamic Scopes": ["Enabled", "Range Start", "Range End", "Gateway", "DNS 1", "Lease (min)", "Comment"],
            "DHCP Static Scopes": ["Enabled", "Name", "IP Address", "Subnet Mask", "Gateway", "DNS 1"],
            "IP Helper": ["Application", "Port 1", "Port 2", "Timeout", "Enabled"],
            "VPN Policies": ["Name", "Gateway", "Shared Secret", "Enabled"],
            "Local Users": ["Username", "Type"],
            "Local Groups": ["Group Name"],
            "Appflow Reporting": ["Collector IP", "Collector Port"],
            "WAN Load Balancing": ["Enable", "Responder Enabled", "Any TCP SYN", "Primary Interface", "Secondary Interface", "Probe Target"]
        };

        const ZONE_TYPE_MAP = {
            "1": "Trusted", "0": "Untrusted", "2": "Public", "5": "Encrypted", "8": "SSL VPN", "4": "Wireless", "6": "Untrusted"
        };
        // ... (skip lines 363-1017, using separate chunks or assuming I must replace contiguous block?
        // I will just replace COLUMN_ORDER and renderServiceObjectsTabs separately.
        // This replacement only covers COLUMN_ORDER. I'll use multi check below.)
        const ACTION_MAP = {
            "2": "ALLOW", "0": "DENY", "1": "DISCARD"
        };
        const ADDRESS_OBJ_TYPE_MAP = {
            "1": "Host", "2": "Range", "4": "Network", "8": "Group", "9": "MAC", "10": "FQDN", "0": "Host"
        };
        const SERVICE_PROTOCOL_MAP = {
            "1": "TCP",
            "0": "UDP",
            "6": "TCP",
            "17": "UDP",
            "2": "Group"
        };
        const ROUTING_TYPE_MAP = {
            "1": "Custom", "0": "Default"
        };

        const ANY_INTERFACE_ID = "4294967295";
        const ANY_VALUE = "Any";

        /* =========================================
           2. GLOBAL STATE & DOM ELEMENTS
           ========================================= */

        let PARSED_DATA = {};
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');

        if (fileInput) {
            fileInput.addEventListener('change', handleFileSelect);
        }

        /* =========================================
           3. EVENT HANDLERS
           ========================================= */

        function togglePasteModal() {
            const modal = document.getElementById('pasteModal');
            modal.classList.toggle('hidden');
            if (!modal.classList.contains('hidden')) {
                const area = document.getElementById('pasteArea');
                area.value = '';
                area.focus();
            }
        }

        function processPaste() {
            const text = document.getElementById('pasteArea').value;
            if (text && text.trim().length > 0) {
                updateFileNameDisplay("Pasted Configuration");
                parseConfig(text);
                togglePasteModal();
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                updateFileNameDisplay(file.name);
                const reader = new FileReader();
                reader.onload = function (e) {
                    const text = e.target.result;
                    parseConfig(text);
                };
                reader.readAsText(file);
            } else {
                clearInput();
            }
        }

        function updateFileNameDisplay(name) {
            fileNameDisplay.textContent = name;
            fileNameDisplay.classList.remove('italic', 'text-obsidian-textMuted');
            fileNameDisplay.classList.add('font-semibold', 'text-white');
        }

        function clearInput() {
            fileInput.value = '';
            fileNameDisplay.textContent = 'No file chosen';
            fileNameDisplay.classList.add('italic', 'text-obsidian-textMuted');
            fileNameDisplay.classList.remove('font-semibold', 'text-white');

            document.getElementById('resultsArea').classList.add('hidden');
            document.getElementById('emptyState').classList.add('hidden'); // Ensure empty state is hidden when clearing
            PARSED_DATA = {};
        }

        function copyToClipboard() {
            if (Object.keys(PARSED_DATA).length === 0) return;
            const json = JSON.stringify(PARSED_DATA, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                alert('Parsed JSON copied to clipboard!');
            });
        }

        function switchTab(tabId) {
            // Hide all contents
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            // Deactivate all nav items
            document.querySelectorAll('.nav-item').forEach(el => {
                el.classList.remove('bg-obsidian-accent/10', 'text-obsidian-accent', 'border-r-2', 'border-obsidian-accent');
                el.classList.add('text-obsidian-textMuted', 'hover:bg-obsidian-border/50', 'hover:text-obsidian-text');

                // Reset icons
                const icon = el.querySelector('i');
                if (icon) icon.className = icon.dataset.originalClass || icon.className;
            });

            // Show target content
            const targetContent = document.getElementById(tabId);
            if (targetContent) {
                targetContent.classList.add('active');

                // Update Header Title
                const titleEl = document.getElementById('currentSectionTitle');
                if (titleEl) titleEl.textContent = targetContent.dataset.title || "Section";

                // Scroll top
                document.getElementById('mainContent').scrollTop = 0;
            }

            // Activate target nav item
            const activeLink = document.querySelector(`.nav-item[data-target="${tabId}"]`);
            if (activeLink) {
                activeLink.classList.remove('text-obsidian-textMuted', 'hover:bg-obsidian-border/50', 'hover:text-obsidian-text');
                activeLink.classList.add('bg-obsidian-accent/10', 'text-obsidian-accent', 'border-r-2', 'border-obsidian-accent');
            }
        }

        // Search Filter for Sidebar
        const navSearch = document.getElementById('navSearch');
        if (navSearch) {
            navSearch.addEventListener('input', (e) => {
                const term = e.target.value.toLowerCase();
                document.querySelectorAll('.nav-item').forEach(el => {
                    const text = el.innerText.toLowerCase();
                    el.style.display = text.includes(term) ? 'flex' : 'none';
                });
            });
        }

        /* =========================================
           4. PARSING LOGIC
           ========================================= */

        function parseConfig(configText) {
            // 1. Build lookup maps
            const interfaceMap = buildInterfaceMap(configText);
            const addressObjectMap = buildAddressObjectMap(configText);
            const groupMemberMap = buildAddressGroupMemberMap(configText);

            // 2. Parse the text map
            PARSED_DATA = parseConfigText(configText, interfaceMap, addressObjectMap, groupMemberMap);

            // 3. Render
            renderView(PARSED_DATA);

            // 4. Update UI state
            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('emptyState').classList.add('hidden');
        }

        function parseConfigText(configText, interfaceMap, addressObjectMap, groupMemberMap) {
            const results = {};
            const lines = configText.split('\n');

            // Helper to collect Interfaces for Zone calculation
            let allInterfaces = [];

            for (const [sectionName, sectionMap] of Object.entries(CONFIG_MAP)) {

                const firstKey = Object.keys(sectionMap)[0];
                const isNested = (typeof sectionMap[firstKey] === 'object' && sectionMap[firstKey] !== null);

                if (isNested) {
                    results[sectionName] = {};
                    for (const [subSectionName, subMap] of Object.entries(sectionMap)) {
                        if (subMap._array) {
                            results[sectionName][subSectionName] = parseGenericArray(lines, subMap, interfaceMap, addressObjectMap);
                        } else {
                            results[sectionName][subSectionName] = parseGenericKV(lines, subMap);
                        }
                    }
                } else {
                    if (sectionMap._array) {
                        let parsedArray = parseGenericArray(lines, sectionMap, interfaceMap, addressObjectMap);

                        if (sectionName === "Interfaces") {
                            parsedArray.sort((a, b) => {
                                const nameA = a["Name"] || "";
                                const nameB = b["Name"] || "";
                                return nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
                            });

                            // Fix WAN IP or missing IP by looking up Address Object "Xn IP"
                            const addressObjects = results["Address Objects"] || [];
                            parsedArray.forEach(iface => {
                                // 1. Check for 0.0.0.0 or missing IP
                                const currentIP = iface["IP Address"];
                                if (!currentIP || currentIP === "0.0.0.0" || currentIP === "(DHCP)") {
                                    const ifaceName = iface["Name"];
                                    // Try to find Address Object "Xn IP"
                                    const targetName = `${ifaceName} IP`;

                                    const addrObj = addressObjects.find(obj =>
                                        obj["Display Name"] === targetName || obj["Name"] === targetName
                                    );

                                    if (addrObj && addrObj["IP/Start"] && addrObj["IP/Start"] !== "0.0.0.0") {
                                        iface["IP Address"] = addrObj["IP/Start"];
                                        // Optional: Update mask if available and missing
                                        if (addrObj["Mask/End"] && (!iface["Subnet Mask"] || iface["Subnet Mask"] === "0.0.0.0")) {
                                            iface["Subnet Mask"] = addrObj["Mask/End"];
                                        }
                                    } else {
                                        // If still not found and valid WAN/X1, mark as DHCP
                                        if ((iface["Zone"] === "WAN" || (ifaceName && ifaceName.startsWith("X1"))) && (currentIP === "0.0.0.0" || !currentIP)) {
                                            iface["IP Address"] = "(DHCP)";
                                        }
                                    }
                                }
                            });
                            allInterfaces = parsedArray;
                        }

                        if (sectionName === "Address Objects" && groupMemberMap) {
                            parsedArray.forEach(obj => {
                                if (obj["Name"] && groupMemberMap[obj["Name"]]) {
                                    obj["Group Members"] = groupMemberMap[obj["Name"]];
                                }
                            });
                        }
                        results[sectionName] = parsedArray;
                    } else {
                        results[sectionName] = parseGenericKV(lines, sectionMap);
                    }
                }
            }

            // Post-Process: Calculate Member Interfaces for Zones
            if (results["Zones"] && Array.isArray(results["Zones"])) {
                results["Zones"].forEach(zone => {
                    const zoneName = zone["Name"];
                    if (zoneName) {
                        const members = allInterfaces.filter(iface => iface["Zone"] === zoneName).map(iface => iface["Name"]);
                        if (members.length > 0) {
                            zone["Member Interfaces"] = members;
                        }
                    }
                });
            }

            // Post-Process: Service Groups Enrichment
            if (results["Service Group Mappings"] && results["Service Objects"]) {
                const serviceGroupMap = {};
                results["Service Group Mappings"].forEach(mapping => {
                    const group = mapping["Group"];
                    const member = mapping["Member"];
                    if (group && member) {
                        if (!serviceGroupMap[group]) serviceGroupMap[group] = [];
                        serviceGroupMap[group].push(member);
                    }
                });

                results["Service Objects"].forEach(obj => {
                    if (obj["Name"] && serviceGroupMap[obj["Name"]]) {
                        obj["Group Members"] = serviceGroupMap[obj["Name"]];
                    }
                });
            }

            return results;
        }

        function buildInterfaceMap(text) {
            const map = {};
            const lines = text.split('\n');
            const ifNumRegex = /^iface_ifnum_(\d+)=(\d+)/;
            const ifNameRegex = /^iface_name_(\d+)=(.*)/;
            const temp = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match = trimmed.match(ifNumRegex);
                if (match) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].id = match[2];
                    continue;
                }
                match = trimmed.match(ifNameRegex);
                if (match) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].name = decodeURIComponent(match[2]);
                }
            }

            Object.values(temp).forEach(obj => {
                if (obj.id && obj.name) {
                    map[obj.id] = obj.name;
                }
            });

            map["-1"] = "Any";
            map[ANY_INTERFACE_ID] = "Any";
            return map;
        }

        function buildAddressObjectMap(text) {
            const map = {};
            const lines = text.split('\n');
            const idRegex = /^addrObjId_(\d+)=(.*)/;
            const ip1Regex = /^addrObjIp1_(\d+)=(.*)/;
            const ip2Regex = /^addrObjIp2_(\d+)=(.*)/;
            const typeRegex = /^addrObjType_(\d+)=(.*)/;
            const fqdnIdRegex = /^addrObjFqdnId_(\d+)=(.*)/;
            const fqdnValRegex = /^addrObjFqdn_(\d+)=(.*)/;

            const temp = {};
            const tempFqdn = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match;
                if ((match = trimmed.match(idRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].name = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(ip1Regex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].ip1 = match[2];
                } else if ((match = trimmed.match(ip2Regex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].ip2 = match[2];
                } else if ((match = trimmed.match(typeRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].type = match[2];
                } else if ((match = trimmed.match(fqdnIdRegex))) {
                    const idx = match[1];
                    if (!tempFqdn[idx]) tempFqdn[idx] = {};
                    tempFqdn[idx].name = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(fqdnValRegex))) {
                    const idx = match[1];
                    if (!tempFqdn[idx]) tempFqdn[idx] = {};
                    tempFqdn[idx].fqdn = match[2];
                }
            }

            Object.values(temp).forEach(obj => {
                if (obj.name) {
                    let desc = "";
                    if (obj.type === "8") {
                        desc = "Group";
                    } else if (obj.ip1) {
                        desc = obj.ip1;
                        if (obj.type === "4" && obj.ip2 && obj.ip2 !== "0.0.0.0") {
                            desc = `${obj.ip1}/${obj.ip2}`;
                        } else if (obj.type === "2" && obj.ip2 && obj.ip2 !== "0.0.0.0") {
                            desc = `${obj.ip1}-${obj.ip2}`;
                        }
                    }
                    if (desc) map[obj.name] = desc;
                }
            });

            Object.values(tempFqdn).forEach(obj => {
                if (obj.name && obj.fqdn) {
                    map[obj.name] = obj.fqdn;
                }
            });

            return map;
        }

        function buildAddressGroupMemberMap(text) {
            const map = {};
            const lines = text.split('\n');
            const atomRegex = /^addro_atomToGrp_(\d+)=(.*)/;
            const grpRegex = /^addro_grpToGrp_(\d+)=(.*)/;
            const temp = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match;
                if ((match = trimmed.match(atomRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].atom = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(grpRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].grp = decodeURIComponent(match[2]);
                }
            }

            Object.values(temp).forEach(item => {
                if (item.atom && item.grp) {
                    if (!map[item.grp]) map[item.grp] = [];
                    map[item.grp].push(item.atom);
                }
            });

            return map;
        }

        function parseGenericKV(lines, map) {
            const result = {};
            // Pre-seed with all known keys
            Object.values(map).forEach(label => result[label] = "");

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                for (const [key, label] of Object.entries(map)) {
                    if (trimmed.startsWith(key + '=')) {
                        let value = trimmed.substring(key.length + 1);
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (key === 'dns_use_static_servers') {
                            if (value === '1' || value.toLowerCase() === 'on') value = 'True';
                            else if (value === '0' || value.toLowerCase() === 'off') value = 'False';
                        }

                        result[label] = value;
                        break;
                    }
                }
            }
            return result;
        }

        function parseGenericArray(lines, map, interfaceMap, addressObjectMap) {
            const tempMap = {};

            for (const line of lines) {
                const trimmed = line.trim();
                for (const [key, label] of Object.entries(map)) {
                    if (key === '_array') continue;

                    const regex = new RegExp(`^${key}_(\\d+)=(.*)`);
                    const match = trimmed.match(regex);

                    if (match) {
                        const index = match[1];
                        let value = match[2];
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (!tempMap[index]) tempMap[index] = {};

                        if (key === 'zoneObjZoneType') value = ZONE_TYPE_MAP[value] || value;
                        if (key === 'addrObjType') value = ADDRESS_OBJ_TYPE_MAP[value] || value;
                        if (key === 'policyAction') value = ACTION_MAP[value] || value;
                        if (key === 'svcObjType' || key === 'svcObjIpType') value = SERVICE_PROTOCOL_MAP[value] || value;
                        if (key === 'pbrObjType') value = ROUTING_TYPE_MAP[value] || "Default";

                        if (key === 'iface_port_disabled') {
                            // Invert: port_disabled=off means Enabled=true
                            // AND must have a Zone assigned (otherwise it's Unassigned/Disabled)
                            const isPortDisabled = value === "1" || value.toLowerCase() === "on" || value.toLowerCase() === "true";
                            const zone = tempMap[index]["Zone"];
                            const hasZone = zone && zone.trim() !== "";

                            value = (!isPortDisabled && hasZone) ? "Enabled" : "Disabled";
                        }

                        if (key === 'policySrcIf' || key === 'policyDstIf' ||
                            key === 'natPolicySrcIface' || key === 'natPolicyDstIface' ||
                            key === 'pbrObjIface') {
                            value = interfaceMap[value] || value;
                        }

                        if ((key === 'policySrcNet' || key === 'policyDstNet' ||
                            key === 'policySrcSvc' || key === 'policyDstSvc' ||
                            key === 'natPolicyOrigSrc' || key === 'natPolicyOrigDst' ||
                            key === 'natPolicyOrigSvc' ||
                            key === 'pbrObjSrc' || key === 'pbrObjDst' ||
                            key === 'pbrObjSvc' || key === 'pbrObjGw' || key === 'pbrObjIface'
                        ) && value === "") {
                            value = ANY_VALUE;
                        }

                        if ((key === 'natPolicyTransSrc' || key === 'natPolicyTransDst' || key === 'natPolicyTransSvc') && value === "") {
                            value = "Original";
                        }

                        if ((key === 'policySrcNet' || key === 'policyDstNet' ||
                            key === 'natPolicyOrigSrc' || key === 'natPolicyOrigDst' ||
                            key === 'natPolicyTransSrc' || key === 'natPolicyTransDst' ||
                            key === 'pbrObjSrc' || key === 'pbrObjDst' || key === 'pbrObjGw'
                        ) && value !== ANY_VALUE) {
                            if (addressObjectMap && addressObjectMap[value]) {
                                value = `${value} <span class="text-obsidian-textMuted text-xs">(${addressObjectMap[value]})</span>`;
                            }
                        }

                        // Prevent overwriting valid IP with 0.0.0.0 or empty
                        const currentValue = tempMap[index][label];
                        const isZeroIP = (value === "0.0.0.0" || value === "");

                        if ((label === "IP Address" || label === "Gateway") && currentValue && currentValue !== "0.0.0.0" && currentValue !== "(DHCP)" && isZeroIP) {
                            // Skip overwriting a valid IP or Gateway with 0.0.0.0
                        } else {
                            tempMap[index][label] = value;
                        }
                        break;
                    }
                }
            }
            // Post-process for missing default values (specifically for Routing Class)
            Object.values(tempMap).forEach(obj => {
                if (obj.hasOwnProperty("Gateway") && obj.hasOwnProperty("Metric")) {
                    // User feedback indicates "Auto-named" policies without type are considered "Custom"
                    // and "Default" policies (standard routing table) are not in this file.
                    // So default to "Custom" if missing.
                    if (!obj["Class"]) obj["Class"] = "Custom";
                }

                // Address Object Logic: Fallback Name & Custom/Default Detection
                if (obj.hasOwnProperty("ID") && obj.hasOwnProperty("Type") && obj.hasOwnProperty("Zone")) {
                    // Fallback Name
                    if (!obj["Name"] || obj["Name"] === "") {
                        obj["Name"] = obj["ID"];
                    }

                    // Custom/Default Logic based on Properties (793 = Default/System Objects, 29 = Default/System Groups)
                    // If properties are missing, fallback to heuristic or default to Custom.
                    if (obj.hasOwnProperty("Properties")) {
                        obj["Custom/Default"] = (obj["Properties"] === "793" || obj["Properties"] === "29") ? "Default" : "Custom";
                    } else {
                        // Heuristic Fallback (legacy/safety)
                        const name = obj["Name"] || "";
                        const id = obj["ID"] || "";
                        const isDefault = /^(X\d+\s+(IP|Subnet)|All\s+|WAN\s+|LAN\s+|DMZ\s+)/i.test(name) ||
                            /^(X\d+\s+(IP|Subnet)|All\s+|WAN\s+|LAN\s+|DMZ\s+)/i.test(id);
                        obj["Custom/Default"] = isDefault ? "Default" : "Custom";
                    }
                }

                // Service Object Logic: Custom/Default
                if (obj.hasOwnProperty("Properties") && obj.hasOwnProperty("Protocol")) {
                    // 14 = Custom, others (e.g. 11293) = Default
                    if (obj["Properties"] === "14") {
                        obj["Custom/Default"] = "Custom";
                    } else {
                        obj["Custom/Default"] = "Default";
                    }
                }
            });

            return Object.values(tempMap);
        }

        /* =========================================
           5. RENDERING LOGIC
           ========================================= */

        function renderView(data) {
            const sidebarNav = document.getElementById('sidebarNav');
            const tabsContent = document.getElementById('tabsContent');

            sidebarNav.innerHTML = '';
            tabsContent.innerHTML = '';

            // Define icons for known sections
            const sectionIcons = {
                "Zones": "fa-vector-square",
                "Interfaces": "fa-network-wired",
                "Access Rules": "fa-shield-alt",
                "NAT Rules": "fa-exchange-alt",
                "Routing Policies": "fa-route",
                "Address Objects": "fa-map-marker-alt",
                "Service Objects": "fa-cube",
                "Service Group Mappings": "fa-layer-group",
                "Security Services": "fa-user-shield",
                "DNS": "fa-server",
                "DHCP": "fa-sitemap",
                "Summary": "fa-info-circle"
            };

            let firstTabId = null;

            // Sort sections: Critical ones first
            const sectionOrder = ["System", "Summary", "Interfaces", "Zones", "Address Objects", "Service Objects", "Access Rules", "NAT Rules", "Routing Policies", "DHCP", "DNS"];
            const sortedKeys = Object.keys(data).sort((a, b) => {
                const idxA = sectionOrder.indexOf(a);
                const idxB = sectionOrder.indexOf(b);
                if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                if (idxA !== -1) return -1;
                if (idxB !== -1) return 1;
                return a.localeCompare(b);
            });

            for (const sectionName of sortedKeys) {
                const sectionData = data[sectionName];
                if (sectionName === 'CLI' || sectionName === 'Service Group Mappings') continue;

                const tabId = sectionName.replace(/\s+/g, '-').toLowerCase();
                if (!firstTabId) firstTabId = tabId;

                // Create Sidebar Item
                const btn = document.createElement('button');
                btn.className = `nav-item w-full flex items-center px-3 py-2 text-sm font-medium rounded-md transition-all duration-200 group text-obsidian-textMuted hover:bg-obsidian-border/50 hover:text-obsidian-text mb-1`;
                btn.dataset.target = tabId;
                btn.onclick = () => switchTab(tabId);

                const iconClass = sectionIcons[sectionName] || "fa-circle";

                // Count items if array
                let countBadge = '';
                if (Array.isArray(sectionData)) {
                    countBadge = `<span class="ml-auto bg-obsidian-border text-obsidian-textMuted text-xs py-0.5 px-2 rounded-full group-hover:bg-obsidian-bg group-hover:text-white transition-colors">${sectionData.length}</span>`;
                }

                btn.innerHTML = `
                    <i class="fa-solid ${iconClass} w-5 text-center mr-3 text-obsidian-textMuted group-hover:text-obsidian-accent transition-colors" data-original-class="fa-solid ${iconClass}"></i>
                    <span class="truncate">${sectionName}</span>
                    ${countBadge}
                `;
                sidebarNav.appendChild(btn);

                // Create Content Pane
                const contentDiv = document.createElement('div');
                contentDiv.id = tabId;
                contentDiv.dataset.title = sectionName;
                contentDiv.className = `tab-content hidden space-y-6 animate-fade-in`; // Add animation class if available, or straight standard

                const isNested = !Array.isArray(sectionData) && Object.values(sectionData).some(v => typeof v === 'object');

                if (isNested) {
                    renderNestedSection(contentDiv, sectionData);
                } else if (sectionName === "Address Objects" && Array.isArray(sectionData)) {
                    renderAddressObjectsTabs(contentDiv, sectionData);
                } else if (sectionName === "Service Objects" && Array.isArray(sectionData)) {
                    renderServiceObjectsTabs(contentDiv, sectionData);
                } else if (Array.isArray(sectionData)) {
                    renderArrayTableSorted(contentDiv, sectionData, sectionName);
                } else {
                    renderKVTable(contentDiv, sectionData);
                }

                tabsContent.appendChild(contentDiv);
            }

            // Select first tab
            if (firstTabId) {
                switchTab(firstTabId);
            }
        }

        // Removed duplicate renderNestedSection


        function renderAddressObjectsTabs(container, data) {
            const groups = [], custom = [], checkDefault = [], all = [];

            data.forEach(item => {
                const type = item["Type"];
                // Check if it's a group: explicit Type "Group", numerical "8", or has Group Members populated
                const isGroup = type === "Group" || type === "8" || (item["Group Members"] && item["Group Members"].length > 0);

                if (isGroup) {
                    groups.push(item);
                } else {
                    // Normalize Mask/End for display consistency
                    if (!item["Mask/End"] || item["Mask/End"] === "0.0.0.0") {
                        // For hosts (Type 1), mask is usually implied 32 or 255.255.255.255, 
                        // but 0.0.0.0 in dump usually means single IP if it's a Host.
                        // Let's leave it blank or strict checked if needed.
                        // Actually existing logic set it to 255.255.255.255 if missing.
                        if (type === "Host" || type === "1") {
                            item["Mask/End"] = "255.255.255.255";
                        }
                    }
                    all.push(item);

                    if (item["Custom/Default"] === "Custom") {
                        custom.push(item);
                    } else {
                        checkDefault.push(item);
                    }
                }
            });

            // Sub-Tabs Header
            const subNav = document.createElement('div');
            subNav.className = "flex space-x-2 mb-4 border-b border-obsidian-border";
            const subContent = document.createElement('div');

            // Categories matching Service Objects style
            const categories = [
                { name: "Address Objects", data: all, section: "Address Objects" },
                { name: "Address Groups", data: groups, section: "Address Groups" }, // Use specific col order for groups
                { name: "Custom", data: custom, section: "Address Objects" }, // Fallback to generic cols? Or maybe we need dynamic cols?
                { name: "Default", data: checkDefault, section: "Address Objects" }
            ];

            categories.forEach((cat, idx) => {
                const btn = document.createElement('button');
                btn.className = `px-3 py-2 text-sm font-medium transition-colors border-b-2 ${idx === 0 ? 'border-obsidian-accent text-obsidian-accent' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text'}`;
                btn.innerText = `${cat.name} (${cat.data.length})`;

                btn.onclick = (e) => {
                    subNav.querySelectorAll('button').forEach(b => {
                        b.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-transparent text-obsidian-textMuted hover:text-obsidian-text";
                    });
                    e.target.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-obsidian-accent text-obsidian-accent";

                    subContent.innerHTML = '';
                    // For "Groups" tab, verify if we should use "Address Groups" column order (less cols) or standard.
                    // For "Custom" and "Default", items are mixed. 
                    // renderArrayTableSorted uses the passed sectionName to look up COLUMN_ORDER.
                    // If we pass "Address Objects", it uses that order. 
                    // If "Address Groups", it uses that order.

                    // Ideally, Custom/Default views might need a union of columns or just standard "Address Objects" columns.
                    // "Address Groups" col order excludes IP/Start, Mask/End usually.

                    renderArrayTableSorted(subContent, cat.data, cat.section);
                };
                subNav.appendChild(btn);
            });

            container.appendChild(subNav);
            container.appendChild(subContent);

            // Default render first tab
            renderArrayTableSorted(subContent, all, "Address Objects");
        }

        function renderServiceObjectsTabs(container, data) {
            const groups = [], custom = [], checkDefault = [], all = [];

            data.forEach(item => {
                // Determine if item is a group: Protocol is Group OR it has populated members
                const isGroup = (item["Protocol"] === "Group") || (item["Group Members"] && item["Group Members"].length > 0);

                if (isGroup) {
                    groups.push(item);
                } else {
                    // Only add non-groups to the main list (or should main list show all? Usually Objects only)
                    // Let's keep "Services" as "All Individual Objects"
                    all.push(item);

                    if (item["Custom/Default"] === "Custom") {
                        custom.push(item);
                    } else {
                        checkDefault.push(item);
                    }
                }
            });

            // Sub-Tabs Header
            const subNav = document.createElement('div');
            subNav.className = "flex space-x-2 mb-4 border-b border-obsidian-border";
            const subContent = document.createElement('div');

            const categories = [
                { name: "Services", data: all, section: "Service Objects" },
                { name: "Groups", data: groups, section: "Service Groups" },
                { name: "Custom", data: custom, section: "Service Objects" },
                { name: "Default", data: checkDefault, section: "Service Objects" }
            ];

            categories.forEach((cat, idx) => {
                const btn = document.createElement('button');
                btn.className = `px-3 py-2 text-sm font-medium transition-colors border-b-2 ${idx === 0 ? 'border-obsidian-accent text-obsidian-accent' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text'}`;
                btn.innerText = `${cat.name} (${cat.data.length})`;

                btn.onclick = (e) => {
                    subNav.querySelectorAll('button').forEach(b => {
                        b.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-transparent text-obsidian-textMuted hover:text-obsidian-text";
                    });
                    e.target.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-obsidian-accent text-obsidian-accent";

                    subContent.innerHTML = '';
                    renderArrayTableSorted(subContent, cat.data, cat.section);
                };
                subNav.appendChild(btn);
            });

            container.appendChild(subNav);
            container.appendChild(subContent);

            // Default view: Services (Individual Objects)
            renderArrayTableSorted(subContent, all, "Service Objects");
        }


        function parseGenericKV(lines, map) {
            // Build a flat lookup of file_key -> { path: [keys...], label: "Label" }
            const keyLookup = {};
            const resultStructure = {};

            function traverseMap(currentMap, pathStack, resultRef) {
                for (const [key, val] of Object.entries(currentMap)) {
                    if (typeof val === 'object' && val !== null) {
                        // Nested section (grouping)
                        resultRef[key] = {};
                        traverseMap(val, [...pathStack, key], resultRef[key]);
                    } else {
                        // Leaf node
                        keyLookup[key] = { path: [...pathStack, val], label: val };
                        resultRef[val] = ""; // Pre-seed
                    }
                }
            }

            traverseMap(map, [], resultStructure);

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                // Optimization: Iterate through known keys or regex? 
                // Since this is generic KV, we checking if line starts with any key in map.
                // We can iterate the lookup.
                for (const [key, info] of Object.entries(keyLookup)) {
                    if (trimmed.startsWith(key + '=')) {
                        let value = trimmed.substring(key.length + 1);
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (key === 'dns_use_static_servers') {
                            if (value === '1' || value.toLowerCase() === 'on') value = 'True';
                            else if (value === '0' || value.toLowerCase() === 'off') value = 'False';
                        }

                        // Set value at path
                        let current = resultStructure;
                        for (let i = 0; i < info.path.length - 1; i++) {
                            current = current[info.path[i]];
                        }
                        current[info.label] = value;
                        break;
                    }
                }
            }
            return resultStructure;
        }

        // ... (parseGenericArray kept as is) ...

        function renderNestedSection(container, data) {
            for (const [subTitle, subData] of Object.entries(data)) {
                const h3 = document.createElement('h3');
                h3.className = "text-lg font-medium leading-6 text-white mb-2 pb-1 border-b border-obsidian-border mt-6 first:mt-0";
                h3.innerText = subTitle;
                container.appendChild(h3);

                const subContainer = document.createElement('div');
                subContainer.className = "mb-8";

                if (Array.isArray(subData)) {
                    // Pure Array
                    renderArrayTableSorted(subContainer, subData, subTitle);
                } else if (typeof subData === 'object' && subData !== null) {
                    // Check for Mixed Content (Scalars + Arrays)
                    const scalars = {};
                    const arrays = {};
                    let hasArrays = false;

                    for (const [k, v] of Object.entries(subData)) {
                        if (Array.isArray(v)) {
                            arrays[k] = v;
                            hasArrays = true;
                        } else {
                            scalars[k] = v;
                        }
                    }

                    // Render Scalars first
                    if (Object.keys(scalars).length > 0) {
                        const scalarContainer = document.createElement('div');
                        scalarContainer.className = "mb-4";
                        renderKVTable(scalarContainer, scalars);
                        subContainer.appendChild(scalarContainer);
                    }

                    // Render Arrays
                    if (hasArrays) {
                        for (const [arrName, arrData] of Object.entries(arrays)) {
                            // Use key as section name for column lookup if needed
                            const arrContainer = document.createElement('div');
                            arrContainer.className = "mt-4";
                            renderArrayTableSorted(arrContainer, arrData, arrName);
                            subContainer.appendChild(arrContainer);
                        }
                    }
                }
                container.appendChild(subContainer);
            }
        }

        function renderKVTable(container, data, isRecursive = false) {
            if (Object.keys(data).length === 0) {
                if (!isRecursive) container.innerHTML += '<p class="text-obsidian-textMuted text-sm italic">No data found.</p>';
                return;
            }

            const table = document.createElement('table');
            table.className = "min-w-full divide-y divide-obsidian-border";
            const tbody = document.createElement('tbody');
            tbody.className = "divide-y divide-obsidian-border";

            let hasRows = false;

            for (const [key, value] of Object.entries(data)) {
                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    // Recursive Nesting (e.g. Settings -> { ... })
                    // Render a row with a mini-header or nested table?
                    // Better: nested table in a cell, or just rows with indentation?
                    // Let's use a sub-header row.

                    const trHeader = document.createElement('tr');
                    trHeader.className = "bg-obsidian-pane/30";
                    trHeader.innerHTML = `
                        <td colspan="2" class="px-6 py-2 text-xs font-bold text-obsidian-accent uppercase tracking-wider border-l-4 border-obsidian-accent">${key}</td>
                    `;
                    tbody.appendChild(trHeader);

                    // Render children flattened or recursively?
                    // Let's recurse but extract rows. 
                    // Actually, if we use recursion, we need to append TRs to THIS tbody.
                    // We can't use renderKVTable easily unless we refactor to return TRs.
                    // Simpler: Just recursively iterate here.

                    const entries = Object.entries(value);
                    if (entries.length === 0) {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td colspan="2" class="px-6 py-2 text-sm text-obsidian-textMuted italic pl-8">No properties</td>`;
                        tbody.appendChild(tr);
                    } else {
                        // We can abuse renderKVTable nicely if we modify it to accept a tbody?
                        // Or just loop.
                        // Let's loop to keep the parent context's table structure (aligned columns).
                        for (const [subKey, subVal] of entries) {
                            const tr = document.createElement('tr');
                            tr.innerHTML = `
                                <td class="px-6 py-3 whitespace-nowrap text-sm font-medium text-obsidian-text w-1/3 border-r border-obsidian-border bg-obsidian-pane/50 pl-10"><i class="fa-solid fa-angle-right text-xs text-obsidian-textMuted mr-2"></i>${subKey}</td>
                                <td class="px-6 py-3 text-sm text-obsidian-textMuted font-mono break-all">${renderValue(subVal, subKey)}</td>
                            `;
                            tbody.appendChild(tr);
                        }
                    }
                    hasRows = true;

                } else {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td class="px-6 py-3 whitespace-nowrap text-sm font-medium text-obsidian-text w-1/3 border-r border-obsidian-border bg-obsidian-pane/50">${key}</td>
                        <td class="px-6 py-3 text-sm text-obsidian-textMuted font-mono break-all">${renderValue(value, key)}</td>
                    `;
                    tbody.appendChild(tr);
                    hasRows = true;
                }
            }

            if (!hasRows && !isRecursive) {
                container.innerHTML += '<p class="text-obsidian-textMuted text-sm italic">No data found.</p>';
                return;
            }

            table.appendChild(tbody);

            const shadowWrapper = document.createElement('div');
            shadowWrapper.className = "shadow ring-1 ring-obsidian-border rounded-lg overflow-hidden bg-obsidian-bg overflow-x-auto";
            shadowWrapper.appendChild(table);
            container.appendChild(shadowWrapper);
        }
        function renderArrayTableSorted(container, data, sectionIdentifier = "") {
            if (!data || data.length === 0) {
                container.innerHTML = '<p class="text-obsidian-textMuted text-sm italic">No items found.</p>';
                return;
            }

            // Determine columns
            const customOrder = COLUMN_ORDER[sectionIdentifier];
            let colArray = [];
            if (customOrder) {
                colArray = [...customOrder];
            } else {
                const columns = new Set();
                data.forEach(item => Object.keys(item).forEach(k => columns.add(k)));
                colArray = Array.from(columns);
                const priorityCols = ["Name", "Action", "Zone Type", "IP Address", "Source Zone"];
                colArray.sort((a, b) => {
                    const idxA = priorityCols.indexOf(a);
                    const idxB = priorityCols.indexOf(b);
                    if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                    if (idxA !== -1) return -1;
                    if (idxB !== -1) return 1;
                    return a.localeCompare(b);
                });
                colArray = colArray.filter(col => data.some(row => row[col] && row[col] !== ""));
            }

            // State for sorting and filtering
            let currentData = [...data];
            let sortCol = null;
            let sortAsc = true;
            let filterTerm = "";

            // Filter UI
            const searchContainer = document.createElement('div');
            searchContainer.className = "mb-4 sticky left-0";
            const searchInput = document.createElement('input');
            searchInput.type = "text";
            searchInput.placeholder = `Filter ${sectionIdentifier}...`;
            searchInput.className = "w-full max-w-sm px-4 py-2 bg-obsidian-pane border border-obsidian-border rounded-md text-sm text-obsidian-text focus:outline-none focus:border-obsidian-accent focus:ring-1 focus:ring-obsidian-accent placeholder-obsidian-textMuted transition-colors";

            searchContainer.appendChild(searchInput);
            container.appendChild(searchContainer);

            // Container Wrapper
            const wrapper = document.createElement('div');
            wrapper.className = "shadow ring-1 ring-obsidian-border rounded-lg overflow-hidden bg-obsidian-bg flex flex-col max-h-[calc(100vh-12rem)]"; // Max height
            const scrollContainer = document.createElement('div');
            scrollContainer.className = "overflow-auto table-container flex-1";

            const table = document.createElement('table');
            table.className = "min-w-full divide-y divide-obsidian-border relative";
            const thead = document.createElement('thead');
            thead.className = "bg-obsidian-pane";
            const tbody = document.createElement('tbody');
            tbody.className = "divide-y divide-obsidian-border";

            table.appendChild(thead);
            table.appendChild(tbody);
            scrollContainer.appendChild(table);
            wrapper.appendChild(scrollContainer);
            container.appendChild(wrapper);

            // Render Function
            const render = () => {
                // 1. Filter
                let filtered = currentData;
                if (filterTerm) {
                    filtered = currentData.filter(item => {
                        return colArray.some(col => {
                            const val = item[col] || "";
                            return String(val).toLowerCase().includes(filterTerm);
                        });
                    });
                }

                // 2. Sort
                if (sortCol) {
                    filtered.sort((a, b) => {
                        let valA = a[sortCol] || "";
                        let valB = b[sortCol] || "";

                        // Numeric Sort Attempt
                        const numA = parseFloat(valA);
                        const numB = parseFloat(valB);
                        if (!isNaN(numA) && !isNaN(numB) &&
                            String(numA) === String(valA) && String(numB) === String(valB)) { // strict numeric check
                            return sortAsc ? numA - numB : numB - numA;
                        }

                        // IP Address Sort
                        if (sortCol.includes("IP") || sortCol.includes("Address")) {
                            const ipA = valA.split('.').map(Number);
                            const ipB = valB.split('.').map(Number);
                            if (ipA.length === 4 && ipB.length === 4) {
                                for (let i = 0; i < 4; i++) {
                                    if (ipA[i] !== ipB[i]) return sortAsc ? ipA[i] - ipB[i] : ipB[i] - ipA[i];
                                }
                                return 0;
                            }
                        }

                        // String Sort
                        return sortAsc
                            ? String(valA).localeCompare(String(valB))
                            : String(valB).localeCompare(String(valA));
                    });
                }

                // 3. Render Header
                let thHtml = '<tr>';
                colArray.forEach(col => {
                    let sortIcon = 'fa-sort text-obsidian-border';
                    if (col === sortCol) {
                        sortIcon = sortAsc ? 'fa-sort-up text-obsidian-accent' : 'fa-sort-down text-obsidian-accent';
                    }
                    thHtml += `
                        <th scope="col" data-col="${col}" class="cursor-pointer group hover:bg-obsidian-pane/80 sticky top-0 z-10 bg-obsidian-pane px-4 py-3 text-left text-xs font-semibold text-white uppercase tracking-wider whitespace-nowrap border-b border-obsidian-border shadow-sm select-none">
                            <div class="flex items-center gap-2">
                                ${col}
                                <i class="fa-solid ${sortIcon} text-[10px] transition-colors"></i>
                            </div>
                        </th>`;
                });
                thHtml += '</tr>';
                thead.innerHTML = thHtml;

                // Bind Header Click
                thead.querySelectorAll('th').forEach(th => {
                    th.addEventListener('click', () => {
                        const col = th.dataset.col;
                        if (sortCol === col) {
                            sortAsc = !sortAsc;
                        } else {
                            sortCol = col;
                            sortAsc = true;
                        }
                        render();
                    });
                });

                // 4. Render Body
                tbody.innerHTML = '';
                if (filtered.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="' + colArray.length + '" class="px-6 py-4 text-center text-sm text-obsidian-textMuted italic">No matches found.</td></tr>';
                    return;
                }

                filtered.forEach((item, idx) => {
                    const tr = document.createElement('tr');
                    tr.className = idx % 2 === 0 ? 'bg-transparent' : 'bg-[#2a2a2c]';
                    tr.className += ' hover:bg-[#323234] transition-colors';

                    let tdHtml = '';
                    colArray.forEach(col => {
                        let val = item[col] || "";
                        let content = renderValue(val, col);
                        if (col === "Name" && val.includes && val.includes(":")) {
                            content = `<span class="ml-4 border-l-2 border-obsidian-border pl-2 text-obsidian-textMuted">${content}</span>`;
                        }
                        tdHtml += `<td class="px-4 py-3 text-sm text-obsidian-text whitespace-nowrap">${content}</td>`;
                    });
                    tr.innerHTML = tdHtml;
                    tbody.appendChild(tr);
                });
            };

            // Initial Render
            render();

            // Filter Event
            searchInput.addEventListener('input', (e) => {
                filterTerm = e.target.value.toLowerCase();
                render();
            });
        }


        const TIMEZONE_MAP = {
            "827": "Central Time (US & Canada)",
        };

        const LOG_RES_MAP = {
            "0": "None",
            "1": "DNS",
            "2": "NetBIOS",
            "3": "DNS then NetBIOS"
        };

        const DNS_REBIND_ACTION_MAP = {
            "0": "Log Attack",
            "1": "Log Attack & Return Query Refused",
            "2": "Log Attack & Drop DNS Reply"
        };

        const BLOCK_MODE_MAP = {
            "0": "All Connections",
            "1": "Firewall Rule-Based",
            "2": "High Assurance"
        };

        function renderValue(val, key = "") {
            if (Array.isArray(val)) {
                return val.map(v => `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-obsidian-pane border border-obsidian-border text-obsidian-text mr-1 mb-1">${v}</span>`).join('');
            }

            // Map Lookups
            const keyLower = key.toLowerCase();
            if (key === "Time Zone (ID)") {
                if (TIMEZONE_MAP[val]) return `${TIMEZONE_MAP[val]} (${val})`;
                return val;
            }
            if (key === "Name Resolution Method" && LOG_RES_MAP[val]) return LOG_RES_MAP[val];
            if (key === "DNS Rebinding Action" && DNS_REBIND_ACTION_MAP[val]) return DNS_REBIND_ACTION_MAP[val];
            if ((key === "Block Mode" || key === "Block Connections (All/Rule)") && BLOCK_MODE_MAP[val]) return BLOCK_MODE_MAP[val];

            // Boolean Flags - Enhanced Logic
            const isTrue = val === "1" || String(val).toLowerCase() === "on" || val === "True";
            const isFalse = val === "0" || String(val).toLowerCase() === "off" || val === "False";

            // Heuristics for when to apply Boolean logic
            const boolKeyKeywords = ["enable", "active", "block", "check", "allow", "log", "stealth", "random", "bit", "auth", "persisten", "detect", "prevent", "responder", "syn", "mgmt"];
            const numberKeyKeywords = ["port", "count", "time", "level", "id", "value", "number", "metric", "interval", "timeout", "lease"];

            const isLikelyBool = boolKeyKeywords.some(k => keyLower.includes(k));
            const isLikelyNumber = numberKeyKeywords.some(k => keyLower.includes(k));

            if (isTrue && (!isLikelyNumber || isLikelyBool)) {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">Yes</span>';
            }
            if (isFalse && (!isLikelyNumber || isLikelyBool)) {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">No</span>';
            }
            if (val === "ALLOW") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">ALLOW</span>';
            }
            if (val === "DENY") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">DENY</span>';
            }
            if (val === "DISCARD" || val === "DROP") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-orange-900/30 text-orange-400 border border-orange-800">DISCARD</span>';
            }
            if (key === "Source Zone" && (val === "" || val === undefined)) {
                return '<span class="italic text-obsidian-textMuted">ALL</span>';
            }
            if (key === "Security Services Setting" && val === "1") {
                return "Enhanced";
            }
            if (key === "Default connections") {
                return "Max DPI Connections (DPI Services Enabled)";
            }
            if (val === "Any" || val === "Any (0)") {
                return '<span class="italic text-obsidian-textMuted">Any</span>';
            }
            return val;
        }
    </script>
</body>

</html>