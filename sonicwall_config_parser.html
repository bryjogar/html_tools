<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SonicWall Config Parser | Homelab Playground</title>
    <link rel="icon" type="image/png" href="favicon.png">

    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <!-- Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        obsidian: {
                            bg: '#1e1e1e',
                            pane: '#252526',
                            border: '#3c3c3c',
                            accent: '#7c3aed',
                            accentHover: '#6d28d9',
                            text: '#cccccc',
                            textMuted: '#9ca3af',
                            success: '#10b981',
                            warning: '#f59e0b',
                            danger: '#ef4444'
                        }
                    },
                    fontFamily: {
                        mono: ['"Fira Code"', 'monospace'],
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3c3c3c;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-btn.active {
            border-bottom-color: #7c3aed;
            color: #7c3aed;
        }
    </style>
</head>

<body class="flex flex-col h-screen overflow-hidden bg-obsidian-bg text-obsidian-text font-sans">

    <!-- Header -->
    <header
        class="h-14 bg-obsidian-pane border-b border-obsidian-border flex items-center justify-between px-6 shrink-0 z-20">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-shield-halved text-obsidian-accent text-lg"></i>
            <h1 class="font-semibold text-white tracking-tight">SonicWall Config Parser</h1>
        </div>
        <div class="flex items-center gap-4">
            <!-- File Input hidden -->
            <input type="file" id="fileInput" accept=".txt,.exp" class="hidden">

            <button onclick="document.getElementById('fileInput').click()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors">
                <i class="fa-solid fa-upload mr-2 text-obsidian-accent"></i>
                Upload
            </button>

            <button onclick="togglePasteModal()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors">
                <i class="fa-solid fa-paste mr-2 text-obsidian-accent"></i>
                Paste Text
            </button>

            <span id="fileName" class="text-sm text-obsidian-textMuted italic max-w-[200px] truncate ml-2">No file
                chosen</span>

            <button onclick="copyToClipboard()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors ml-4">
                <i class="fa-regular fa-copy mr-2 text-obsidian-accent"></i>
                Copy JSON
            </button>
        </div>
    </header>

    <!-- Paste Modal -->
    <div id="pasteModal"
        class="fixed inset-0 bg-black/80 hidden z-50 flex items-center justify-center backdrop-blur-sm">
        <div
            class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl w-full max-w-4xl flex flex-col h-[80vh]">
            <div class="flex items-center justify-between px-6 py-4 border-b border-obsidian-border bg-obsidian-pane">
                <h3 class="text-lg font-semibold text-white"><i
                        class="fa-solid fa-clipboard mr-2 text-obsidian-accent"></i>Paste Configuration</h3>
                <button onclick="togglePasteModal()" class="text-obsidian-textMuted hover:text-white transition-colors">
                    <i class="fa-solid fa-xmark text-xl"></i>
                </button>
            </div>
            <div class="p-0 flex-1 flex flex-col min-h-0">
                <textarea id="pasteArea"
                    class="w-full h-full bg-obsidian-bg border-none p-4 font-mono text-xs text-obsidian-text focus:ring-0 outline-none resize-none"
                    placeholder="Paste SonicWall configuration text here..."></textarea>
            </div>
            <div class="px-6 py-4 border-t border-obsidian-border bg-obsidian-pane flex justify-end space-x-3">
                <button onclick="togglePasteModal()"
                    class="px-4 py-2 text-obsidian-textMuted hover:text-white transition-colors text-sm font-medium">Cancel</button>
                <button onclick="processPaste()"
                    class="bg-obsidian-accent hover:bg-obsidian-accentHover text-white px-6 py-2 rounded-md font-medium transition-colors shadow-lg shadow-obsidian-accent/20">
                    <i class="fa-solid fa-bolt mr-2"></i>Parse Text
                </button>
            </div>
        </div>
    </div>


    <!-- Main Content -->
    <main class="flex-1 overflow-auto p-4 md:p-8 flex flex-col gap-6 max-w-7xl mx-auto w-full">

        <!-- Results Section -->
        <div id="resultsArea"
            class="hidden bg-obsidian-pane shadow-lg border border-obsidian-border rounded-xl overflow-hidden min-h-[600px] flex flex-col">
            <!-- Tabs Header -->
            <div class="border-b border-obsidian-border overflow-x-auto bg-obsidian-pane shrink-0">
                <nav class="flex px-4" aria-label="Tabs" id="tabsHeader">
                    <!-- Tabs injected by JS -->
                </nav>
            </div>

            <!-- Tab Contents -->
            <div id="tabsContent" class="p-6 flex-1 overflow-auto">
                <!-- Tab panes injected by JS -->
            </div>
        </div>

        <!-- Empty State -->
        <div id="emptyState" class="text-center py-20 flex flex-col items-center justify-center opacity-60">
            <i class="fa-solid fa-file-code text-6xl text-obsidian-border mb-4"></i>
            <h3 class="mt-2 text-lg font-medium text-white">No configuration parsed</h3>
            <p class="mt-1 text-sm text-obsidian-textMuted">Upload a SonicWall configuration file (.txt or .exp) to view
                the parsed details.</p>
        </div>

    </main>

    <!-- Footer -->
    <footer class="bg-obsidian-pane border-t border-obsidian-border py-3 text-center shrink-0">
        <a href="index.html"
            class="text-obsidian-textMuted hover:text-obsidian-accent text-xs transition-colors no-underline">
            HomeLab Playground
        </a>
    </footer>

    <script>
        /* =========================================
           1. CONSTANTS & CONFIGURATION
           ========================================= */

        // CONFIG_MAP defines the structure and mapping of the SonicWall config
        const CONFIG_MAP = {
            "Zones": {
                "_array": "zoneObjId",
                "zoneObjId": "Name",
                "zoneObjZoneType": "Zone Type",
                "zoneObjIntraZoneCom": "Interface Trust",
                "zoneObjAvProfile": "Gateway AV Profile",
                "zoneObjACProfile": "App Control Profile",
                "zoneObjASProfile": "Anti-Spyware Profile",
                "zoneObjGavProfile": "GAV Profile",
                "zoneObjDPISSLSProfile": "DPI-SSL Server",
                "zoneObjDPISSLCProfile": "DPI-SSL Client",
                "zoneObjEnableContentFiltering": "CFS Enabled",
                // Computed fields
                "computed_MemberInterfaces": "Member Interfaces"
            },
            "Interfaces": {
                "_array": "iface_ifnum",
                "iface_name": "Name",
                "interface_Zone": "Zone",
                "iface_comment": "Comment",
                "iface_lan_ip": "IP Address",
                "iface_wan_ip": "IP Address",
                "iface_static_ip": "IP Address",
                "iface_lan_mask": "Subnet Mask",
                "iface_static_mask": "Subnet Mask",
                "iface_static_gateway": "Gateway",
                "iface_lan_default_gw": "Gateway",
                "iface_wan_default_gw": "Gateway",
                "iface_https_mgmt": "HTTPS Mgmt",
                "iface_ping_mgmt": "Ping Mgmt",
                "iface_ssh_mgmt": "SSH Mgmt",
                "iface_snmp_mgmt": "SNMP Mgmt",
                "iface_enabled": "Enabled"
            },
            "Access Rules": {
                "_array": "policyAction",
                "policyName": "Name",
                "policyAction": "Action",
                "policySrcZone": "Source Zone",
                "policyDstZone": "Dest Zone",
                "policySrcNet": "Source Address",
                "policyDstNet": "Destination Address",
                "policyDstSvc": "Service",
                "policyComment": "Comment"
            },
            "NAT Rules": {
                "_array": "natPolicyOrigSrc",
                "natPolicyName": "Name",
                "natPolicyOrigSrc": "Original Source",
                "natPolicyOrigDst": "Original Dest",
                "natPolicyOrigSvc": "Original Service",
                "natPolicyTransSrc": "Translated Source",
                "natPolicyTransDst": "Translated Dest",
                "natPolicyTransSvc": "Translated Service",
                "natPolicySrcIface": "Ingress Interface",
                "natPolicyDstIface": "Egress Interface",
                "natPolicyComment": "Comment",
                "natPolicyEnabled": "Status",
                "natPolicyReflexive": "Reflexive",
                "natPolicyDnsDoctorEnable": "DNS Doctoring"
            },
            "Routing Policies": {
                "_array": "pbrObjId",
                "pbrPolicyName": "Name",
                "pbrObjSrc": "Source",
                "pbrObjDst": "Destination",
                "pbrObjSvc": "Service",
                "pbrObjIface": "Interface",
                "pbrObjGw": "Gateway",
                "pbrObjMetric": "Metric",
                "pbrObjType": "Class",
                "pbrObjPriority": "Priority",
                "pbrObjProbe": "Probe",
                "pbrObjDisableOnProbeFail": "Disable on Fail"
            },
            "Address Objects": {
                "_array": "addrObjId",
                "addrObjId": "ID",
                "addrObjIdDisp": "Name",
                "addrObjType": "Type",
                "addrObjIp1": "IP/Start",
                "addrObjIp2": "Mask/End",
                "addrObjZone": "Zone",
                "addrObjProperties": "Properties",
                // Computed/Enriched
                "Members": "Group Members",
                "addrObjCustom": "Custom/Default"
            },
            "Service Objects": {
                "_array": "svcObjId",
                "svcObjId": "Name",
                "svcObjIpType": "Protocol",
                "svcObjType": "Protocol",
                "svcObjPort1": "Port Start",
                "svcObjPort2": "Port End",
                "svcObjProperties": "Properties",
                "svcObjGuiClass": "Custom/Default",
                "Members": "Group Members"
            },
            "Service Group Mappings": {
                "_array": "so_atomToGrp",
                "so_atomToGrp": "Member",
                "so_grpToGrp": "Group"
            },
            "Security Services": {
                "GAV": {
                    "gavEnableScanning": "Enable GAV Scanning",
                    "gavEnableInbound": "Enable Inbound",
                    "gavEnableOutbound": "Enable Outbound"
                },
                "IPS": {
                    "isIDPEnabled": "Enable IPS",
                    "idpPreventHighPriority": "Prevent High Pri",
                    "idpDetectHighPriority": "Detect High Pri",
                    "idpPreventMediumPriority": "Prevent Med Pri",
                    "idpDetectMediumPriority": "Detect Med Pri"
                },
                "Geo-IP": {
                    "geoIpBlkMode": "Block Mode",
                    "geoIpLoggingEnabled": "Logging Enabled",
                    "geoEnforcement": "Enable Enforcement",
                    "blockUnknownGeo": "Block Unknown"
                },
                "Botnet": {
                    "botnetBlock": "Block Botnet",
                    "botnetLoggingEnabled": "Logging Enabled"
                },
                "AS": {
                    "asEnableScanning": "Enable Anti-Spyware",
                    "asEnableInbound": "Enable Inbound",
                    "asEnableOutbound": "Enable Outbound"
                }
            },
            "DNS": {
                "dns_server_one": "DNS Server 1",
                "dns_server_two": "DNS Server 2",
                "dns_server_three": "DNS Server 3",
                "dns_use_static_servers": "Use Static DNS"
            },
            "DHCP": {
                "Settings": {
                    "enableDHCP": "Enable DHCP Server"
                },
                "Static Scopes": {
                    "_array": "prefs_dhstaticip",
                    "prefs_dhstaticscopeactive": "Enabled",
                    "prefs_dhstaticname": "Name",
                    "prefs_dhstaticip": "IP Address",
                    "prefs_dhstatichw": "MAC Address",
                    "prefs_dhstaticsubnetmask": "Subnet Mask",
                    "prefs_dhstaticrouter": "Gateway",
                    "prefs_dhstaticdns0": "DNS 1"
                },
                "Dynamic Scopes": {
                    "_array": "prefs_dhdynstart",
                    "prefs_dhdynscopeactive": "Enabled",
                    "prefs_dhdynstart": "Range Start",
                    "prefs_dhdynend": "Range End",
                    "prefs_dhdynrouter": "Gateway",
                    "prefs_dhdynsubnetmask": "Subnet Mask",
                    "prefs_dhdynlease": "Lease (min)",
                    "prefs_dhdyndns0": "DNS 1",
                    "prefs_dhdyndns1": "DNS 2",
                    "prefs_dhdynComment": "Comment"
                }
            }
        };

        const COLUMN_ORDER = {
            "Interfaces": ["Name", "Zone", "IP Address", "Subnet Mask", "Enabled", "Comment"],
            "Zones": ["Name", "Zone Type", "Member Interfaces", "Interface Trust", "GAV Profile", "Anti-Spyware Profile", "IPS", "App Control Profile", "DPI-SSL Client", "DPI-SSL Server"],
            "Access Rules": ["Name", "Action", "Source Zone", "Dest Zone", "Source Address", "Destination Address", "Service", "Comment"],
            "Address Objects": ["Name", "IP/Start", "Mask/End", "Type", "Zone", "Group Members", "Custom/Default"],
            "Service Objects": ["Name", "Protocol", "Port Start", "Port End", "Custom/Default"],
            "Service Groups": ["Name", "Group Members", "Custom/Default"],
            "Routing Policies": ["Name", "Source", "Destination", "Service", "Interface", "Gateway", "Metric", "Class"],
            "NAT Rules": ["Name", "Status", "Ingress Interface", "Egress Interface", "Original Source", "Original Dest", "Original Service", "Translated Source", "Translated Dest", "Translated Service"]
        };

        const ZONE_TYPE_MAP = {
            "1": "Trusted", "0": "Untrusted", "2": "Public", "5": "Encrypted", "8": "SSL VPN", "4": "Wireless", "6": "Untrusted"
        };
        // ... (skip lines 363-1017, using separate chunks or assuming I must replace contiguous block?
        // I will just replace COLUMN_ORDER and renderServiceObjectsTabs separately.
        // This replacement only covers COLUMN_ORDER. I'll use multi check below.)
        const ACTION_MAP = {
            "2": "ALLOW", "0": "DENY", "1": "DISCARD"
        };
        const ADDRESS_OBJ_TYPE_MAP = {
            "1": "Host", "2": "Range", "4": "Network", "8": "Group", "9": "MAC", "10": "FQDN", "0": "Host"
        };
        const SERVICE_PROTOCOL_MAP = {
            "1": "TCP",
            "0": "UDP",
            "6": "TCP",
            "17": "UDP",
            "2": "Group"
        };
        const ROUTING_TYPE_MAP = {
            "1": "Custom", "0": "Default"
        };

        const ANY_INTERFACE_ID = "4294967295";
        const ANY_VALUE = "Any";

        /* =========================================
           2. GLOBAL STATE & DOM ELEMENTS
           ========================================= */

        let PARSED_DATA = {};
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');

        if (fileInput) {
            fileInput.addEventListener('change', handleFileSelect);
        }

        /* =========================================
           3. EVENT HANDLERS
           ========================================= */

        function togglePasteModal() {
            const modal = document.getElementById('pasteModal');
            modal.classList.toggle('hidden');
            if (!modal.classList.contains('hidden')) {
                const area = document.getElementById('pasteArea');
                area.value = '';
                area.focus();
            }
        }

        function processPaste() {
            const text = document.getElementById('pasteArea').value;
            if (text && text.trim().length > 0) {
                updateFileNameDisplay("Pasted Configuration");
                parseConfig(text);
                togglePasteModal();
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                updateFileNameDisplay(file.name);
                const reader = new FileReader();
                reader.onload = function (e) {
                    const text = e.target.result;
                    parseConfig(text);
                };
                reader.readAsText(file);
            } else {
                clearInput();
            }
        }

        function updateFileNameDisplay(name) {
            fileNameDisplay.textContent = name;
            fileNameDisplay.classList.remove('italic', 'text-obsidian-textMuted');
            fileNameDisplay.classList.add('font-semibold', 'text-white');
        }

        function clearInput() {
            fileInput.value = '';
            fileNameDisplay.textContent = 'No file chosen';
            fileNameDisplay.classList.add('italic', 'text-obsidian-textMuted');
            fileNameDisplay.classList.remove('font-semibold', 'text-white');

            document.getElementById('resultsArea').classList.add('hidden');
            document.getElementById('emptyState').classList.add('hidden'); // Ensure empty state is hidden when clearing
            PARSED_DATA = {};
        }

        function copyToClipboard() {
            if (Object.keys(PARSED_DATA).length === 0) return;
            const json = JSON.stringify(PARSED_DATA, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                alert('Parsed JSON copied to clipboard!');
            });
        }

        function switchTab(tabId) {
            // Hide all contents
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            // Deactivate all buttons
            document.querySelectorAll('.tab-btn').forEach(el => {
                el.classList.remove('border-obsidian-accent', 'text-obsidian-accent', 'active');
                el.classList.add('border-transparent', 'text-obsidian-textMuted');
            });

            // Show target content
            const targetContent = document.getElementById(tabId);
            if (targetContent) targetContent.classList.add('active');

            // Activate target button(s)
            const buttons = document.querySelectorAll('.tab-btn');
            for (const btn of buttons) {
                if (btn.innerText.replace(/\s+/g, '-').toLowerCase() === tabId) {
                    btn.classList.add('border-obsidian-accent', 'text-obsidian-accent', 'active');
                    btn.classList.remove('border-transparent', 'text-obsidian-textMuted');
                }
            }
        }

        /* =========================================
           4. PARSING LOGIC
           ========================================= */

        function parseConfig(configText) {
            // 1. Build lookup maps
            const interfaceMap = buildInterfaceMap(configText);
            const addressObjectMap = buildAddressObjectMap(configText);
            const groupMemberMap = buildAddressGroupMemberMap(configText);

            // 2. Parse the text map
            PARSED_DATA = parseConfigText(configText, interfaceMap, addressObjectMap, groupMemberMap);

            // 3. Render
            renderTabs(PARSED_DATA);

            // 4. Update UI state
            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('emptyState').classList.add('hidden');
        }

        function parseConfigText(configText, interfaceMap, addressObjectMap, groupMemberMap) {
            const results = {};
            const lines = configText.split('\n');

            // Helper to collect Interfaces for Zone calculation
            let allInterfaces = [];

            for (const [sectionName, sectionMap] of Object.entries(CONFIG_MAP)) {

                const firstKey = Object.keys(sectionMap)[0];
                const isNested = (typeof sectionMap[firstKey] === 'object' && sectionMap[firstKey] !== null);

                if (isNested) {
                    results[sectionName] = {};
                    for (const [subSectionName, subMap] of Object.entries(sectionMap)) {
                        if (subMap._array) {
                            results[sectionName][subSectionName] = parseGenericArray(lines, subMap, interfaceMap, addressObjectMap);
                        } else {
                            results[sectionName][subSectionName] = parseGenericKV(lines, subMap);
                        }
                    }
                } else {
                    if (sectionMap._array) {
                        let parsedArray = parseGenericArray(lines, sectionMap, interfaceMap, addressObjectMap);

                        if (sectionName === "Interfaces") {
                            parsedArray.sort((a, b) => {
                                const nameA = a["Name"] || "";
                                const nameB = b["Name"] || "";
                                return nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
                            });

                            // Fix WAN IP or missing IP by looking up Address Object "Xn IP"
                            const addressObjects = results["Address Objects"] || [];
                            parsedArray.forEach(iface => {
                                // 1. Check for 0.0.0.0 or missing IP
                                const currentIP = iface["IP Address"];
                                if (!currentIP || currentIP === "0.0.0.0" || currentIP === "(DHCP)") {
                                    const ifaceName = iface["Name"];
                                    // Try to find Address Object "Xn IP"
                                    const targetName = `${ifaceName} IP`;

                                    const addrObj = addressObjects.find(obj =>
                                        obj["Display Name"] === targetName || obj["Name"] === targetName
                                    );

                                    if (addrObj && addrObj["IP/Start"] && addrObj["IP/Start"] !== "0.0.0.0") {
                                        iface["IP Address"] = addrObj["IP/Start"];
                                        // Optional: Update mask if available and missing
                                        if (addrObj["Mask/End"] && (!iface["Subnet Mask"] || iface["Subnet Mask"] === "0.0.0.0")) {
                                            iface["Subnet Mask"] = addrObj["Mask/End"];
                                        }
                                    } else {
                                        // If still not found and valid WAN/X1, mark as DHCP
                                        if ((iface["Zone"] === "WAN" || (ifaceName && ifaceName.startsWith("X1"))) && (currentIP === "0.0.0.0" || !currentIP)) {
                                            iface["IP Address"] = "(DHCP)";
                                        }
                                    }
                                }
                            });
                            allInterfaces = parsedArray;
                        }

                        if (sectionName === "Address Objects" && groupMemberMap) {
                            parsedArray.forEach(obj => {
                                if (obj["Name"] && groupMemberMap[obj["Name"]]) {
                                    obj["Group Members"] = groupMemberMap[obj["Name"]];
                                }
                            });
                        }
                        results[sectionName] = parsedArray;
                    } else {
                        results[sectionName] = parseGenericKV(lines, sectionMap);
                    }
                }
            }

            // Post-Process: Calculate Member Interfaces for Zones
            if (results["Zones"] && Array.isArray(results["Zones"])) {
                results["Zones"].forEach(zone => {
                    const zoneName = zone["Name"];
                    if (zoneName) {
                        const members = allInterfaces.filter(iface => iface["Zone"] === zoneName).map(iface => iface["Name"]);
                        if (members.length > 0) {
                            zone["Member Interfaces"] = members;
                        }
                    }
                });
            }

            // Post-Process: Service Groups Enrichment
            if (results["Service Group Mappings"] && results["Service Objects"]) {
                const serviceGroupMap = {};
                results["Service Group Mappings"].forEach(mapping => {
                    const group = mapping["Group"];
                    const member = mapping["Member"];
                    if (group && member) {
                        if (!serviceGroupMap[group]) serviceGroupMap[group] = [];
                        serviceGroupMap[group].push(member);
                    }
                });

                results["Service Objects"].forEach(obj => {
                    if (obj["Name"] && serviceGroupMap[obj["Name"]]) {
                        obj["Group Members"] = serviceGroupMap[obj["Name"]];
                    }
                });
            }

            return results;
        }

        function buildInterfaceMap(text) {
            const map = {};
            const lines = text.split('\n');
            const ifNumRegex = /^iface_ifnum_(\d+)=(\d+)/;
            const ifNameRegex = /^iface_name_(\d+)=(.*)/;
            const temp = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match = trimmed.match(ifNumRegex);
                if (match) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].id = match[2];
                    continue;
                }
                match = trimmed.match(ifNameRegex);
                if (match) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].name = decodeURIComponent(match[2]);
                }
            }

            Object.values(temp).forEach(obj => {
                if (obj.id && obj.name) {
                    map[obj.id] = obj.name;
                }
            });

            map["-1"] = "Any";
            map[ANY_INTERFACE_ID] = "Any";
            return map;
        }

        function buildAddressObjectMap(text) {
            const map = {};
            const lines = text.split('\n');
            const idRegex = /^addrObjId_(\d+)=(.*)/;
            const ip1Regex = /^addrObjIp1_(\d+)=(.*)/;
            const ip2Regex = /^addrObjIp2_(\d+)=(.*)/;
            const typeRegex = /^addrObjType_(\d+)=(.*)/;
            const fqdnIdRegex = /^addrObjFqdnId_(\d+)=(.*)/;
            const fqdnValRegex = /^addrObjFqdn_(\d+)=(.*)/;

            const temp = {};
            const tempFqdn = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match;
                if ((match = trimmed.match(idRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].name = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(ip1Regex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].ip1 = match[2];
                } else if ((match = trimmed.match(ip2Regex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].ip2 = match[2];
                } else if ((match = trimmed.match(typeRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].type = match[2];
                } else if ((match = trimmed.match(fqdnIdRegex))) {
                    const idx = match[1];
                    if (!tempFqdn[idx]) tempFqdn[idx] = {};
                    tempFqdn[idx].name = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(fqdnValRegex))) {
                    const idx = match[1];
                    if (!tempFqdn[idx]) tempFqdn[idx] = {};
                    tempFqdn[idx].fqdn = match[2];
                }
            }

            Object.values(temp).forEach(obj => {
                if (obj.name) {
                    let desc = "";
                    if (obj.type === "8") {
                        desc = "Group";
                    } else if (obj.ip1) {
                        desc = obj.ip1;
                        if (obj.type === "4" && obj.ip2 && obj.ip2 !== "0.0.0.0") {
                            desc = `${obj.ip1}/${obj.ip2}`;
                        } else if (obj.type === "2" && obj.ip2 && obj.ip2 !== "0.0.0.0") {
                            desc = `${obj.ip1}-${obj.ip2}`;
                        }
                    }
                    if (desc) map[obj.name] = desc;
                }
            });

            Object.values(tempFqdn).forEach(obj => {
                if (obj.name && obj.fqdn) {
                    map[obj.name] = obj.fqdn;
                }
            });

            return map;
        }

        function buildAddressGroupMemberMap(text) {
            const map = {};
            const lines = text.split('\n');
            const atomRegex = /^addro_atomToGrp_(\d+)=(.*)/;
            const grpRegex = /^addro_grpToGrp_(\d+)=(.*)/;
            const temp = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match;
                if ((match = trimmed.match(atomRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].atom = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(grpRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].grp = decodeURIComponent(match[2]);
                }
            }

            Object.values(temp).forEach(item => {
                if (item.atom && item.grp) {
                    if (!map[item.grp]) map[item.grp] = [];
                    map[item.grp].push(item.atom);
                }
            });

            return map;
        }

        function parseGenericKV(lines, map) {
            const result = {};
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                for (const [key, label] of Object.entries(map)) {
                    if (trimmed.startsWith(key + '=')) {
                        let value = trimmed.substring(key.length + 1);
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (key === 'dns_use_static_servers') {
                            if (value === '1' || value.toLowerCase() === 'on') value = 'True';
                            else if (value === '0' || value.toLowerCase() === 'off') value = 'False';
                        }

                        result[label] = value;
                        break;
                    }
                }
            }
            return result;
        }

        function parseGenericArray(lines, map, interfaceMap, addressObjectMap) {
            const tempMap = {};

            for (const line of lines) {
                const trimmed = line.trim();
                for (const [key, label] of Object.entries(map)) {
                    if (key === '_array') continue;

                    const regex = new RegExp(`^${key}_(\\d+)=(.*)`);
                    const match = trimmed.match(regex);

                    if (match) {
                        const index = match[1];
                        let value = match[2];
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (!tempMap[index]) tempMap[index] = {};

                        if (key === 'zoneObjZoneType') value = ZONE_TYPE_MAP[value] || value;
                        if (key === 'addrObjType') value = ADDRESS_OBJ_TYPE_MAP[value] || value;
                        if (key === 'policyAction') value = ACTION_MAP[value] || value;
                        if (key === 'svcObjType' || key === 'svcObjIpType') value = SERVICE_PROTOCOL_MAP[value] || value;
                        if (key === 'pbrObjType') value = ROUTING_TYPE_MAP[value] || "Default";

                        if (key === 'policySrcIf' || key === 'policyDstIf' ||
                            key === 'natPolicySrcIface' || key === 'natPolicyDstIface' ||
                            key === 'pbrObjIface') {
                            value = interfaceMap[value] || value;
                        }

                        if ((key === 'policySrcNet' || key === 'policyDstNet' ||
                            key === 'policySrcSvc' || key === 'policyDstSvc' ||
                            key === 'natPolicyOrigSrc' || key === 'natPolicyOrigDst' ||
                            key === 'natPolicyOrigSvc' ||
                            key === 'pbrObjSrc' || key === 'pbrObjDst' ||
                            key === 'pbrObjSvc' || key === 'pbrObjGw' || key === 'pbrObjIface'
                        ) && value === "") {
                            value = ANY_VALUE;
                        }

                        if ((key === 'natPolicyTransSrc' || key === 'natPolicyTransDst' || key === 'natPolicyTransSvc') && value === "") {
                            value = "Original";
                        }

                        if ((key === 'policySrcNet' || key === 'policyDstNet' ||
                            key === 'natPolicyOrigSrc' || key === 'natPolicyOrigDst' ||
                            key === 'natPolicyTransSrc' || key === 'natPolicyTransDst' ||
                            key === 'pbrObjSrc' || key === 'pbrObjDst' || key === 'pbrObjGw'
                        ) && value !== ANY_VALUE) {
                            if (addressObjectMap && addressObjectMap[value]) {
                                value = `${value} <span class="text-obsidian-textMuted text-xs">(${addressObjectMap[value]})</span>`;
                            }
                        }

                        // Prevent overwriting valid IP with 0.0.0.0 or empty
                        const currentValue = tempMap[index][label];
                        const isZeroIP = (value === "0.0.0.0" || value === "");

                        if ((label === "IP Address" || label === "Gateway") && currentValue && currentValue !== "0.0.0.0" && currentValue !== "(DHCP)" && isZeroIP) {
                            // Skip overwriting a valid IP or Gateway with 0.0.0.0
                        } else {
                            tempMap[index][label] = value;
                        }
                        break;
                    }
                }
            }
            // Post-process for missing default values (specifically for Routing Class)
            Object.values(tempMap).forEach(obj => {
                if (obj.hasOwnProperty("Gateway") && obj.hasOwnProperty("Metric")) {
                    // User feedback indicates "Auto-named" policies without type are considered "Custom"
                    // and "Default" policies (standard routing table) are not in this file.
                    // So default to "Custom" if missing.
                    if (!obj["Class"]) obj["Class"] = "Custom";
                }

                // Address Object Logic: Fallback Name & Custom/Default Detection
                if (obj.hasOwnProperty("ID") && obj.hasOwnProperty("Type") && obj.hasOwnProperty("Zone")) {
                    // Fallback Name
                    if (!obj["Name"] || obj["Name"] === "") {
                        obj["Name"] = obj["ID"];
                    }

                    // Custom/Default Logic based on Properties (793 = Default/System Objects, 29 = Default/System Groups)
                    // If properties are missing, fallback to heuristic or default to Custom.
                    if (obj.hasOwnProperty("Properties")) {
                        obj["Custom/Default"] = (obj["Properties"] === "793" || obj["Properties"] === "29") ? "Default" : "Custom";
                    } else {
                        // Heuristic Fallback (legacy/safety)
                        const name = obj["Name"] || "";
                        const id = obj["ID"] || "";
                        const isDefault = /^(X\d+\s+(IP|Subnet)|All\s+|WAN\s+|LAN\s+|DMZ\s+)/i.test(name) ||
                            /^(X\d+\s+(IP|Subnet)|All\s+|WAN\s+|LAN\s+|DMZ\s+)/i.test(id);
                        obj["Custom/Default"] = isDefault ? "Default" : "Custom";
                    }
                }

                // Service Object Logic: Custom/Default
                if (obj.hasOwnProperty("Properties") && obj.hasOwnProperty("Protocol")) {
                    // 14 = Custom, others (e.g. 11293) = Default
                    if (obj["Properties"] === "14") {
                        obj["Custom/Default"] = "Custom";
                    } else {
                        obj["Custom/Default"] = "Default";
                    }
                }
            });

            return Object.values(tempMap);
        }

        /* =========================================
           5. RENDERING LOGIC
           ========================================= */

        function renderTabs(data) {
            const tabsHeader = document.getElementById('tabsHeader');
            const tabsContent = document.getElementById('tabsContent');

            tabsHeader.innerHTML = '';
            tabsContent.innerHTML = '';

            let first = true;
            for (const [sectionName, sectionData] of Object.entries(data)) {
                if (sectionName === 'CLI' || sectionName === 'Service Group Mappings') continue;

                const tabId = sectionName.replace(/\s+/g, '-').toLowerCase();

                // Create Button
                const btn = document.createElement('button');
                btn.className = `tab-btn group inline-flex items-center px-4 py-4 border-b-2 font-medium text-sm mr-4 whitespace-nowrap transition-colors ${first ? 'border-obsidian-accent text-obsidian-accent active' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text hover:border-obsidian-border'}`;
                btn.innerText = sectionName;
                btn.onclick = () => switchTab(tabId);
                tabsHeader.appendChild(btn);

                // Create Content
                const contentDiv = document.createElement('div');
                contentDiv.id = tabId;
                contentDiv.className = `tab-content ${first ? 'active' : ''} space-y-6`;

                const isNested = !Array.isArray(sectionData) && Object.values(sectionData).some(v => typeof v === 'object');

                if (isNested) {
                    renderNestedSection(contentDiv, sectionData);
                } else if (sectionName === "Address Objects" && Array.isArray(sectionData)) {
                    renderAddressObjectsTabs(contentDiv, sectionData);
                } else if (sectionName === "Service Objects" && Array.isArray(sectionData)) {
                    renderServiceObjectsTabs(contentDiv, sectionData);
                } else if (Array.isArray(sectionData)) {
                    renderArrayTable(contentDiv, sectionData, sectionName); // Pass section name for sorting
                } else {
                    renderKVTable(contentDiv, sectionData);
                }

                tabsContent.appendChild(contentDiv);
                first = false;
            }
        }

        function renderNestedSection(container, data) {
            for (const [subTitle, subData] of Object.entries(data)) {
                const h3 = document.createElement('h3');
                h3.className = "text-lg font-medium leading-6 text-white mb-2 pb-1 border-b border-obsidian-border";
                h3.innerText = subTitle;
                container.appendChild(h3);

                const subContainer = document.createElement('div');
                subContainer.className = "mb-8";
                if (Array.isArray(subData)) {
                    renderArrayTable(subContainer, subData, subTitle);
                } else {
                    renderKVTable(subContainer, subData);
                }
                container.appendChild(subContainer);
            }
        }

        function renderAddressObjectsTabs(container, data) {
            const hosts = [], networks = [], ranges = [], groups = [];

            data.forEach(item => {
                const type = item["Type"];
                const isGroup = type === "Group" || !!item["Group Members"];
                const isNetwork = type === "Network" || type === "4";
                const isRange = type === "Range" || type === "2";

                if (isGroup) {
                    groups.push(item);
                } else if (isNetwork) {
                    networks.push(item);
                } else if (isRange) {
                    ranges.push(item);
                } else {
                    if (!item["Mask/End"] || item["Mask/End"] === "0.0.0.0") {
                        item["Mask/End"] = "255.255.255.255";
                    }
                    hosts.push(item);
                }
            });

            // Sub-Tabs Header
            const subNav = document.createElement('div');
            subNav.className = "flex space-x-2 mb-4 border-b border-obsidian-border";
            const subContent = document.createElement('div');

            const categories = [
                { name: "Hosts", data: hosts },
                { name: "Networks", data: networks },
                { name: "Ranges", data: ranges },
                { name: "Groups", data: groups }
            ];

            categories.forEach((cat, idx) => {
                const btn = document.createElement('button');
                btn.className = `px-3 py-2 text-sm font-medium transition-colors border-b-2 ${idx === 0 ? 'border-obsidian-accent text-obsidian-accent' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text'}`;
                btn.innerText = `${cat.name} (${cat.data.length})`;

                btn.onclick = (e) => {
                    subNav.querySelectorAll('button').forEach(b => {
                        b.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-transparent text-obsidian-textMuted hover:text-obsidian-text";
                    });
                    e.target.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-obsidian-accent text-obsidian-accent";

                    subContent.innerHTML = '';
                    renderArrayTable(subContent, cat.data, "Address Objects");
                };
                subNav.appendChild(btn);
            });

            container.appendChild(subNav);
            container.appendChild(subContent);

            renderArrayTable(subContent, hosts, "Address Objects");
        }

        function renderServiceObjectsTabs(container, data) {
            const groups = [], custom = [], checkDefault = [], all = [];

            data.forEach(item => {
                // Determine if item is a group: Protocol is Group OR it has populated members
                const isGroup = (item["Protocol"] === "Group") || (item["Group Members"] && item["Group Members"].length > 0);

                if (isGroup) {
                    groups.push(item);
                } else {
                    // Only add non-groups to the main list (or should main list show all? Usually Objects only)
                    // Let's keep "Services" as "All Individual Objects"
                    all.push(item);

                    if (item["Custom/Default"] === "Custom") {
                        custom.push(item);
                    } else {
                        checkDefault.push(item);
                    }
                }
            });

            // Sub-Tabs Header
            const subNav = document.createElement('div');
            subNav.className = "flex space-x-2 mb-4 border-b border-obsidian-border";
            const subContent = document.createElement('div');

            const categories = [
                { name: "Services", data: all, section: "Service Objects" },
                { name: "Groups", data: groups, section: "Service Groups" },
                { name: "Custom", data: custom, section: "Service Objects" },
                { name: "Default", data: checkDefault, section: "Service Objects" }
            ];

            categories.forEach((cat, idx) => {
                const btn = document.createElement('button');
                btn.className = `px-3 py-2 text-sm font-medium transition-colors border-b-2 ${idx === 0 ? 'border-obsidian-accent text-obsidian-accent' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text'}`;
                btn.innerText = `${cat.name} (${cat.data.length})`;

                btn.onclick = (e) => {
                    subNav.querySelectorAll('button').forEach(b => {
                        b.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-transparent text-obsidian-textMuted hover:text-obsidian-text";
                    });
                    e.target.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-obsidian-accent text-obsidian-accent";

                    subContent.innerHTML = '';
                    renderArrayTable(subContent, cat.data, cat.section);
                };
                subNav.appendChild(btn);
            });

            container.appendChild(subNav);
            container.appendChild(subContent);

            // Default view: Services (Individual Objects)
            renderArrayTable(subContent, all, "Service Objects");
        }


        function renderKVTable(container, data) {
            if (Object.keys(data).length === 0) {
                container.innerHTML += '<p class="text-obsidian-textMuted text-sm italic">No data found.</p>';
                return;
            }
            const table = document.createElement('table');
            table.className = "min-w-full divide-y divide-obsidian-border";
            const tbody = document.createElement('tbody');
            tbody.className = "divide-y divide-obsidian-border";

            for (const [key, value] of Object.entries(data)) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="px-6 py-3 whitespace-nowrap text-sm font-medium text-obsidian-text w-1/3">${key}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-obsidian-textMuted font-mono">${renderValue(value, key)}</td>
                `;
                tbody.appendChild(tr);
            }
            table.appendChild(tbody);

            const shadowWrapper = document.createElement('div');
            shadowWrapper.className = "shadow ring-1 ring-obsidian-border rounded-lg overflow-hidden bg-obsidian-bg";
            shadowWrapper.appendChild(table);
            container.appendChild(shadowWrapper);
        }

        function renderArrayTable(container, data, sectionIdentifier = "") {
            if (!data || data.length === 0) {
                container.innerHTML = '<p class="text-obsidian-textMuted text-sm italic">No items found.</p>';
                return;
            }

            // Determine columns to display
            const customOrder = COLUMN_ORDER[sectionIdentifier];
            let colArray = [];

            if (customOrder) {
                // Strict mode: Use exactly the columns defined in COLUMN_ORDER
                colArray = [...customOrder];
            } else {
                // Auto-detect mode: Collect all keys from data
                const columns = new Set();
                data.forEach(item => Object.keys(item).forEach(k => columns.add(k)));
                colArray = Array.from(columns);

                // Fallback default sort for auto-detected columns
                const priorityCols = ["Name", "Action", "Zone Type", "IP Address", "Source Zone"];
                colArray.sort((a, b) => {
                    const idxA = priorityCols.indexOf(a);
                    const idxB = priorityCols.indexOf(b);
                    if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                    if (idxA !== -1) return -1;
                    if (idxB !== -1) return 1;
                    return a.localeCompare(b);
                });

                // Filter out empty columns in auto-detect mode
                colArray = colArray.filter(col => data.some(row => row[col] && row[col] !== ""));
            }

            // Filter Logic
            const searchContainer = document.createElement('div');
            searchContainer.className = "mb-4 sticky left-0";
            const searchInput = document.createElement('input');
            searchInput.type = "text";
            searchInput.placeholder = `Filter ${sectionIdentifier}...`;
            searchInput.className = "w-full max-w-sm px-4 py-2 bg-obsidian-pane border border-obsidian-border rounded-md text-sm text-obsidian-text focus:outline-none focus:border-obsidian-accent focus:ring-1 focus:ring-obsidian-accent placeholder-obsidian-textMuted transition-colors";

            searchContainer.appendChild(searchInput);
            container.appendChild(searchContainer);

            const wrapper = document.createElement('div');
            wrapper.className = "shadow ring-1 ring-obsidian-border rounded-lg overflow-hidden bg-obsidian-bg";
            const scrollContainer = document.createElement('div');
            scrollContainer.className = "overflow-x-auto table-container";

            const table = document.createElement('table');
            table.className = "min-w-full divide-y divide-obsidian-border";

            // Wire up filter
            searchInput.addEventListener('input', (e) => {
                const term = e.target.value.toLowerCase();
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const text = Array.from(row.children).map(c => c.textContent).join(' ').toLowerCase();
                    row.style.display = text.includes(term) ? '' : 'none';
                });
            });

            // Header
            const thead = document.createElement('thead');
            thead.className = "bg-obsidian-pane";
            let thHtml = '<tr>';
            colArray.forEach(col => {
                thHtml += `<th scope="col" class="px-4 py-3 text-left text-xs font-semibold text-white uppercase tracking-wider whitespace-nowrap">${col}</th>`;
            });
            thHtml += '</tr>';
            thead.innerHTML = thHtml;
            table.appendChild(thead);

            // Body
            const tbody = document.createElement('tbody');
            tbody.className = "divide-y divide-obsidian-border";

            data.forEach((item, idx) => {
                const tr = document.createElement('tr');
                tr.className = idx % 2 === 0 ? 'bg-transparent' : 'bg-[#2a2a2c]';
                tr.className += ' hover:bg-[#323234] transition-colors';

                let tdHtml = '';
                colArray.forEach(col => {
                    let val = item[col] || "";
                    let content = renderValue(val, col); // Pass column name to renderValue

                    if (col === "Name" && val.includes && val.includes(":")) {
                        content = `<span class="ml-4 border-l-2 border-obsidian-border pl-2 text-obsidian-textMuted">${content}</span>`;
                    }

                    tdHtml += `<td class="px-4 py-3 text-sm text-obsidian-text whitespace-nowrap">${content}</td>`;
                });
                tr.innerHTML = tdHtml;
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);

            scrollContainer.appendChild(table);
            wrapper.appendChild(scrollContainer);
            container.appendChild(wrapper);
        }

        function renderValue(val, key = "") {
            if (Array.isArray(val)) {
                return val.map(v => `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-obsidian-pane border border-obsidian-border text-obsidian-text mr-1 mb-1">${v}</span>`).join('');
            }

            // Only convert 0/1 to boolean for specific keys
            const booleanKeys = ["Enabled", "Status", "Ready", "Active", "IPS", "GAV", "Anti-Spyware", "App Control", "Botnet", "Geo-IP", "DPI-SSL", "DPI-SSL Client", "DPI-SSL Server", "Multicast"];
            const isBooleanKey = booleanKeys.some(k => key.includes(k) || key === k);

            if (isBooleanKey) {
                if (val === "1" || String(val).toLowerCase() === "on" || val === "True") {
                    return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">Yes</span>';
                }
                if (val === "0" || String(val).toLowerCase() === "off" || val === "False") {
                    return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">No</span>';
                }
            } else {
                // For non-boolean keys, if value is explicitly "True"/"False" string (Python bools), render them.
                // But strictly avoid 0/1 conversion.
                if (String(val).toLowerCase() === "true") return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">Yes</span>';
                if (String(val).toLowerCase() === "false") return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">No</span>';
            }

            if (val === "ALLOW") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">ALLOW</span>';
            }
            if (val === "DENY") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">DENY</span>';
            }
            if (val === "DISCARD" || val === "DROP") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-orange-900/30 text-orange-400 border border-orange-800">DISCARD</span>';
            }
            if (val === ANY_VALUE) {
                return '<span class="italic text-obsidian-textMuted">Any</span>';
            }
            return val;
        }
    </script>
</body>

</html>