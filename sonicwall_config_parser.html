<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SonicWall Config Parser | Homelab Playground</title>
    <link rel="icon" type="image/png" href="favicon.png">

    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <!-- Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        obsidian: {
                            bg: '#1e1e1e',
                            pane: '#252526',
                            border: '#3c3c3c',
                            accent: '#7c3aed',
                            accentHover: '#6d28d9',
                            text: '#cccccc',
                            textMuted: '#9ca3af',
                            success: '#10b981',
                            warning: '#f59e0b',
                            danger: '#ef4444'
                        }
                    },
                    fontFamily: {
                        mono: ['"Fira Code"', 'monospace'],
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3c3c3c;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-btn.active {
            border-bottom-color: #7c3aed;
            color: #7c3aed;
        }
    </style>
</head>

<body class="flex flex-col h-screen overflow-hidden bg-obsidian-bg text-obsidian-text font-sans">

    <!-- Header -->
    <header
        class="h-14 bg-obsidian-pane border-b border-obsidian-border flex items-center justify-between px-6 shrink-0 z-20">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-shield-halved text-obsidian-accent text-lg"></i>
            <h1 class="font-semibold text-white tracking-tight">SonicWall Config Parser</h1>
        </div>
        <div class="flex items-center gap-4">
            <!-- File Input hidden -->
            <input type="file" id="fileInput" accept=".txt,.exp" class="hidden">

            <button onclick="document.getElementById('fileInput').click()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors">
                <i class="fa-solid fa-upload mr-2 text-obsidian-accent"></i>
                Upload
            </button>

            <button onclick="togglePasteModal()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors">
                <i class="fa-solid fa-paste mr-2 text-obsidian-accent"></i>
                Paste Text
            </button>

            <span id="fileName" class="text-sm text-obsidian-textMuted italic max-w-[200px] truncate ml-2">No file
                chosen</span>

            <button onclick="copyToClipboard()"
                class="inline-flex items-center px-3 py-1.5 border border-obsidian-border text-sm font-medium rounded-md shadow-sm text-obsidian-text bg-obsidian-pane hover:bg-obsidian-accentHover/10 focus:outline-none transition-colors ml-4">
                <i class="fa-regular fa-copy mr-2 text-obsidian-accent"></i>
                Copy JSON
            </button>
        </div>
    </header>

    <!-- Paste Modal -->
    <div id="pasteModal"
        class="fixed inset-0 bg-black/80 hidden z-50 flex items-center justify-center backdrop-blur-sm">
        <div
            class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl w-full max-w-4xl flex flex-col h-[80vh]">
            <div class="flex items-center justify-between px-6 py-4 border-b border-obsidian-border bg-obsidian-pane">
                <h3 class="text-lg font-semibold text-white"><i
                        class="fa-solid fa-clipboard mr-2 text-obsidian-accent"></i>Paste Configuration</h3>
                <button onclick="togglePasteModal()" class="text-obsidian-textMuted hover:text-white transition-colors">
                    <i class="fa-solid fa-xmark text-xl"></i>
                </button>
            </div>
            <div class="p-0 flex-1 flex flex-col min-h-0">
                <textarea id="pasteArea"
                    class="w-full h-full bg-obsidian-bg border-none p-4 font-mono text-xs text-obsidian-text focus:ring-0 outline-none resize-none"
                    placeholder="Paste SonicWall configuration text here..."></textarea>
            </div>
            <div class="px-6 py-4 border-t border-obsidian-border bg-obsidian-pane flex justify-end space-x-3">
                <button onclick="togglePasteModal()"
                    class="px-4 py-2 text-obsidian-textMuted hover:text-white transition-colors text-sm font-medium">Cancel</button>
                <button onclick="processPaste()"
                    class="bg-obsidian-accent hover:bg-obsidian-accentHover text-white px-6 py-2 rounded-md font-medium transition-colors shadow-lg shadow-obsidian-accent/20">
                    <i class="fa-solid fa-bolt mr-2"></i>Parse Text
                </button>
            </div>
        </div>
    </div>


    </header>

    <!-- Main Content -->
    <main class="flex-1 overflow-auto p-4 md:p-8 flex flex-col gap-6 max-w-7xl mx-auto w-full">

        <!-- Results Section -->
        <div id="resultsArea"
            class="hidden bg-obsidian-pane shadow-lg border border-obsidian-border rounded-xl overflow-hidden min-h-[600px] flex flex-col">
            <!-- Tabs Header -->
            <div class="border-b border-obsidian-border overflow-x-auto bg-obsidian-pane shrink-0">
                <nav class="flex px-4" aria-label="Tabs" id="tabsHeader">
                    <!-- Tabs injected by JS -->
                </nav>
            </div>

            <!-- Tab Contents -->
            <div id="tabsContent" class="p-6 flex-1 overflow-auto">
                <!-- Tab panes injected by JS -->
            </div>
        </div>

        <!-- Empty State -->
        <div id="emptyState" class="text-center py-20 flex flex-col items-center justify-center opacity-60">
            <i class="fa-solid fa-file-code text-6xl text-obsidian-border mb-4"></i>
            <h3 class="mt-2 text-lg font-medium text-white">No configuration parsed</h3>
            <p class="mt-1 text-sm text-obsidian-textMuted">Upload a SonicWall configuration file (.txt or .exp) to view
                the parsed details.</p>
        </div>

    </main>

    <!-- Footer -->
    <footer class="bg-obsidian-pane border-t border-obsidian-border py-3 text-center shrink-0">
        <a href="index.html"
            class="text-obsidian-textMuted hover:text-obsidian-accent text-xs transition-colors no-underline">
            HomeLab Playground
        </a>
    </footer>

    <script>
        // CONFIG_MAP defines the structure and mapping of the SonicWall config
        const CONFIG_MAP = {
            "Zones": {
                "_array": "zoneObjId",
                "zoneObjId": "Name",
                "zoneObjZoneType": "Zone Type",
                "zoneObjIntraZoneCom": "Allow Interface Trust",
                "zoneObjAvProfile": "Gateway AV Profile",
                "zoneObjACProfile": "App Control Profile",
                "zoneObjASProfile": "Anti-Spyware Profile",
                "zoneObjGavProfile": "GAV Profile",
                "zoneObjDPISSLSProfile": "DPI-SSL Server",
                "zoneObjDPISSLCProfile": "DPI-SSL Client",
                "zoneObjEnableContentFiltering": "CFS Enabled"
            },
            "Interfaces": {
                "_array": "iface_ifnum",
                "iface_name": "Name",

                "interface_Zone": "Zone",
                "iface_comment": "Comment",
                "iface_lan_ip": "IP Address",
                "iface_static_ip": "IP Address",
                "iface_lan_mask": "Subnet Mask",
                "iface_static_mask": "Subnet Mask",
                "iface_static_gateway": "Gateway",
                "iface_lan_default_gw": "Gateway",
                "iface_https_mgmt": "HTTPS Mgmt",
                "iface_ping_mgmt": "Ping Mgmt",
                "iface_ssh_mgmt": "SSH Mgmt",
                "iface_snmp_mgmt": "SNMP Mgmt"
            },
            "Access Rules": {
                "_array": "policyAction",
                "policyName": "Name",
                "policyAction": "Action",
                "policySrcZone": "Source Zone",
                "policyDstZone": "Dest Zone",
                "policySrcNet": "Source Network",
                "policyDstNet": "Dest Network",
                "policySrcSvc": "Source Service",
                "policyDstSvc": "Dest Service",
                "policySrcIf": "Source Interface",
                "policyDstIf": "Dest Interface",
                "policyComment": "Comment",
                "policyEnabled": "Enabled",
                "policyLog": "Logging"
            },
            "NAT Rules": {
                "_array": "natPolicyOrigSrc",
                "natPolicyName": "Name",
                "natPolicyOrigSrc": "Original Source",
                "natPolicyOrigDst": "Original Dest",
                "natPolicyOrigSvc": "Original Service",
                "natPolicyTransSrc": "Translated Source",
                "natPolicyTransDst": "Translated Dest",
                "natPolicyTransSvc": "Translated Service",
                "natPolicySrcIface": "Source Interface",
                "natPolicyDstIface": "Dest Interface",
                "natPolicyComment": "Comment",
                "natPolicyEnabled": "Enabled",
                "natPolicyReflexive": "Reflexive",
                "natPolicyDnsDoctorEnable": "DNS Doctoring"
            },
            "Routing Policies": {
                "_array": "pbrObjId",
                "pbrPolicyName": "Name",
                "pbrObjSrc": "Source",
                "pbrObjDst": "Destination",
                "pbrObjSvc": "Service",
                "pbrObjGw": "Gateway",
                "pbrObjIfaceName": "Interface",
                "pbrObjMetric": "Metric",
                "pbrObjPriority": "Priority",
                "pbrObjProbe": "Probe",
                "pbrObjDisableOnProbeFail": "Disable on Fail"
            },
            "Security Services": {
                "GAV": {
                    "gavEnableScanning": "Enable GAV Scanning",
                    "gavEnableInbound": "Enable Inbound",
                    "gavEnableOutbound": "Enable Outbound"
                },
                "IPS": {
                    "isIDPEnabled": "Enable IPS",
                    "idpPreventHighPriority": "Prevent High Pri",
                    "idpDetectHighPriority": "Detect High Pri",
                    "idpPreventMediumPriority": "Prevent Med Pri",
                    "idpDetectMediumPriority": "Detect Med Pri"
                },
                "Geo-IP": {
                    "geoIpBlkMode": "Block Mode",
                    "geoIpLoggingEnabled": "Logging Enabled",
                    "geoEnforcement": "Enable Enforcement",
                    "blockUnknownGeo": "Block Unknown"
                },
                "Botnet": {
                    "botnetBlock": "Block Botnet",
                    "botnetLoggingEnabled": "Logging Enabled"
                },
                "AS": {
                    "asEnableScanning": "Enable Anti-Spyware",
                    "asEnableInbound": "Enable Inbound",
                    "asEnableOutbound": "Enable Outbound"
                }
            },
            "DNS": {
                "dns_server_one": "DNS Server 1",
                "dns_server_two": "DNS Server 2",
                "dns_server_three": "DNS Server 3",
                "dns_use_static_servers": "Use Static DNS"
            },
            "Address Objects": {
                "_array": "addrObjId",
                "addrObjId": "Name",
                "addrObjIdDisp": "Display Name",
                "addrObjType": "Type",
                "addrObjIp1": "IP/Start",
                "addrObjIp2": "Mask/End",
                "addrObjZone": "Zone"
            },
            "DHCP": {
                "Settings": {
                    "enableDHCP": "Enable DHCP Server"
                },
                "Static Scopes": {
                    "_array": "prefs_dhstaticip",
                    "prefs_dhstaticscopeactive": "Enabled",
                    "prefs_dhstaticname": "Name",
                    "prefs_dhstaticip": "IP Address",
                    "prefs_dhstatichw": "MAC Address",
                    "prefs_dhstaticsubnetmask": "Subnet Mask",
                    "prefs_dhstaticrouter": "Gateway",
                    "prefs_dhstaticdns0": "DNS 1"
                },
                "Dynamic Scopes": {
                    "_array": "prefs_dhdynstart",
                    "prefs_dhdynscopeactive": "Enabled",
                    "prefs_dhdynstart": "Range Start",
                    "prefs_dhdynend": "Range End",
                    "prefs_dhdynrouter": "Gateway",
                    "prefs_dhdynsubnetmask": "Subnet Mask",
                    "prefs_dhdynlease": "Lease (min)",
                    "prefs_dhdyndns0": "DNS 1",
                    "prefs_dhdyndns1": "DNS 2",
                    "prefs_dhdynComment": "Comment"
                }
            }
        };

        const ZONE_TYPE_MAP = {
            "1": "Trusted", "0": "Untrusted", "2": "Public", "5": "Encrypted", "8": "SSL VPN", "4": "Wireless", "6": "Untrusted"
        };
        const ACTION_MAP = {
            "2": "ALLOW", "0": "DENY", "1": "DISCARD"
        };
        const ANY_INTERFACE_ID = "4294967295";
        const ANY_VALUE = "Any";

        const ADDRESS_OBJ_TYPE_MAP = {
            "1": "Host", "2": "Range", "4": "Network", "8": "Group", "9": "MAC", "10": "FQDN", "0": "Host"
        };

        let PARSED_DATA = {};

        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');

        if (fileInput) {
            fileInput.addEventListener('change', handleFileSelect);
        }

        // --- Paste Modal Logic ---
        function togglePasteModal() {
            const modal = document.getElementById('pasteModal');
            modal.classList.toggle('hidden');
            if (!modal.classList.contains('hidden')) {
                document.getElementById('pasteArea').focus();
            }
        }

        function processPaste() {
            const text = document.getElementById('pasteArea').value;
            if (text && text.trim().length > 0) {
                fileNameDisplay.textContent = "Pasted Configuration";
                fileNameDisplay.classList.remove('italic', 'text-obsidian-textMuted');
                fileNameDisplay.classList.add('font-semibold', 'text-white');
                parseConfig(text);
                togglePasteModal();
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                fileNameDisplay.textContent = file.name;
                fileNameDisplay.classList.remove('italic', 'text-obsidian-textMuted');
                fileNameDisplay.classList.add('font-semibold', 'text-white');

                const reader = new FileReader();
                reader.onload = function (e) {
                    const text = e.target.result;
                    parseConfig(text);
                };
                reader.readAsText(file);
            } else {
                clearInput();
            }
        }

        function clearInput() {
            fileInput.value = '';
            fileNameDisplay.textContent = 'No file chosen';
            fileNameDisplay.classList.add('italic', 'text-obsidian-textMuted');
            fileNameDisplay.classList.remove('font-semibold', 'text-white');

            document.getElementById('resultsArea').classList.add('hidden');
            document.getElementById('emptyState').classList.remove('hidden');
            PARSED_DATA = {};
        }

        function parseConfig(configText) {
            const interfaceMap = buildInterfaceMap(configText);
            const addressObjectMap = buildAddressObjectMap(configText);
            const groupMemberMap = buildAddressGroupMemberMap(configText);
            PARSED_DATA = parseConfigText(configText, interfaceMap, addressObjectMap, groupMemberMap);
            renderTabs(PARSED_DATA);

            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('emptyState').classList.add('hidden');
        }

        function buildInterfaceMap(text) {
            const map = {};
            const lines = text.split('\n');
            const ifNumRegex = /^iface_ifnum_(\d+)=(\d+)/;
            const ifNameRegex = /^iface_name_(\d+)=(.*)/;

            const temp = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match = trimmed.match(ifNumRegex);
                if (match) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].id = match[2];
                    continue;
                }
                match = trimmed.match(ifNameRegex);
                if (match) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].name = decodeURIComponent(match[2]);
                }
            }

            Object.values(temp).forEach(obj => {
                if (obj.id && obj.name) {
                    map[obj.id] = obj.name;
                }
            });

            map["-1"] = "Any";
            map[ANY_INTERFACE_ID] = "Any";

            return map;
        }

        function buildAddressObjectMap(text) {
            const map = {};
            // Basic regex for Address Objects: addrObjId_XX (Name), addrObjIp1_XX (IP)
            // We want to map: Name -> IP String
            const lines = text.split('\n');
            const idRegex = /^addrObjId_(\d+)=(.*)/;
            const ip1Regex = /^addrObjIp1_(\d+)=(.*)/;
            const ip2Regex = /^addrObjIp2_(\d+)=(.*)/;
            const typeRegex = /^addrObjType_(\d+)=(.*)/;

            // FQDN Objects: addrObjFqdnId_XX, addrObjFqdn_XX
            const fqdnIdRegex = /^addrObjFqdnId_(\d+)=(.*)/;
            const fqdnValRegex = /^addrObjFqdn_(\d+)=(.*)/;

            const temp = {};
            const tempFqdn = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match;

                // Standard Address Objects
                if ((match = trimmed.match(idRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].name = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(ip1Regex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].ip1 = match[2];
                } else if ((match = trimmed.match(ip2Regex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].ip2 = match[2];
                } else if ((match = trimmed.match(typeRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].type = match[2]; // 1=Host, 2=Range, 4=Network
                }
                // FQDN Objects
                else if ((match = trimmed.match(fqdnIdRegex))) {
                    const idx = match[1];
                    if (!tempFqdn[idx]) tempFqdn[idx] = {};
                    tempFqdn[idx].name = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(fqdnValRegex))) {
                    const idx = match[1];
                    if (!tempFqdn[idx]) tempFqdn[idx] = {};
                    tempFqdn[idx].fqdn = match[2];
                }
            }

            // Process Standard Objects
            Object.values(temp).forEach(obj => {
                if (obj.name) {
                    let desc = "";
                    const typeName = ADDRESS_OBJ_TYPE_MAP[obj.type] || `Type ${obj.type}`;

                    // We only use this map for the tooltip/enrichment text usually, 
                    // but for the "Address Objects" tab we want the actual type name.
                    // The 'map' returned here is Name -> Description (IP/subnet).
                    // Wait, this function returns a map for ENRICHMENT (Name -> Value).
                    // The extraction for the TABLE happens in parseGenericArray using the raw lines.
                    // Actually, looking at CONFIG_MAP["Address Objects"], it maps "addrObjType" to "Type".
                    // So parseGenericArray extracts the raw number.
                    // I need to update parseGenericArray to use ADDRESS_OBJ_TYPE_MAP for 'addrObjType'.

                    if (obj.type === "8") {
                        desc = "Group";
                    } else if (obj.ip1) {
                        desc = obj.ip1;
                        if (obj.type === "4" && obj.ip2 && obj.ip2 !== "0.0.0.0") {
                            desc = `${obj.ip1}/${obj.ip2}`; // Net/Mask
                        } else if (obj.type === "2" && obj.ip2 && obj.ip2 !== "0.0.0.0") {
                            desc = `${obj.ip1}-${obj.ip2}`; // Range
                        }
                    }
                    if (desc) map[obj.name] = desc;
                }
            });

            // Process FQDN Objects
            Object.values(tempFqdn).forEach(obj => {
                if (obj.name && obj.fqdn) {
                    map[obj.name] = obj.fqdn;
                }
            });

            return map;
        }

        function buildAddressGroupMemberMap(text) {
            const map = {}; // GroupName -> [MemberName1, MemberName2]
            const lines = text.split('\n');
            // addro_atomToGrp_XX=Member
            // addro_grpToGrp_XX=Group
            const atomRegex = /^addro_atomToGrp_(\d+)=(.*)/;
            const grpRegex = /^addro_grpToGrp_(\d+)=(.*)/;

            const temp = {};

            for (const line of lines) {
                const trimmed = line.trim();
                let match;

                if ((match = trimmed.match(atomRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].atom = decodeURIComponent(match[2]);
                } else if ((match = trimmed.match(grpRegex))) {
                    const idx = match[1];
                    if (!temp[idx]) temp[idx] = {};
                    temp[idx].grp = decodeURIComponent(match[2]);
                }
            }

            Object.values(temp).forEach(item => {
                if (item.atom && item.grp) {
                    if (!map[item.grp]) map[item.grp] = [];
                    map[item.grp].push(item.atom);
                }
            });

            return map;
        }

        function parseConfigText(configText, interfaceMap, addressObjectMap, groupMemberMap) {
            const results = {};
            const lines = configText.split('\n');

            for (const [sectionName, sectionMap] of Object.entries(CONFIG_MAP)) {

                const firstKey = Object.keys(sectionMap)[0];
                if (typeof sectionMap[firstKey] === 'object' && sectionMap[firstKey] !== null) {
                    results[sectionName] = {};
                    for (const [subSectionName, subMap] of Object.entries(sectionMap)) {
                        if (subMap._array) {
                            results[sectionName][subSectionName] = parseGenericArray(lines, subMap, interfaceMap, addressObjectMap);
                        } else {
                            results[sectionName][subSectionName] = parseGenericKV(lines, subMap);
                        }
                    }
                }
                else {
                    if (sectionMap._array) {
                        let parsedArray = parseGenericArray(lines, sectionMap, interfaceMap, addressObjectMap);
                        if (sectionName === "Interfaces") {
                            parsedArray.sort((a, b) => {
                                const nameA = a["Name"] || "";
                                const nameB = b["Name"] || "";
                                return nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
                            });
                        }
                        // Enrich Address Groups
                        if (sectionName === "Address Objects" && groupMemberMap) {
                            parsedArray.forEach(obj => {
                                if (obj["Name"] && groupMemberMap[obj["Name"]]) {
                                    obj["Members"] = groupMemberMap[obj["Name"]];
                                }
                            });
                        }
                        results[sectionName] = parsedArray;
                    } else {
                        results[sectionName] = parseGenericKV(lines, sectionMap);
                    }
                }
            }
            return results;
        }

        function parseGenericKV(lines, map) {
            const result = {};
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                for (const [key, label] of Object.entries(map)) {
                    if (trimmed.startsWith(key + '=')) {
                        let value = trimmed.substring(key.length + 1);
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (key === 'dns_use_static_servers') {
                            if (value === '1' || value.toLowerCase() === 'on') value = 'True';
                            else if (value === '0' || value.toLowerCase() === 'off') value = 'False';
                        }

                        result[label] = value;
                        break;
                    }
                }
            }
            return result;
        }

        function parseGenericArray(lines, map, interfaceMap, addressObjectMap) {
            const result = [];
            const tempMap = {};

            for (const line of lines) {
                const trimmed = line.trim();
                for (const [key, label] of Object.entries(map)) {
                    if (key === '_array') continue;

                    const regex = new RegExp(`^${key}_(\\d+)=(.*)`);
                    const match = trimmed.match(regex);

                    if (match) {
                        const index = match[1];
                        let value = match[2];
                        try { value = decodeURIComponent(value); } catch (e) { }
                        value = value.trim();

                        if (!tempMap[index]) tempMap[index] = {};

                        if (key === 'zoneObjZoneType') value = ZONE_TYPE_MAP[value] || value;
                        if (key === 'addrObjType') value = ADDRESS_OBJ_TYPE_MAP[value] || value;
                        if (key === 'policyAction') value = ACTION_MAP[value] || value;
                        if (key === 'policySrcIf' || key === 'policyDstIf' ||
                            key === 'natPolicySrcIface' || key === 'natPolicyDstIface') {
                            value = interfaceMap[value] || value;
                        }

                        if ((key === 'policySrcNet' || key === 'policyDstNet' ||
                            key === 'policySrcSvc' || key === 'policyDstSvc' ||
                            key === 'natPolicyOrigSrc' || key === 'natPolicyOrigDst' ||
                            key === 'natPolicyOrigSvc' || key === 'natPolicyTransSrc' ||
                            key === 'natPolicyTransDst' || key === 'natPolicyTransSvc'
                        ) && value === "") {
                            value = ANY_VALUE;
                        }

                        // Enrich Address Object names with IP/FQDN
                        if ((key === 'policySrcNet' || key === 'policyDstNet' ||
                            key === 'natPolicyOrigSrc' || key === 'natPolicyOrigDst' ||
                            key === 'natPolicyTransSrc' || key === 'natPolicyTransDst' ||
                            key === 'pbrObjSrc' || key === 'pbrObjDst'
                        ) && value !== ANY_VALUE) {
                            if (addressObjectMap && addressObjectMap[value]) {
                                value = `${value} <span class="text-obsidian-textMuted text-xs">(${addressObjectMap[value]})</span>`;
                            }
                        }

                        tempMap[index][label] = value;
                        break;
                    }
                }
            }
            return Object.values(tempMap);
        }

        // --- Rendering ---

        function renderTabs(data) {
            const tabsHeader = document.getElementById('tabsHeader');
            const tabsContent = document.getElementById('tabsContent');

            tabsHeader.innerHTML = '';
            tabsContent.innerHTML = '';

            let first = true;
            for (const [sectionName, sectionData] of Object.entries(data)) {
                if (sectionName === 'CLI') continue;

                const tabId = sectionName.replace(/\s+/g, '-').toLowerCase();

                // Create Button
                const btn = document.createElement('button');
                btn.className = `tab-btn group inline-flex items-center px-4 py-4 border-b-2 font-medium text-sm mr-4 whitespace-nowrap transition-colors ${first ? 'border-obsidian-accent text-obsidian-accent active' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text hover:border-obsidian-border'
                    }`;
                btn.innerText = sectionName;
                btn.onclick = () => switchTab(tabId);
                tabsHeader.appendChild(btn);

                // Create Content
                const contentDiv = document.createElement('div');
                contentDiv.id = tabId;
                contentDiv.className = `tab-content ${first ? 'active' : ''} space-y-6`;

                const isNested = !Array.isArray(sectionData) && Object.values(sectionData).some(v => typeof v === 'object');

                if (isNested) {
                    renderNestedSection(contentDiv, sectionData);
                } else if (sectionName === "Address Objects" && Array.isArray(sectionData)) {
                    renderAddressObjectsTabs(contentDiv, sectionData);
                } else if (Array.isArray(sectionData)) {
                    renderArrayTable(contentDiv, sectionData);
                } else {
                    renderKVTable(contentDiv, sectionData);
                }

                tabsContent.appendChild(contentDiv);
                first = false;
            }
        }

        function renderAddressObjectsTabs(container, data) {
            // Segregate Data
            const hosts = [], networks = [], ranges = [], groups = [];

            data.forEach(item => {
                // Determine type based on properties or explicit type if available
                // We mapped Type in buildAddressObjectMap, but here we have the PARSED/ENRICHED object.
                // The 'Type' key might not be in the final array if not key-mapped.
                // However, we can infer from keys or if we preserved 'Type'.
                // Let's rely on our inference or the 'Members' field.

                if (item.Members) {
                    groups.push(item);
                } else if (item["Name"] && item["Name"].includes && (item["Name"].includes("/") || item["Name"].includes("-"))) {
                    // Weak inference if no type. 
                    // Better: check keys. Networks have Net/Mask or similar? 
                    // Actually, parseGenericArray uses CONFIG_MAP. 
                    // Address Objects map has: addrObjId (Name), addrObjType (Type), addrObjIp1 (IP/Start), addrObjIp2 (End/Mask)
                    // So 'Type' should be there if we mapped it.
                    // I didn't verify if 'addrObjType' is in CONFIG_MAP.
                    // It IS: "Type": "addrObjType".
                    // So we can use item["Type"].
                }

                const type = item["Type"];
                if (type === "Group" || item.Members) groups.push(item);
                else if (type === "Network" || type === "4") networks.push(item);
                else if (type === "Range" || type === "2") ranges.push(item);
                else {
                    if (!item["Mask/End"] || item["Mask/End"] === "0.0.0.0") item["Mask/End"] = "255.255.255.255";
                    hosts.push(item); // Default to Host (1)
                }
            });

            // Render Sub-Tabs Header
            const subNav = document.createElement('div');
            subNav.className = "flex space-x-2 mb-4 border-b border-obsidian-border";

            const subContent = document.createElement('div');

            const categories = [
                { name: "Hosts", data: hosts },
                { name: "Networks", data: networks },
                { name: "Ranges", data: ranges },
                { name: "Groups", data: groups }
            ];

            categories.forEach((cat, idx) => {
                const btn = document.createElement('button');
                btn.className = `px-3 py-2 text-sm font-medium transition-colors border-b-2 ${idx === 0 ? 'border-obsidian-accent text-obsidian-accent' : 'border-transparent text-obsidian-textMuted hover:text-obsidian-text'}`;
                btn.innerText = `${cat.name} (${cat.data.length})`;
                btn.onclick = (e) => {
                    // Reset all
                    subNav.querySelectorAll('button').forEach(b => {
                        b.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-transparent text-obsidian-textMuted hover:text-obsidian-text";
                    });
                    // Active this
                    e.target.className = "px-3 py-2 text-sm font-medium transition-colors border-b-2 border-obsidian-accent text-obsidian-accent";

                    // Render content
                    subContent.innerHTML = '';
                    if (cat.name === "Groups") {
                        renderArrayTable(subContent, cat.data, ["IP/Start", "Mask/End", "Zone", "Type"]);
                    } else {
                        renderArrayTable(subContent, cat.data);
                    }
                };
                subNav.appendChild(btn);
            });

            container.appendChild(subNav);
            container.appendChild(subContent);

            // Initial Render (Hosts)
            renderArrayTable(subContent, hosts);
        }

        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => {
                el.classList.remove('border-obsidian-accent', 'text-obsidian-accent', 'active');
                el.classList.add('border-transparent', 'text-obsidian-textMuted');
            });

            document.getElementById(tabId).classList.add('active');

            const buttons = document.querySelectorAll('.tab-btn');
            for (const btn of buttons) {
                if (btn.innerText.replace(/\s+/g, '-').toLowerCase() === tabId) {
                    btn.classList.add('border-obsidian-accent', 'text-obsidian-accent', 'active');
                    btn.classList.remove('border-transparent', 'text-obsidian-textMuted');
                }
            }
        }

        function renderNestedSection(container, data) {
            for (const [subTitle, subData] of Object.entries(data)) {
                const h3 = document.createElement('h3');
                h3.className = "text-lg font-medium leading-6 text-white mb-2 pb-1 border-b border-obsidian-border";
                h3.innerText = subTitle;
                container.appendChild(h3);

                const subContainer = document.createElement('div');
                subContainer.className = "mb-8";
                if (Array.isArray(subData)) {
                    renderArrayTable(subContainer, subData);
                } else {
                    renderKVTable(subContainer, subData);
                }
                container.appendChild(subContainer);
            }
        }

        function renderKVTable(container, data) {
            if (Object.keys(data).length === 0) {
                container.innerHTML += '<p class="text-obsidian-textMuted text-sm italic">No data found.</p>';
                return;
            }
            const table = document.createElement('table');
            table.className = "min-w-full divide-y divide-obsidian-border";
            const tbody = document.createElement('tbody');
            tbody.className = "divide-y divide-obsidian-border";

            for (const [key, value] of Object.entries(data)) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="px-6 py-3 whitespace-nowrap text-sm font-medium text-obsidian-text w-1/3">${key}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-obsidian-textMuted font-mono">${renderValue(value)}</td>
                `;
                tbody.appendChild(tr);
            }
            table.appendChild(tbody);

            const shadowWrapper = document.createElement('div');
            shadowWrapper.className = "shadow ring-1 ring-obsidian-border rounded-lg overflow-hidden bg-obsidian-bg";
            shadowWrapper.appendChild(table);
            container.appendChild(shadowWrapper);
        }

        function renderArrayTable(container, data, excludeColumns = []) {
            if (!data || data.length === 0) {
                container.innerHTML = '<p class="text-obsidian-textMuted text-sm italic">No items found.</p>';
                return;
            }

            const columns = new Set();
            data.forEach(item => Object.keys(item).forEach(k => columns.add(k)));
            let colArray = Array.from(columns);

            const priorityCols = ["Name", "Action", "Zone Type", "IP Address", "Source Zone"];
            colArray.sort((a, b) => {
                const idxA = priorityCols.indexOf(a);
                const idxB = priorityCols.indexOf(b);
                if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                if (idxA !== -1) return -1;
                if (idxB !== -1) return 1;
                return a.localeCompare(b);
            });

            colArray = colArray.filter(col => {
                if (excludeColumns.includes(col)) return false;
                return data.some(row => row[col] && row[col] !== "");
            });

            const wrapper = document.createElement('div');
            wrapper.className = "shadow ring-1 ring-obsidian-border rounded-lg overflow-hidden bg-obsidian-bg";
            const scrollContainer = document.createElement('div');
            scrollContainer.className = "overflow-x-auto table-container";

            const table = document.createElement('table');
            table.className = "min-w-full divide-y divide-obsidian-border";

            const thead = document.createElement('thead');
            thead.className = "bg-obsidian-pane";
            let thHtml = '<tr>';
            colArray.forEach(col => {
                thHtml += `<th scope="col" class="px-4 py-3 text-left text-xs font-semibold text-white uppercase tracking-wider whitespace-nowrap">${col}</th>`;
            });
            thHtml += '</tr>';
            thead.innerHTML = thHtml;
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            tbody.className = "divide-y divide-obsidian-border";

            data.forEach((item, idx) => {
                const tr = document.createElement('tr');
                tr.className = idx % 2 === 0 ? 'bg-transparent' : 'bg-[#2a2a2c]'; // Subtle zebra striping
                tr.className += ' hover:bg-[#323234] transition-colors';

                let tdHtml = '';
                colArray.forEach(col => {
                    let val = item[col] || "";

                    let cellClass = "px-4 py-3 text-sm text-obsidian-text whitespace-nowrap";
                    let content = renderValue(val);

                    if (col === "Name" && val.includes(":")) {
                        content = `<span class="ml-4 border-l-2 border-obsidian-border pl-2 text-obsidian-textMuted">${content}</span>`;
                    }

                    tdHtml += `<td class="${cellClass}">${content}</td>`;
                });
                tr.innerHTML = tdHtml;
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);

            scrollContainer.appendChild(table);
            wrapper.appendChild(scrollContainer);
            container.appendChild(wrapper);
        }

        function renderValue(val) {
            if (Array.isArray(val)) {
                return val.map(v => `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-obsidian-pane border border-obsidian-border text-obsidian-text mr-1 mb-1">${v}</span>`).join('');
            }
            if (val === "1" || val.toLowerCase() === "on" || val === "True") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">Yes</span>';
            }
            if (val === "0" || val.toLowerCase() === "off" || val === "False") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">No</span>';
            }
            if (val === "ALLOW") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-900/30 text-green-400 border border-green-800">ALLOW</span>';
            }
            if (val === "DENY") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-900/30 text-red-400 border border-red-800">DENY</span>';
            }
            if (val === "DISCARD" || val === "DROP") {
                return '<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-orange-900/30 text-orange-400 border border-orange-800">DISCARD</span>';
            }
            if (val === ANY_VALUE) {
                return '<span class="italic text-obsidian-textMuted">Any</span>';
            }
            return val;
        }

        function copyToClipboard() {
            if (Object.keys(PARSED_DATA).length === 0) return;
            const json = JSON.stringify(PARSED_DATA, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                // Could be replaced with a nicer toast if desired, but alert is fine for now
                alert('Parsed JSON copied to clipboard!');
            });
        }
    </script>
</body>

</html>