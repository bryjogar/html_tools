<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switch Designer v21 (Homelab Playground)</title>
    <link rel="icon" type="image/png" href="https://homelabplayground.com/favicon.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        obsidian: {
                            bg: '#1e1e1e',
                            pane: '#252526',
                            border: '#3c3c3c',
                            accent: '#7c3aed',
                            text: '#cccccc'
                        }
                    },
                    fontFamily: {
                        mono: ['"Fira Code"', 'Consolas', 'Monaco', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #3c3c3c; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        /* Prevent text selection during drag */
        body { user-select: none; -webkit-user-select: none; }
        .rj45-port, .sfp-port { user-select: none; -webkit-user-select: none; }

        /* RJ45 Port Styling */
        .rj45-port {
            position: relative;
            background-color: #0d0d0d;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.9);
            transition: all 0.2s;
            cursor: pointer;
        }
        .rj45-port::after {
            content: '';
            position: absolute;
            bottom: 0; left: 50%; transform: translateX(-50%);
            width: 60%; height: 4px;
            background: repeating-linear-gradient(90deg, #b8860b, #b8860b 2px, #000 2px, #000 4px);
            opacity: 0.6; pointer-events: none; z-index: 5;
        }

        /* SFP Port Styling */
        .sfp-port {
            position: relative;
            background-color: #1a1a1a;
            box-shadow: inset 0 0 5px rgba(0,0,0,1);
            border: 1px solid #444;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .sfp-port::before {
            content: '';
            width: 40%; height: 4px;
            background: #333; border-radius: 2px;
        }

        /* Input Styling */
        .port-label-input:focus { outline: none; background: #3c3c3c; color: white; }

        /* Tag Pips */
        .tag-container {
            position: absolute; bottom: 2px; left: 2px; right: 2px;
            display: flex; gap: 2px; justify-content: center;
            z-index: 10; pointer-events: none;
        }
        .tag-pip {
            height: 4px; flex: 1; border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.8);
            border: 0.5px solid rgba(255,255,255,0.2);
        }

        /* Badges */
        .lag-badge {
            position: absolute; top: 2px; right: 2px;
            background: #2563eb; color: white;
            font-size: 8px; font-weight: bold;
            padding: 1px 3px; border-radius: 2px;
            z-index: 20; box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .shield-badge {
            position: absolute; top: 2px; left: 2px;
            color: #ec4899; 
            font-size: 9px;
            z-index: 20; 
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.8));
        }

        /* Print/Export */
        @media print {
            body * { visibility: hidden; }
            #export-area, #export-area * { visibility: visible; }
            #export-area { position: absolute; left: 0; top: 0; width: 100%; background: white !important; color: black !important; padding: 20px; }
            .rj45-port, .sfp-port { border: 1px solid #ccc; }
        }
    </style>
</head>
<body class="flex flex-col h-screen overflow-hidden bg-obsidian-bg text-obsidian-text font-sans">

    <header class="h-14 bg-obsidian-pane border-b border-obsidian-border flex items-center justify-between px-4 shrink-0 z-20">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-network-wired text-obsidian-accent text-xl"></i>
            <h1 class="font-bold text-lg tracking-wide text-gray-200 hidden md:block">Switch Designer <span class="text-obsidian-accent font-light">v23</span></h1>
        </div>
        <div class="flex items-center gap-2">
            <button onclick="cycleSwitchSize()" id="size-btn" class="text-xs bg-obsidian-border hover:bg-white/10 text-white px-3 py-1.5 rounded transition font-mono border border-transparent hover:border-gray-500">
                Size: 24 Ports
            </button>
            <button onclick="openSettingsModal()" class="text-xs bg-obsidian-pane hover:bg-white/10 text-gray-300 border border-obsidian-border px-3 py-1.5 rounded transition">
                <i class="fa-solid fa-gear"></i> Settings
            </button>
            <button onclick="openExportModal()" class="text-xs bg-obsidian-accent hover:bg-violet-600 text-white px-3 py-1.5 rounded transition shadow-lg shadow-violet-900/20">
                <i class="fa-solid fa-camera mr-1"></i> PNG
            </button>
        </div>
    </header>

    <div class="flex-1 flex flex-col md:flex-row overflow-hidden">
        
        <aside class="w-full md:w-80 bg-obsidian-pane border-b md:border-b-0 md:border-r border-obsidian-border flex flex-col shrink-0 overflow-y-auto z-10">
            
            <div class="p-4 border-b border-obsidian-border bg-black/10">
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <button onclick="downloadJson()" class="bg-obsidian-bg hover:bg-white/5 border border-obsidian-border text-gray-300 text-xs py-2 rounded flex items-center justify-center gap-2 transition">
                        <i class="fa-solid fa-download text-green-500"></i> Save JSON
                    </button>
                    <button onclick="triggerImport()" class="bg-obsidian-bg hover:bg-white/5 border border-obsidian-border text-gray-300 text-xs py-2 rounded flex items-center justify-center gap-2 transition">
                        <i class="fa-solid fa-upload text-blue-500"></i> Load JSON
                    </button>
                    <input type="file" id="json-input" class="hidden" accept=".json" onchange="importJson(this)">
                </div>
                
                <div class="grid grid-cols-1 gap-2">
                    <button onclick="openImporterModal()" class="bg-slate-700 hover:bg-slate-600 text-white border border-slate-600 text-xs py-2 rounded flex items-center justify-center gap-2 transition shadow-lg">
                        <i class="fa-solid fa-file-import text-yellow-400"></i> Import Running-Config
                    </button>
                    <button onclick="openCliModal()" class="bg-slate-800 hover:bg-slate-700 text-blue-400 border border-slate-700 text-xs py-2 rounded flex items-center justify-center gap-2 transition shadow-lg">
                        <i class="fa-solid fa-terminal"></i> Generate Full Config
                    </button>
                </div>
            </div>

            <div class="p-4 border-b border-obsidian-border">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-xs font-bold uppercase text-gray-500 tracking-wider">VLANs</h2>
                    <span class="text-[10px] text-gray-600 cursor-pointer hover:text-white" onclick="resetVlans()">Reset</span>
                </div>
                
                <div id="vlan-properties" class="bg-black/20 p-2 rounded border border-obsidian-border mb-3 hidden">
                    <div class="flex justify-between items-center mb-2 border-b border-white/5 pb-1">
                         <span id="prop-vlan-title" class="text-xs font-bold text-white">VLAN Details</span>
                         <button onclick="saveVlanProps()" class="text-[10px] bg-green-900/50 text-green-400 px-2 rounded border border-green-800">Save</button>
                    </div>
                    <div class="space-y-2">
                        <div class="flex gap-2">
                            <input id="prop-vlan-name" placeholder="Name" class="w-full bg-obsidian-pane border border-obsidian-border text-[10px] text-white px-1 py-1 rounded">
                            <input id="prop-vlan-vid" type="number" placeholder="VLAN ID" min="1" max="4094" class="w-20 bg-obsidian-pane border border-obsidian-border text-[10px] text-white px-1 py-1 rounded font-mono">
                            <input id="prop-vlan-ip" placeholder="L3 IP (10.0.0.1/24)" class="w-full bg-obsidian-pane border border-obsidian-border text-[10px] text-white px-1 py-1 rounded">
                        </div>
                        <div class="flex gap-2 items-center">
                            <label class="text-[10px] text-gray-400 whitespace-nowrap">Color:</label>
                            <input id="prop-vlan-color" type="color" value="#64748b" class="w-full h-6 bg-obsidian-pane border border-obsidian-border rounded cursor-pointer">
                        </div>
                        <div class="flex gap-2 items-center justify-between">
                            <label class="flex items-center gap-1 text-[10px] text-gray-400 cursor-pointer">
                                <input type="checkbox" id="prop-vlan-igmp" class="rounded bg-obsidian-pane border-obsidian-border"> IGMP Snoop
                            </label>
                            <select id="prop-vlan-qos" class="bg-obsidian-pane border border-obsidian-border text-[10px] text-gray-300 rounded px-1 py-0.5">
                                <option value="">No QoS</option>
                                <option value="voice">Voice</option>
                                <option value="video">Video</option>
                                <option value="critical">Critical</option>
                            </select>
                        </div>
                        <div class="flex gap-2 items-center">
                            <label class="flex items-center gap-1 text-[10px] text-gray-400 cursor-pointer">
                                <input type="checkbox" id="prop-vlan-voice" class="rounded bg-obsidian-pane border-obsidian-border"> Voice VLAN
                            </label>
                        </div>
                        <div class="border-t border-white/5 pt-2 mt-2">
                            <label class="text-[10px] text-gray-400 block mb-1">Spanning Tree Protocol</label>
                            <div class="space-y-1">
                                <select id="prop-vlan-stp-mode" class="w-full bg-obsidian-pane border border-obsidian-border text-[10px] text-gray-300 rounded px-1 py-1">
                                    <option value="">Disabled</option>
                                    <option value="stp">STP (802.1D)</option>
                                    <option value="rstp">RSTP (802.1w)</option>
                                    <option value="mstp">MSTP (802.1s)</option>
                                    <option value="rapid-pvst">Rapid-PVST</option>
                                    <option value="pvst">PVST+</option>
                                </select>
                                <input id="prop-vlan-stp-priority" type="number" placeholder="STP Priority" class="w-full bg-obsidian-pane border border-obsidian-border text-[10px] text-white px-1 py-1 rounded">
                            </div>
                        </div>
                    </div>
                </div>
                <div id="lag-properties" class="bg-black/20 p-2 rounded border border-obsidian-border mb-3 hidden">
                    <div class="flex justify-between items-center mb-2 border-b border-white/5 pb-1">
                         <span id="prop-lag-title" class="text-xs font-bold text-white">LAG Details</span>
                         <button onclick="saveLagProps()" class="text-[10px] bg-green-900/50 text-green-400 px-2 rounded border border-green-800">Save</button>
                    </div>
                    <div class="space-y-2">
                        <div class="flex gap-2">
                            <input id="prop-lag-name" placeholder="Name" class="w-full bg-obsidian-pane border border-obsidian-border text-[10px] text-white px-1 py-1 rounded">
                            <input id="prop-lag-stp-priority" type="number" placeholder="STP Priority" class="w-full bg-obsidian-pane border border-obsidian-border text-[10px] text-white px-1 py-1 rounded">
                        </div>
                        <div class="flex gap-2 items-center justify-between">
                            <label class="flex items-center gap-1 text-[10px] text-gray-400 cursor-pointer">
                                <input type="checkbox" id="prop-lag-uplink" onchange="toggleLagNativeVlan()" class="rounded bg-obsidian-pane border-obsidian-border"> Uplink (untag native, tag all others)
                            </label>
                        </div>
                        <div id="prop-lag-native-vlan-container" class="hidden">
                            <label class="text-[10px] text-gray-400 block mb-1">Native VLAN (untagged)</label>
                            <select id="prop-lag-native-vlan" class="w-full bg-obsidian-pane border border-obsidian-border text-[10px] text-white px-1 py-1 rounded">
                                <option value="">Select VLAN...</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="vlan-list" class="space-y-1 mb-2 max-h-32 overflow-y-auto"></div>
                
                <div class="flex gap-2 items-center bg-obsidian-bg p-2 rounded border border-obsidian-border">
                    <input type="color" id="new-vlan-color" value="#10b981" class="bg-transparent border-none h-5 w-6 cursor-pointer p-0">
                    <input type="text" id="new-vlan-name" placeholder="New VLAN..." class="bg-transparent border-none text-xs text-white w-full focus:outline-none font-mono">
                    <input type="number" id="new-vlan-vid" placeholder="ID" min="1" max="4094" class="bg-transparent border border-obsidian-border text-xs text-white w-16 px-1 py-0.5 rounded font-mono focus:outline-none">
                    <button onclick="addVlan()" class="text-obsidian-accent hover:text-white px-2"><i class="fa-solid fa-plus"></i></button>
                </div>
            </div>

            <div class="p-4 border-b border-obsidian-border">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-xs font-bold uppercase text-gray-500 tracking-wider">Link Aggregation</h2>
                    <span class="text-[10px] text-gray-600 cursor-pointer hover:text-white" onclick="resetLags()">Reset</span>
                </div>
                <div id="lag-list" class="space-y-1 mb-2 max-h-32 overflow-y-auto"></div>
                <div class="flex gap-2 items-center bg-obsidian-bg p-2 rounded border border-obsidian-border">
                    <select id="new-lag-type" class="bg-obsidian-pane text-[10px] text-white border border-obsidian-border rounded px-1">
                        <option value="lacp">LACP</option>
                        <option value="static">Static</option>
                    </select>
                    <input type="text" id="new-lag-name" placeholder="Name..." class="bg-transparent border-none text-xs text-white w-full focus:outline-none font-mono">
                    <button onclick="addLag()" class="text-blue-400 hover:text-white px-2"><i class="fa-solid fa-plus"></i></button>
                </div>
            </div>

            <div class="p-4">
                <h2 class="text-xs font-bold uppercase text-gray-500 mb-3 tracking-wider">Tools</h2>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="setTool('paint')" id="tool-paint" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-paintbrush"></i> Native
                    </button>
                    <button onclick="setTool('tag')" id="tool-tag" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-tags"></i> Add Tag
                    </button>
                     <button onclick="setTool('lag')" id="tool-lag" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-link"></i> Assign LAG
                    </button>
                    <button onclick="setTool('poe')" id="tool-poe" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-bolt"></i> Toggle PoE
                    </button>
                    <button onclick="setTool('protect')" id="tool-protect" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-shield-halved"></i> Loop Prot.
                    </button>
                    <button onclick="setTool('bpdu')" id="tool-bpdu" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-shield"></i> Disable BPDU
                    </button>
                    <button onclick="setTool('label')" id="tool-label" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-tag"></i> Label
                    </button>
                    <button onclick="setTool('uplink')" id="tool-uplink" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-arrow-up"></i> Uplink
                    </button>
                    <button onclick="setTool('erase')" id="tool-erase" class="tool-btn col-span-2 p-2 rounded flex items-center justify-center gap-2 text-xs border border-red-900/30 text-red-400 hover:bg-red-900/20">
                        <i class="fa-solid fa-eraser"></i> Erase Port
                    </button>
                </div>
            </div>
        </aside>

        <main class="flex-1 overflow-auto bg-obsidian-bg relative flex flex-col items-center p-4 md:p-10">
            <div id="export-area" class="w-auto inline-block min-w-0">
                <div class="bg-obsidian-pane rounded-sm border border-obsidian-border shadow-2xl relative w-fit mx-auto pr-6">
                    <div class="absolute top-0 bottom-0 -left-4 w-4 bg-obsidian-bg border border-obsidian-border rounded-l flex flex-col justify-between py-2 items-center">
                        <div class="w-2 h-3 rounded-full bg-black/60 border border-gray-600"></div><div class="w-2 h-3 rounded-full bg-black/60 border border-gray-600"></div>
                    </div>
                    <div class="absolute top-0 bottom-0 -right-4 w-4 bg-obsidian-bg border border-obsidian-border rounded-r flex flex-col justify-between py-2 items-center">
                        <div class="w-2 h-3 rounded-full bg-black/60 border border-gray-600"></div><div class="w-2 h-3 rounded-full bg-black/60 border border-gray-600"></div>
                    </div>

                    <div class="p-3 md:p-5 flex flex-row items-center gap-8 whitespace-nowrap">
                        <div class="flex flex-col items-start gap-2 shrink-0 min-w-[80px]">
                            <div class="text-gray-400 font-bold font-mono tracking-widest text-sm uppercase">SW-<span id="model-label">24</span></div>
                            <div class="grid grid-cols-2 gap-x-2 gap-y-1">
                                <div class="flex items-center gap-1"><div class="w-1.5 h-1.5 rounded-full bg-green-500 shadow-[0_0_5px_#22c55e]"></div><span class="text-[9px] text-gray-500 font-mono">SYS</span></div>
                                <div class="flex items-center gap-1"><div class="w-1.5 h-1.5 rounded-full bg-green-500 shadow-[0_0_5px_#22c55e]"></div><span class="text-[9px] text-gray-500 font-mono">PWR</span></div>
                            </div>
                        </div>
                        <div id="rj45-container" class="grid gap-x-1 gap-y-5"></div>
                        <div class="flex flex-col items-center gap-1 border-l border-white/5 pl-8 ml-auto">
                            <span class="text-[9px] text-gray-500 font-mono uppercase mb-1">SFP+ Uplinks</span>
                            <div id="sfp-container" class="grid grid-cols-2 gap-2 p-1.5 bg-black/30 rounded border border-white/5"></div>
                        </div>
                    </div>
                </div>
                <div id="export-legend" class="mt-8 grid grid-cols-2 md:grid-cols-4 gap-4 hidden bg-white p-4 text-black border border-gray-300"></div>
            </div>
        </main>
    </div>

    <div id="settings-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl max-w-3xl w-full flex flex-col animate-fade-in max-h-[90vh]">
            <div class="flex justify-between items-center p-4 border-b border-obsidian-border bg-obsidian-bg">
                <h3 class="text-white font-bold"><i class="fa-solid fa-gear"></i> Switch Configuration</h3>
                <button onclick="closeSettingsModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6 space-y-6">
                <section>
                    <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Device Basics</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div><label class="text-xs text-gray-400 block mb-1">Hostname</label><input id="conf-hostname" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">Domain Name</label><input id="conf-domain-name" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="example.com"></div>
                    </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Network Configuration</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div><label class="text-xs text-gray-400 block mb-1">Default Gateway</label><input id="conf-gateway" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="192.168.1.1"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">DNS Servers (comma-separated)</label><input id="conf-dns" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="8.8.8.8, 1.1.1.1"></div>
                        <div class="md:col-span-2">
                            <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                <input type="checkbox" id="conf-ip-routing" class="rounded bg-obsidian-pane border-obsidian-border"> Enable IP Routing (L3 Mode)
                            </label>
                        </div>
                    </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Time Configuration</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Timezone</label>
                            <select id="conf-timezone" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono">
                                <option value="">Select timezone...</option>
                                <option value="us central">US Central</option>
                                <option value="us eastern">US Eastern</option>
                                <option value="us pacific">US Pacific</option>
                                <option value="us mountain">US Mountain</option>
                                <option value="gmt">GMT</option>
                                <option value="utc">UTC</option>
                                <option value="us alaska">US Alaska</option>
                                <option value="us hawaii">US Hawaii</option>
                                <option value="us arizona">US Arizona</option>
                                <option value="us indiana">US Indiana</option>
                                <option value="canada eastern">Canada Eastern</option>
                                <option value="canada central">Canada Central</option>
                                <option value="canada mountain">Canada Mountain</option>
                                <option value="canada pacific">Canada Pacific</option>
                                <option value="uk">UK (GMT/BST)</option>
                                <option value="europe central">Europe Central</option>
                                <option value="europe eastern">Europe Eastern</option>
                                <option value="europe western">Europe Western</option>
                                <option value="asia tokyo">Asia Tokyo</option>
                                <option value="asia shanghai">Asia Shanghai</option>
                                <option value="asia singapore">Asia Singapore</option>
                                <option value="australia sydney">Australia Sydney</option>
                                <option value="australia melbourne">Australia Melbourne</option>
                            </select>
                        </div>
                        <div class="md:col-span-2">
                            <div class="flex justify-between items-center mb-1">
                                <label class="text-xs text-gray-400">NTP Servers</label>
                                <button onclick="addNtpServer()" class="text-[10px] bg-green-900/30 text-green-400 border border-green-900 px-2 py-0.5 rounded hover:bg-green-900/50"><i class="fa-solid fa-plus"></i> Add</button>
                            </div>
                            <div id="ntp-servers-list" class="space-y-1">
                                <!-- NTP servers will be rendered here -->
                            </div>
                            <div class="mt-2">
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-ntp-serve" class="rounded bg-obsidian-pane border-obsidian-border"> Enable NTP Serve (allow switch to act as NTP server)
                                </label>
                            </div>
                        </div>
                        <div>
                            <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer mb-1">
                                <input type="checkbox" id="conf-sntp-unicast" class="rounded bg-obsidian-pane border-obsidian-border"> SNTP Unicast Client
                            </label>
                            <input id="conf-sntp-interval" type="number" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono mt-1" placeholder="SNTP Interval (seconds)">
                        </div>
                    </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">SNMP Configuration</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div><label class="text-xs text-gray-400 block mb-1">Location</label><input id="conf-snmp-location" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">Contact</label><input id="conf-snmp-contact" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">System Name</label><input id="conf-snmp-sysname" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">Enable VLAN</label><input id="conf-snmp-enable-vlan" type="number" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="VLAN ID"></div>
                        <div class="md:col-span-2">
                            <div class="flex justify-between items-center mb-2">
                                <label class="text-xs text-gray-400 block">SNMP Communities</label>
                                <button onclick="addSnmpCommunity()" class="text-xs bg-green-900/30 text-green-400 border border-green-900 px-2 py-1 rounded hover:bg-green-900/50"><i class="fa-solid fa-plus"></i> Add Community</button>
                            </div>
                            <div id="snmp-communities-list" class="space-y-2">
                                <!-- SNMP communities will be rendered here -->
                            </div>
                        </div>
                    </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Management Interfaces</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="text-xs text-gray-400 block mb-2">Web Management</label>
                            <div class="space-y-2">
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-web-http" class="rounded bg-obsidian-pane border-obsidian-border"> HTTP Server
                                </label>
                                <input id="conf-web-http-port" type="number" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="HTTP Port">
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-web-https" class="rounded bg-obsidian-pane border-obsidian-border"> HTTPS Server
                                </label>
                                <input id="conf-web-https-port" type="number" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="HTTPS Port">
                            </div>
                        </div>
                        <div>
                            <label class="text-xs text-gray-400 block mb-2">Remote Access</label>
                            <div class="space-y-2">
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-ssh-enabled" class="rounded bg-obsidian-pane border-obsidian-border"> SSH Server
                                </label>
                                <input id="conf-ssh-timeout" type="number" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="SSH Timeout (seconds)">
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-telnet-enabled" class="rounded bg-obsidian-pane border-obsidian-border"> Telnet Server
                                </label>
                                <input id="conf-console-timeout" type="number" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="Console Timeout (seconds)">
                            </div>
                        </div>
                    </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Layer 2 Protocols</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="text-xs text-gray-400 block mb-2">IGMP</label>
                            <div class="space-y-2">
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-igmp-enabled" class="rounded bg-obsidian-pane border-obsidian-border"> IGMP Enabled
                                </label>
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-igmp-snooping" class="rounded bg-obsidian-pane border-obsidian-border"> IGMP Snooping
                                </label>
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-igmp-querier-enabled" class="rounded bg-obsidian-pane border-obsidian-border"> IGMP Querier
                                </label>
                                <input id="conf-igmp-querier-interval" type="number" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="Query Interval (seconds)">
                            </div>
                        </div>
                        <div>
                            <label class="text-xs text-gray-400 block mb-2">Spanning Tree</label>
                            <div class="space-y-2">
                                <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                                    <input type="checkbox" id="conf-stp-enabled" class="rounded bg-obsidian-pane border-obsidian-border"> STP Enabled
                                </label>
                                <input id="conf-stp-priority" type="number" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-2 py-1 text-sm font-mono" placeholder="STP Priority">
                            </div>
                        </div>
                    </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-xs font-bold uppercase text-obsidian-accent">Routed Interfaces (Layer 3)</h4>
                        <button onclick="addRoutedInterface()" class="text-xs bg-green-900/30 text-green-400 border border-green-900 px-2 py-1 rounded hover:bg-green-900/50"><i class="fa-solid fa-plus"></i> Add Interface</button>
                    </div>
                    <div id="l3-interfaces-list" class="space-y-2">
                        </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Router Protocols</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                            <input type="checkbox" id="conf-router-rip" class="rounded bg-obsidian-pane border-obsidian-border"> RIP
                        </label>
                        <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                            <input type="checkbox" id="conf-router-ospf" class="rounded bg-obsidian-pane border-obsidian-border"> OSPF
                        </label>
                        <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                            <input type="checkbox" id="conf-router-ipv6-ospf" class="rounded bg-obsidian-pane border-obsidian-border"> IPv6 OSPF
                        </label>
                        </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-xs font-bold uppercase text-obsidian-accent">Static Routes</h4>
                        <button onclick="addStaticRoute()" class="text-xs bg-green-900/30 text-green-400 border border-green-900 px-2 py-1 rounded hover:bg-green-900/50"><i class="fa-solid fa-plus"></i> Add Route</button>
                    </div>
                    <div id="static-routes-list" class="space-y-2">
                        </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                     <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Custom Config Injection</h4>
                     <p class="text-[10px] text-gray-500 mb-2">Any text here will be appended/injected into the final generated configuration. Use generic syntax or specific commands.</p>
                     <textarea id="conf-custom" class="w-full h-32 bg-obsidian-pane text-green-400 font-mono text-xs p-2 rounded border border-obsidian-border" placeholder="! Add custom commands here..."></textarea>
                </section>
            </div>
            <div class="p-4 bg-obsidian-pane border-t border-obsidian-border flex justify-end">
                <button onclick="saveSettings()" class="bg-obsidian-accent hover:bg-violet-600 text-white px-6 py-2 rounded text-sm transition">Save</button>
            </div>
        </div>
    </div>

    <div id="cli-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl max-w-5xl w-full h-[85vh] flex flex-col animate-fade-in">
            <div class="flex justify-between items-center p-4 border-b border-obsidian-border bg-obsidian-bg">
                <h3 class="text-white font-bold"><i class="fa-solid fa-terminal text-green-500"></i> Config Generator</h3>
                <button onclick="closeCliModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="p-4 bg-obsidian-bg border-b border-obsidian-border flex gap-4 items-center flex-wrap">
                <label class="text-xs text-gray-400">Target:</label>
                <select id="cli-brand" onchange="generateCli()" class="bg-obsidian-pane text-white text-xs p-2 rounded border border-obsidian-border">
                    <option value="hp">HP Aruba (AOS-S)</option>
                    <option value="netgear">Netgear M-Series</option>
                    <option value="ruckus">Ruckus (ICX)</option>
                    <option value="dell">Dell PowerConnect</option>
                </select>
                <button onclick="copyCli()" class="ml-auto bg-obsidian-accent text-white px-4 py-2 rounded text-xs"><i class="fa-regular fa-copy"></i> Copy</button>
            </div>
            <div class="flex-1 overflow-auto p-4 bg-obsidian-bg"><pre id="cli-output" class="font-mono text-xs text-green-400 whitespace-pre-wrap"></pre></div>
        </div>
    </div>

    <div id="export-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col items-center justify-center p-4 backdrop-blur-sm"><div class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl max-w-7xl w-full h-[90vh] flex flex-col"><div class="flex justify-between items-center p-4 border-b border-obsidian-border bg-obsidian-bg"><h3 class="text-white font-bold">Export Preview</h3><button onclick="closeExportModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button></div><div class="flex-1 overflow-auto p-8 bg-white flex items-center justify-center" id="modal-content"></div><div class="p-4 bg-obsidian-pane border-t border-obsidian-border flex justify-end"><button onclick="closeExportModal()" class="bg-obsidian-border text-white px-6 py-2 rounded text-sm">Close</button></div></div></div>
    <div id="importer-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl max-w-4xl w-full h-[80vh] flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-obsidian-border bg-obsidian-bg">
                <h3 class="text-white font-bold">Import Running-Config</h3>
                <button onclick="closeImporterModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="p-4 bg-obsidian-bg border-b border-obsidian-border">
                <div class="mb-3">
                    <label class="text-xs text-gray-400 block mb-1">Vendor/Model</label>
                    <select id="import-vendor" class="w-full bg-obsidian-pane text-white border border-obsidian-border rounded px-3 py-2 text-sm">
                        <option value="">Select vendor...</option>
                        <option value="dell">Dell PowerConnect</option>
                        <option value="netgear">Netgear M-Series</option>
                        <option value="hp">HP Aruba (AOS-S)</option>
                        <option value="ruckus">Ruckus ICX</option>
                    </select>
                </div>
                <textarea id="import-text" class="w-full h-64 bg-obsidian-pane text-gray-300 font-mono text-xs p-4 rounded border border-obsidian-border" placeholder="Paste running-config here..."></textarea>
            </div>
            <div class="p-4 bg-obsidian-pane flex justify-end gap-2">
                <button onclick="closeImporterModal()" class="bg-obsidian-border text-white px-4 py-2 rounded text-xs">Cancel</button>
                <button onclick="parseAndLoadConfig()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-xs font-bold">Import Config</button>
            </div>
        </div>
    </div>

    <footer class="bg-obsidian-pane border-t border-obsidian-border py-3 text-center shrink-0 z-10 flex flex-col md:flex-row justify-center items-center gap-3">
        <a href="https://homelabplayground.com" class="text-gray-500 hover:text-violet-400 text-xs transition-colors font-sans no-underline">
            HomeLab Playground
        </a>
        <span class="hidden md:block text-obsidian-border mx-1">|</span>
        <a href="https://www.buymeacoffee.com/bryjogar" target="_blank" class="inline-flex items-center px-3 py-1 bg-obsidian-accent hover:bg-violet-600 text-white text-xs font-sans rounded-full transition-colors no-underline">
            <i class="fa-solid fa-mug-hot mr-1.5"></i>
            <span>Support The Tools</span>
        </a>
    </footer>

    <script>
        // --- State ---
        const SFP_COUNT = 4;
        const PORT_OPTIONS = [8, 10, 16, 24, 48]; // Used only for manual cycling, not for limiting port counts
        let state = {
            portCount: 24,
            activeVlanId: 'vlan-1',
            activeLagId: null,
            currentTool: 'paint', 
            isMouseDown: false,  // Track mouse state for drag-to-paint
            dragStartPort: null,  // Track which port the drag started on
            hasDragged: false,    // Track if mouse has moved during drag
            vlans: [{ 
                id: 'vlan-1', 
                name: 'Default', 
                vid: 1, 
                color: '#64748b',
                ip: '',                    // L3 IP address (CIDR format)
                ipHelperAddresses: [],     // IP helper addresses (DHCP relay)
                noIpAddress: false,        // no ip address (HP)
                routingInstance: null,     // vlan routing instance (Netgear)
                igmp: {                    // IGMP settings (consolidated)
                    enabled: false,
                    querier: false,
                    fastLeave: false,
                    reportSuppression: false
                },
                qos: {                     // QoS settings per VLAN
                    priority: ''            // QoS priority/class
                },
                voice: false,              // Voice VLAN flag
                stp: {                     // STP settings per VLAN (vendor-agnostic)
                    mode: null,           // 'stp'|'rstp'|'mstp'|'rapid-pvst'|'pvst'|null (disabled)
                    priority: null        // STP priority (0-61440, typically multiples of 4096)
                }
            }],
            lags: [],
            ports: {},
            routedInterfaces: [
                { 
                    id: 'vlan-1', 
                    ip: '192.168.1.2/24',
                    description: '',
                    portName: '',           // port-name (vendor-agnostic)
                    shutdown: false,
                    dhcp: false,            // ip address dhcp (Netgear)
                    ipHelperAddresses: []   // IP helper addresses
                }
            ],
            global: { 
                // System Identity
                hostname: 'SWITCH-01', 
                
                // Network Configuration
                network: {
                    gateway: '192.168.1.1',
                    dns: ['8.8.8.8'],
                    domainName: '',
                    defaultNetwork: null,      // ip default-network (Ruckus)
                    staticRoutes: [],          // [{ network: string, mask: string, gateway: string }]
                    routerProtocols: {         // Router protocols
                        rip: false,
                        ospf: false,
                        ipv6Ospf: false
                    },
                    ipRouting: false
                },
                
                // Time Configuration
                time: {
                    timezone: null,
                    daylightTime: null,         // e.g., 'continental-us-and-canada', 'recurring USA'
                    ntp: [{ server: 'pool.ntp.org', priority: null }],
                    sntp: {                    // SNTP settings (consolidated)
                        interval: null,
                        unicastClient: false,
                        servers: []            // Array of { server: string, priority: number }
                    }
                },
                
                // Management Interfaces
                management: {
                    web: {                     // Web management (consolidated)
                        http: true,
                        httpPort: null,        // ip http port (Netgear)
                        https: false,
                        httpsPort: null,       // ip http secure-port (Netgear)
                        ssl: false
                    },
                    remote: {            // Remote access (consolidated)
                        ssh: null,
                        sshTimeout: null,      // ip ssh timeout / sshcon timeout
                        sshVrf: null,
                        telnet: null,
                        consoleTimeout: null,  // console idle-timeout
                        serialTimeout: null,   // serial timeout
                        cliTimeout: null       // cli timeout (Ruckus)
                    },
                    managerRegistrar: null,   // manager registrar (Ruckus) { device: string, ip: string, port: number }
                    flashTimeout: null        // flash-timeout (Ruckus)
                },
                
                // SNMP Configuration
                snmp: {                    // SNMP settings (consolidated)
                    location: '',
                    contact: '',
                    sysname: '',           // snmp-server sysname (Netgear)
                    communities: [],       // [{ community: string, access: 'ro'|'rw'|'operator'|'unrestricted' }]
                    enableVlan: null,     // VLAN ID for SNMP
                    hosts: [],            // [{ host: string, community: string, version: 'v1'|'v2'|'v3', traps: boolean }]
                    users: []             // [{ username: string, auth: string, priv: string }] (v3)
                },
                
                // Authentication & Authorization
                authentication: {
                    users: [],                 // Array of { username: string, password: string, level: number, encrypted: boolean }
                    passwords: {                // Manager/operator passwords (HP)
                        manager: null,
                        operator: null
                    },
                    aaa: {                     // AAA authentication (Ruckus)
                        login: null,           // aaa authentication login default local
                        webServer: null,       // aaa authentication web-server default local
                        snmpServer: null       // aaa authentication snmp-server default local
                    }
                },
                
                // Layer 2 Protocols
                layer2: {
                    igmp: {                    // Global IGMP (consolidated)
                        enabled: false,
                        snooping: false,
                        querier: {             // IGMP querier settings (Netgear)
                            enabled: false,
                            queryInterval: null
                        }
                    },
                    spanningTree: {            // Global STP (consolidated)
                        enabled: false,
                        mode: null,
                        priority: null,
                        systemMax: null,       // system-max spanning-tree (Ruckus)
                        trapErrantBpdu: false, // spanning-tree trap errant-bpdu (HP)
                        bpduProtectionTimeout: null  // spanning-tree bpdu-protection-timeout (HP)
                    },
                    loopProtect: {             // Loop protection (consolidated)
                        disableTimer: null,
                        trapLoopDetected: false  // loop-protect trap loop-detected (HP)
                    },
                    voiceVlan: null            // Global voice vlan (Dell)
                },
                
                // QoS Configuration
                qos: {                     // QoS settings
                    classOfService: {
                        dot1pMapping: [],  // [{ dot1p: number, queue: number }]
                        ipDscpMapping: [], // [{ dscp: number, queue: number }]
                        trust: null        // 'ip-dscp' | 'dot1p' | null
                    },
                    cosQueue: {            // COS queue settings
                        strict: []         // Array of queue numbers
                    }
                },
                
                // System Services
                services: {                // Service enable/disable
                    restInterface: null,   // rest-interface (HP)
                    restconf: null,         // restconf enable (Ruckus)
                    arubaCentral: null,    // aruba-central disable (HP)
                    tftpServer: null,      // tftp server enable/disable
                    tftpBlocksize: null,   // ip tftp blocksize
                    dhcpConfigFileUpdate: null,  // dhcp config-file-update
                    dhcpImageFileUpdate: null,   // dhcp image-file-update
                    dhcpTr69AcsUrl: null,  // dhcp tr69-acs-url
                    provision: null,        // activate provision disable
                    keepalive: null,           // keepalive (Netgear)
                    syslogServer: null
                },
                
                // Stack Configuration
                stack: {                   // Stack configuration
                    member: null           // { unit: number, member: number }
                },
                
                // Custom Configuration
                customConfig: ''
            }
        };

        // --- DOM Elements ---
        const rj45Container = document.getElementById('rj45-container');
        const sfpContainer = document.getElementById('sfp-container');
        const vlanList = document.getElementById('vlan-list');
        const lagList = document.getElementById('lag-list');
        const sizeBtn = document.getElementById('size-btn');
        const modelLabel = document.getElementById('model-label');
        const cliOutput = document.getElementById('cli-output');
        const propPane = document.getElementById('vlan-properties');

        function init() { 
            setTool('paint'); 
            renderVlanList(); 
            renderLagList(); 
            renderAllPorts(); 
            updateSizeBtnLabel(); 
            loadSettingsToForm();
            updatePropPane();
        }

        // --- Rendering ---
        function renderVlanList() {
            vlanList.innerHTML = '';
            state.vlans.forEach(vlan => {
                const isActive = state.activeVlanId === vlan.id;
                const div = document.createElement('div');
                div.className = `flex items-center justify-between p-2 rounded cursor-pointer transition border mb-1 ${isActive ? 'bg-white/5 border-obsidian-accent' : 'border-transparent hover:bg-white/5'}`;
                div.onclick = () => selectVlan(vlan.id);
                
                let icons = '';
                if(vlan.ip) icons += '<i class="fa-solid fa-network-wired text-[8px] text-green-400 ml-1" title="L3 Interface"></i>';
                if(vlan.igmp?.enabled) icons += '<i class="fa-solid fa-eye text-[8px] text-blue-400 ml-1" title="IGMP"></i>';
                if(vlan.stp?.mode) icons += '<i class="fa-solid fa-sitemap text-[8px] text-purple-400 ml-1" title="STP: ' + (vlan.stp.mode.toUpperCase()) + '"></i>';
                if(vlan.voice) icons += '<i class="fa-solid fa-phone text-[8px] text-green-400 ml-1" title="Voice VLAN"></i>';
                
                div.innerHTML = `<div class="flex items-center gap-2"><div class="w-3 h-3 rounded shadow-sm" style="background-color: ${vlan.color};"></div><span class="text-xs font-mono text-gray-300">${vlan.name} (${vlan.vid})</span>${icons}</div>`;
                vlanList.appendChild(div);
            });
            updatePropPane();
        }

        function updatePropPane() {
            const lagPropPane = document.getElementById('lag-properties');
            if (lagPropPane) lagPropPane.classList.add('hidden');
            
            const vlan = state.vlans.find(v => v.id === state.activeVlanId);
            if(!vlan) { propPane.classList.add('hidden'); return; }
            propPane.classList.remove('hidden');
            document.getElementById('prop-vlan-title').innerText = `${vlan.name} (ID: ${vlan.vid})`;
            document.getElementById('prop-vlan-name').value = vlan.name;
            document.getElementById('prop-vlan-vid').value = vlan.vid || '';
            document.getElementById('prop-vlan-ip').value = vlan.ip || '';
            document.getElementById('prop-vlan-color').value = vlan.color || '#64748b';
            document.getElementById('prop-vlan-igmp').checked = vlan.igmp?.enabled || false;
            document.getElementById('prop-vlan-qos').value = vlan.qos?.priority || '';
            document.getElementById('prop-vlan-voice').checked = vlan.voice || false;
            // STP settings
            if (!vlan.stp) vlan.stp = { mode: null, priority: null };
            document.getElementById('prop-vlan-stp-mode').value = vlan.stp.mode || '';
            // Handle priority 0 correctly (0 is falsy, so check for null/undefined explicitly)
            const stpPriority = (vlan.stp.priority !== null && vlan.stp.priority !== undefined) ? String(vlan.stp.priority) : '';
            document.getElementById('prop-vlan-stp-priority').value = stpPriority;
        }
        
        function saveVlanProps() {
            const vlan = state.vlans.find(v => v.id === state.activeVlanId);
            if(vlan) {
                vlan.name = document.getElementById('prop-vlan-name').value;
                
                // Handle VLAN ID change
                const newVidStr = document.getElementById('prop-vlan-vid').value.trim();
                if (newVidStr) {
                    const newVid = parseInt(newVidStr);
                    if (isNaN(newVid) || newVid < 1 || newVid > 4094) {
                        alert("VLAN ID must be between 1 and 4094");
                        return;
                    }
                    // Check if new VID already exists (and it's not the current VLAN)
                    const existingVlan = state.vlans.find(v => v.vid === newVid && v.id !== vlan.id);
                    if (existingVlan) {
                        alert(`VLAN ID ${newVid} is already in use by ${existingVlan.name}`);
                        return;
                    }
                    // Update VID if it changed
                    if (newVid !== vlan.vid) {
                        vlan.vid = newVid;
                        // Update the ID to match (vlan-{vid})
                        const oldId = vlan.id;
                        vlan.id = `vlan-${newVid}`;
                        // Update activeVlanId if this was the active VLAN
                        if (state.activeVlanId === oldId) {
                            state.activeVlanId = vlan.id;
                        }
                        // Update all port references to use new VLAN ID
                        Object.keys(state.ports).forEach(portNum => {
                            const port = state.ports[portNum];
                            if (port.nativeVlanId === oldId) {
                                port.nativeVlanId = vlan.id;
                            }
                            if (port.taggedVlans) {
                                const idx = port.taggedVlans.indexOf(oldId);
                                if (idx > -1) {
                                    port.taggedVlans[idx] = vlan.id;
                                }
                            }
                        });
                        // Update LAG references
                        state.lags.forEach(lag => {
                            if (lag.nativeVlanId === oldId) {
                                lag.nativeVlanId = vlan.id;
                            }
                        });
                    }
                }
                
                vlan.ip = document.getElementById('prop-vlan-ip').value;
                vlan.color = document.getElementById('prop-vlan-color').value;
                if (!vlan.igmp) vlan.igmp = { enabled: false, querier: false, fastLeave: false, reportSuppression: false };
                vlan.igmp.enabled = document.getElementById('prop-vlan-igmp').checked;
                if (!vlan.qos) vlan.qos = { priority: '' };
                vlan.qos.priority = document.getElementById('prop-vlan-qos').value;
                vlan.voice = document.getElementById('prop-vlan-voice').checked;
                // STP settings
                if (!vlan.stp) vlan.stp = { mode: null, priority: null };
                const stpMode = document.getElementById('prop-vlan-stp-mode').value.trim();
                vlan.stp.mode = stpMode || null;
                const stpPriority = document.getElementById('prop-vlan-stp-priority').value.trim();
                vlan.stp.priority = stpPriority ? parseInt(stpPriority) : null;
                renderVlanList();
                renderAllPorts(); // Refresh port colors
                // Close the properties panel after saving
                propPane.classList.add('hidden');
            }
        }

        function renderLagList() {
            lagList.innerHTML = '';
            state.lags.forEach(lag => {
                const isActive = state.activeLagId === lag.id;
                const div = document.createElement('div');
                div.className = `flex items-center justify-between p-2 rounded cursor-pointer transition border mb-1 ${isActive ? 'bg-white/5 border-blue-500' : 'border-transparent hover:bg-white/5'}`;
                div.onclick = () => selectLag(lag.id);
                div.innerHTML = `<div class="flex items-center gap-2"><i class="fa-solid fa-link text-blue-500 text-xs"></i><span class="text-xs font-mono text-gray-300">L${lag.id}: ${lag.name}</span></div><span class="text-[9px] text-gray-500 uppercase">${lag.type}</span>`;
                lagList.appendChild(div);
            });
        }

        function renderAllPorts() { renderRJ45(); renderSFP(); modelLabel.innerText = state.portCount; }

        function renderRJ45() {
            // Calculate columns (ports are displayed in pairs, top and bottom)
            const columns = Math.ceil(state.portCount / 2);
            rj45Container.style.gridTemplateColumns = `repeat(${columns}, minmax(34px, 1fr))`; 
            rj45Container.innerHTML = '';
            
            let lastModule = null;
            
            for (let col = 0; col < columns; col++) {
                const topPort = (col * 2) + 1;
                const bottomPort = (col * 2) + 2;
                
                // Check if we need a module separator (for Ruckus multi-module switches)
                const topPortGroup = topPort <= state.portCount ? (state.ports[topPort]?.portGroup || null) : null;
                const bottomPortGroup = bottomPort <= state.portCount ? (state.ports[bottomPort]?.portGroup || null) : null;
                const currentGroup = topPortGroup || bottomPortGroup;
                
                const colDiv = document.createElement('div');
                // Add left border and margin as separator if port group changed (but not on first port)
                if (currentGroup && lastModule !== null && currentGroup !== lastModule) {
                    colDiv.className = "flex flex-col gap-1 items-center border-l-2 border-gray-600 pl-2 ml-2";
                } else {
                colDiv.className = "flex flex-col gap-1 items-center";
                }
                
                // Top port
                if (topPort <= state.portCount) {
                    colDiv.appendChild(createPortNode(topPort, 'top', false));
                    if (lastModule === null) lastModule = topPortGroup;
                } else {
                    // Empty space if odd number of ports
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = "w-8 h-8"; // Same size as port for spacing
                    colDiv.appendChild(emptyDiv);
                }
                
                // Bottom port
                if (bottomPort <= state.portCount) {
                    colDiv.appendChild(createPortNode(bottomPort, 'bottom', false));
                    if (lastModule === null) lastModule = bottomPortGroup;
                } else {
                    // Empty space if odd number of ports
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = "w-8 h-8"; // Same size as port for spacing
                    colDiv.appendChild(emptyDiv);
                }
                
                rj45Container.appendChild(colDiv);
                
                // Update lastModule after processing this column
                if (currentGroup) lastModule = currentGroup;
            }
        }

        function renderSFP() {
            sfpContainer.innerHTML = '';
            // SFP ports are any ports with number > state.portCount (universal approach)
            // For Ruckus: state.portCount = 26 (module 1 + module 2), so SFP = ports 27-30
            // This works for any vendor, not just Ruckus
            const sfpStartNum = state.portCount + 1;
            
            // Find all ports that are SFP (port number > main section port count)
            const sfpPorts = [];
            Object.keys(state.ports).forEach(portNumStr => {
                const portNum = parseInt(portNumStr);
                if (portNum > state.portCount) {
                    sfpPorts.push(portNum);
                }
            });
            
            // Sort SFP ports
            sfpPorts.sort((a, b) => a - b);
            
            // Render SFP ports in pairs (top/bottom) like RJ45 ports
            // Calculate columns (ports are displayed in pairs, top and bottom)
            const sfpPortCount = sfpPorts.length > 0 ? sfpPorts.length : SFP_COUNT;
            const columns = Math.ceil(sfpPortCount / 2);
            
            for (let col = 0; col < columns; col++) {
                const topPortIndex = col * 2;
                const bottomPortIndex = col * 2 + 1;
                
                const colDiv = document.createElement('div');
                colDiv.className = "flex flex-col gap-1 items-center";
                
                // Top port
                if (sfpPorts.length > 0 && topPortIndex < sfpPorts.length) {
                    colDiv.appendChild(createPortNode(sfpPorts[topPortIndex], 'top', true));
                } else if (sfpPorts.length === 0 && topPortIndex < SFP_COUNT) {
                    colDiv.appendChild(createPortNode(sfpStartNum + topPortIndex, 'top', true));
                } else {
                    // Empty space if odd number of ports
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = "w-8 h-8"; // Same size as port for spacing
                    colDiv.appendChild(emptyDiv);
                }
                
                // Bottom port
                if (sfpPorts.length > 0 && bottomPortIndex < sfpPorts.length) {
                    colDiv.appendChild(createPortNode(sfpPorts[bottomPortIndex], 'bottom', true));
                } else if (sfpPorts.length === 0 && bottomPortIndex < SFP_COUNT) {
                    colDiv.appendChild(createPortNode(sfpStartNum + bottomPortIndex, 'bottom', true));
                } else {
                    // Empty space if odd number of ports
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = "w-8 h-8"; // Same size as port for spacing
                    colDiv.appendChild(emptyDiv);
                }
                
                sfpContainer.appendChild(colDiv);
            }
        }

        function createPortNode(portNum, position, isSfp) {
            const portData = state.ports[portNum] || { 
                nativeVlanId: null, 
                taggedVlans: [], 
                excludedVlans: [],
                customLabel: null, 
                poe: { enabled: undefined, priority: null },
                portMode: null,
                lagId: null, 
                loopProtect: { enabled: false, action: null },
                bpduProtection: true,
                stp: { edgePort: false, pt2ptMac: false, portfast: false },
                voice: { vlanId: null, lldpMed: null },
                routing: null,
                trunkNativeVlan: null,
                shutdown: false,
                mtu: null,
                speed: null,
                duplex: null,
                autoNegotiate: null,
                lldp: { transmitTlv: [], transmitMgmt: false },
                keepalive: null,
                vlanParticipationAuto: null,
                ptp: null
            };
            // Default BPDU protection to true if not explicitly set
            if (portData.bpduProtection === undefined) portData.bpduProtection = true;
            // Handle legacy isPoe format for backward compatibility
            const isPoeEnabled = !isSfp && (portData.poe?.enabled !== false && (portData.poe?.enabled === true || portData.isPoe !== false));
            
            // Apply LAG uplink configuration to port if it's part of an uplink LAG
            let displayNativeVlanId = portData.nativeVlanId;
            let displayTaggedVlans = portData.taggedVlans ? [...portData.taggedVlans] : [];
            
            if (portData.lagId) {
                const lag = state.lags.find(l => String(l.id) === String(portData.lagId));
                if (lag && lag.uplink && lag.nativeVlanId) {
                    // Apply uplink configuration: native VLAN is untagged, all others are tagged
                    displayNativeVlanId = lag.nativeVlanId;
                    // Tag all VLANs except the native one
                    displayTaggedVlans = state.vlans
                        .filter(v => v.id !== lag.nativeVlanId)
                        .map(v => v.id);
                }
            }

            let baseColor = isSfp ? '#1a1a1a' : '#0d0d0d';
            let vlanName = 'Unassigned';
            let vid = '';
            
            if (displayNativeVlanId) {
                const vlan = state.vlans.find(v => v.id === displayNativeVlanId);
                if (vlan) { baseColor = vlan.color; vlanName = vlan.name; vid = vlan.vid; }
            }

            let tooltip = `Port ${portNum}`;
            if(portData.customLabel) tooltip += `\nLabel: ${portData.customLabel}`;
            if(portData.lagId) {
                const lag = state.lags.find(l=>l.id===portData.lagId);
                tooltip += `\nLAG: L${portData.lagId} ${lag?lag.name:''}`;
            }
            if(displayNativeVlanId) tooltip += `\nNative: ${vlanName} (${vid})`;
            if(displayTaggedVlans && displayTaggedVlans.length > 0) {
                const tagNames = displayTaggedVlans.map(tid => {
                    const v = state.vlans.find(v => v.id === tid);
                    return v ? `${v.name} (${v.vid})` : tid;
                }).join(', ');
                tooltip += `\nTagged: ${tagNames}`;
            }
            if(!isSfp) tooltip += `\nPoE: ${isPoeEnabled?'On':'Off'}`;
            if(portData.loopProtect?.enabled) tooltip += `\nLoop Protect: On`;
            if(!isSfp && portData.bpduProtection !== undefined) {
                tooltip += `\nBPDU Protection: ${portData.bpduProtection ? 'On' : 'Off'}`;
            }

            let tagsHtml = '';
            if (displayTaggedVlans && displayTaggedVlans.length > 0) {
                tagsHtml = '<div class="tag-container">';
                displayTaggedVlans.forEach(tagId => {
                    const tagVlan = state.vlans.find(v => v.id === tagId);
                    if(tagVlan) tagsHtml += `<div class="tag-pip" style="background-color: ${tagVlan.color};"></div>`;
                });
                tagsHtml += '</div>';
            }

            const lagBadge = portData.lagId ? `<div class="lag-badge">L${portData.lagId}</div>` : '';
            const poeIcon = isPoeEnabled ? '<i class="fa-solid fa-bolt text-yellow-400 absolute top-0.5 right-0.5 text-[9px] z-20 drop-shadow-md"></i>' : '';
            const protectIcon = portData.loopProtect?.enabled ? '<i class="fa-solid fa-shield-halved text-blue-400 absolute top-0.5 left-0.5 text-[9px] z-20 drop-shadow-md"></i>' : '';
            // BPDU protection indicator - show when disabled (red X) or enabled (green shield)
            const bpduIcon = !isSfp && portData.bpduProtection === false 
                ? '<i class="fa-solid fa-shield text-red-400 absolute bottom-0.5 right-0.5 text-[8px] z-20 drop-shadow-md" title="BPDU Protection Disabled"></i>' 
                : (!isSfp && portData.bpduProtection !== false 
                    ? '<i class="fa-solid fa-shield text-green-400 absolute bottom-0.5 right-0.5 text-[8px] z-20 drop-shadow-md opacity-60" title="BPDU Protection Enabled"></i>' 
                    : '');
            const wrapper = document.createElement('div');
            wrapper.className = "flex flex-col items-center gap-1 group relative";
            const inputHtml = `<input type="text" value="${portData.customLabel || portNum}" class="w-8 text-[9px] text-center bg-transparent border-none text-gray-500 font-mono focus:text-white focus:bg-obsidian-pane rounded port-label-input z-20" onchange="updateLabel(${portNum}, this.value)" readonly>`;
            
            const commonClasses = `w-8 h-8 rounded-sm relative overflow-hidden border ${portData.lagId ? 'border-blue-500' : 'border-obsidian-border'}`;
            const bgStyle = `background-color: ${displayNativeVlanId ? baseColor : (isSfp?'#1a1a1a':'#0d0d0d')}`;
            const overlay = `<div class="absolute inset-0 opacity-40" style="${displayNativeVlanId ? 'background-color:'+baseColor : ''}"></div>`;
            const led = !isSfp ? `<div class="absolute bottom-1 right-1 w-1 h-1 rounded-full ${displayNativeVlanId ? 'bg-green-500 shadow-[0_0_4px_#22c55e]' : 'bg-gray-800'}"></div>` : `<div class="z-10 w-3 h-4 bg-black/50 rounded-sm border border-white/10"></div>`;
            
            // For label tool, use onclick (needs prompt). For all others, use mousedown + mouseenter (drag to paint)
            // Apply tool on initial mousedown, then continue on mouseenter while dragging
            const clickHandler = state.currentTool === 'label' 
                ? `onclick="handlePortClick(${portNum})"` 
                : `onmousedown="event.preventDefault(); state.isMouseDown = true; state.dragStartPort = ${portNum}; state.hasDragged = false; handlePortClick(${portNum});" onmouseenter="if(state.isMouseDown && state.dragStartPort !== ${portNum}) { state.hasDragged = true; handlePortClick(${portNum}); }" onmouseup="state.isMouseDown = false; state.hasDragged = false; state.dragStartPort = null;"`;
            const portHtml = `<div class="${commonClasses} ${isSfp?'sfp-port':'rj45-port'}" title="${tooltip}" style="user-select: none; -webkit-user-select: none;" ${clickHandler}>${overlay}${tagsHtml}${led}${poeIcon}${protectIcon}${bpduIcon}${lagBadge}</div>`;

            if (position === 'top') wrapper.innerHTML = inputHtml + portHtml;
            else if (position === 'bottom') wrapper.innerHTML = portHtml + inputHtml;
            else wrapper.innerHTML = portHtml + `<div class="mt-1">${inputHtml}</div>`;
            return wrapper;
        }

        // --- Logic ---
        function handlePortClick(portNum) {
            if (!state.ports[portNum]) {
                state.ports[portNum] = { 
                    nativeVlanId: null, 
                    taggedVlans: [], 
                    excludedVlans: [],
                    customLabel: null, 
                    portMode: null,          // switchport mode (general/trunk/access)
                    poe: { enabled: undefined, priority: null },
                    lagId: null, 
                    loopProtect: { enabled: false, action: null },
                    bpduProtection: true,
                    stp: { 
                        edgePort: false,     // spanning-tree portfast / admin-edge-port
                        pt2ptMac: false,    // admin-pt2pt-mac (Ruckus)
                        portfast: false     // spanning-tree portfast (Dell)
                    },
                    voice: { vlanId: null, lldpMed: null },
                    routing: null,
                    trunkNativeVlan: null,
                    shutdown: false,
                    mtu: null,
                    speed: null,            // speed 100 full-duplex (Netgear)
                    duplex: null,           // full-duplex / half-duplex
                    autoNegotiate: null,    // no auto-negotiate (Netgear)
                    lldp: {                 // LLDP settings
                        transmitTlv: [],    // lldp transmit-tlv (port-desc, sys-name)
                        transmitMgmt: false // lldp transmit-mgmt
                    },
                    keepalive: null,        // keepalive action both (Netgear)
                    vlanParticipationAuto: null,  // vlan participation auto 1 (Netgear)
                    ptp: null               // ptp clock e2e-transparent (Netgear)
                };
            }
            const p = state.ports[portNum];
            if (p.bpduProtection === undefined) p.bpduProtection = true;
            const isSfp = portNum > state.portCount; 

            // Apply tool action
            if (state.currentTool === 'paint') p.nativeVlanId = state.activeVlanId;
            else if (state.currentTool === 'tag') {
                if (!p.taggedVlans) p.taggedVlans = [];
                const idx = p.taggedVlans.indexOf(state.activeVlanId);
                if (idx > -1) p.taggedVlans.splice(idx, 1);
                else if (p.nativeVlanId !== state.activeVlanId) p.taggedVlans.push(state.activeVlanId);
            }
            else if (state.currentTool === 'poe' && !isSfp) {
                if (!p.poe) p.poe = { enabled: undefined, priority: null };
                p.poe.enabled = (p.poe.enabled === false) ? true : false;
            }
            else if (state.currentTool === 'protect') {
                if (!p.loopProtect) p.loopProtect = { enabled: false, action: null };
                p.loopProtect.enabled = !p.loopProtect.enabled;
            }
            else if (state.currentTool === 'bpdu') {
                if (p.bpduProtection === undefined) p.bpduProtection = true;
                p.bpduProtection = !p.bpduProtection;
            }
            else if (state.currentTool === 'lag') {
                if (state.activeLagId) p.lagId = (p.lagId === state.activeLagId) ? null : state.activeLagId;
            }
            else if (state.currentTool === 'erase') { 
                p.nativeVlanId = null; 
                p.taggedVlans = []; 
                p.excludedVlans = [];
                if (p.poe) p.poe.enabled = undefined;
                p.customLabel = null; 
                p.lagId = null; 
                if (p.loopProtect) p.loopProtect.enabled = false;
                p.bpduProtection = true; 
            }
            else if (state.currentTool === 'label') {
                const newLabel = prompt(`Label Port ${portNum}:`, p.customLabel || portNum);
                if (newLabel !== null) p.customLabel = (newLabel === '' || newLabel == portNum) ? null : newLabel;
            }
            else if (state.currentTool === 'uplink') {
                // Uplink: untag selected VLAN (make it native), tag all other VLANs
                if (state.activeVlanId) {
                    p.nativeVlanId = state.activeVlanId;
                    // Tag all other VLANs
                    p.taggedVlans = [];
                    state.vlans.forEach(v => {
                        if (v.id !== state.activeVlanId) {
                            p.taggedVlans.push(v.id);
                        }
                    });
                }
            }
            renderAllPorts();
        }

        function updateLabel(portNum, text) { 
            if(!state.ports[portNum]) state.ports[portNum]={}; state.ports[portNum].customLabel = text; renderAllPorts(); 
        }

        window.setTool = function(tool) {
            state.currentTool = tool;
            const base = ['tool-btn','p-2','rounded','flex','items-center','justify-center','gap-2','text-xs'];
            const active = ['bg-obsidian-accent','text-white'];
            const inactive = ['bg-obsidian-bg','text-gray-400','border','border-obsidian-border'];
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.className = ''; btn.classList.add(...base);
                if(btn.id===`tool-${tool}`) btn.classList.add(...active);
                else btn.classList.add(...(btn.id!=='tool-erase' ? inactive : ['border','border-red-900/30','text-red-400']));
            });
        };
        
        // Also create an alias for backwards compatibility
        function setTool(tool) { window.setTool(tool); }
        
        // Global mouse event handlers for drag-to-paint
        // Stop painting when mouse is released anywhere
        document.addEventListener('mouseup', () => { 
            if (state) state.isMouseDown = false; 
        });
        // Stop painting if mouse leaves the document
        document.addEventListener('mouseout', (e) => { 
            if (state && (!e.relatedTarget || e.relatedTarget === document)) {
                state.isMouseDown = false; 
            }
        });
        
        function selectVlan(id) { state.activeVlanId = id; renderVlanList(); }
        function selectLag(id) { 
            state.activeLagId = id; 
            setTool('lag'); 
            renderLagList(); 
            updateLagPropPane(); 
        }
        
        function updateLagPropPane() {
            const lagPropPane = document.getElementById('lag-properties');
            const vlanPropPane = document.getElementById('vlan-properties');
            const lag = state.lags.find(l => String(l.id) === String(state.activeLagId));
            
            // Hide VLAN properties when showing LAG properties
            if (vlanPropPane) vlanPropPane.classList.add('hidden');
            
            if (!lag) { 
                if (lagPropPane) lagPropPane.classList.add('hidden'); 
                return; 
            }
            if (lagPropPane) lagPropPane.classList.remove('hidden');
            document.getElementById('prop-lag-title').innerText = `${lag.name} (LAG ${lag.id})`;
            document.getElementById('prop-lag-name').value = lag.name || '';
            document.getElementById('prop-lag-stp-priority').value = lag.stpPriority || '';
            document.getElementById('prop-lag-uplink').checked = lag.uplink || false;
            
            // Update native VLAN dropdown
            const nativeVlanSelect = document.getElementById('prop-lag-native-vlan');
            const nativeVlanContainer = document.getElementById('prop-lag-native-vlan-container');
            nativeVlanSelect.innerHTML = '<option value="">Select VLAN...</option>';
            state.vlans.forEach(v => {
                const sel = lag.nativeVlanId === v.id ? 'selected' : '';
                nativeVlanSelect.innerHTML += `<option value="${v.id}" ${sel}>${v.name} (${v.vid})</option>`;
            });
            
            // Show/hide native VLAN selector based on uplink flag
            toggleLagNativeVlan();
        }
        
        function toggleLagNativeVlan() {
            const uplinkChecked = document.getElementById('prop-lag-uplink').checked;
            const nativeVlanContainer = document.getElementById('prop-lag-native-vlan-container');
            if (uplinkChecked) {
                nativeVlanContainer.classList.remove('hidden');
            } else {
                nativeVlanContainer.classList.add('hidden');
            }
        }
        
        function saveLagProps() {
            const lag = state.lags.find(l => String(l.id) === String(state.activeLagId));
            if (!lag) return;
            
            lag.name = document.getElementById('prop-lag-name').value;
            const stpPriority = document.getElementById('prop-lag-stp-priority').value.trim();
            lag.stpPriority = stpPriority ? parseInt(stpPriority) : null;
            lag.uplink = document.getElementById('prop-lag-uplink').checked;
            
            if (lag.uplink) {
                lag.nativeVlanId = document.getElementById('prop-lag-native-vlan').value || null;
                
                // Apply uplink configuration: untag native VLAN, tag all others
                if (lag.nativeVlanId) {
                    // This will be handled during export generation
                    // For now, we just store the configuration
                }
            } else {
                lag.nativeVlanId = null;
            }
            
            renderLagList();
            // Close the LAG properties panel after saving
            const lagPropPane = document.getElementById('lag-properties');
            if (lagPropPane) lagPropPane.classList.add('hidden');
        }

        function addVlan() {
            const nameInput = document.getElementById('new-vlan-name');
            const colorInput = document.getElementById('new-vlan-color');
            const vidInput = document.getElementById('new-vlan-vid');

            const name = nameInput.value.trim();
            const color = colorInput.value;
            const vidStr = vidInput.value.trim();

            if (!name) { alert("Please enter a VLAN Name"); return; }

            // Use provided VID or auto-increment
            let vid;
            if (vidStr) {
                vid = parseInt(vidStr);
                if (isNaN(vid) || vid < 1 || vid > 4094) {
                    alert("VLAN ID must be between 1 and 4094");
                    return;
                }
            } else {
                // Auto-increment VID
                 vid = state.vlans.length > 0 ? Math.max(...state.vlans.map(v => v.vid || 0)) + 10 : 10;
            }

            // Validate ID
            if (state.vlans.find(v => v.vid === vid)) {
                alert(`VLAN ID ${vid} already exists.`);
                return;
            }

            const id = `vlan-${vid}`;
            state.vlans.push({ id, name, color, vid });
            
            // Reset inputs
            nameInput.value = '';
            vidInput.value = '';
            
            selectVlan(id);
        }

        function addLag() {
            const name = document.getElementById('new-lag-name').value.trim();
            if(!name) return;
            const id = state.lags.length + 1; 
            const type = document.getElementById('new-lag-type').value;
            state.lags.push({ id: String(id), name, type, stpPriority: null, uplink: false, nativeVlanId: null });
            document.getElementById('new-lag-name').value = ''; selectLag(String(id));
        }

        function resetVlans() { if(confirm("Reset VLANs?")) { state.vlans=[{ id: 'vlan-1', name: 'Default', vid: 1, color: '#64748b' }]; state.activeVlanId='vlan-1'; renderVlanList(); renderAllPorts(); } }
        function resetLags() { if(confirm("Clear LAGs?")) { state.lags = []; Object.values(state.ports).forEach(p=>p.lagId=null); renderLagList(); renderAllPorts(); } }
        function cycleSwitchSize() {
            // Cycle through common port counts, or if current count isn't in options, start from first option
            let idx = PORT_OPTIONS.indexOf(state.portCount);
            if (idx === -1) {
                // Current port count not in options (e.g., 54), start from first option
                state.portCount = PORT_OPTIONS[0];
            } else {
            state.portCount = PORT_OPTIONS[(idx+1)%PORT_OPTIONS.length];
            }
            updateSizeBtnLabel(); renderAllPorts();
        }
        function updateSizeBtnLabel() { sizeBtn.innerText = `Size: ${state.portCount} Ports`; }
        
        function openSettingsModal() { loadSettingsToForm(); document.getElementById('settings-modal').classList.remove('hidden'); }
        function closeSettingsModal() { document.getElementById('settings-modal').classList.add('hidden'); }
        function loadSettingsToForm() { 
            // Device Basics
            document.getElementById('conf-hostname').value = state.global.hostname || '';
            document.getElementById('conf-domain-name').value = state.global.network?.domainName || '';
            
            // Network Configuration
            document.getElementById('conf-gateway').value = state.global.network?.gateway || '';
            const dnsValue = Array.isArray(state.global.network?.dns) ? state.global.network.dns.join(', ') : (state.global.network?.dns || '');
            document.getElementById('conf-dns').value = dnsValue;
            document.getElementById('conf-ip-routing').checked = state.global.network?.ipRouting || false;
            
            // Time Configuration
            document.getElementById('conf-timezone').value = state.global.time?.timezone || '';
            // NTP servers - render list
            renderNtpServersList();
            // NTP serve - if all entries have disableServe=false or no entries, enable serve
            const ntpServeEnabled = !state.global.time?.ntp || state.global.time.ntp.length === 0 || 
                                   !state.global.time.ntp.some(ntp => ntp.disableServe === true);
            document.getElementById('conf-ntp-serve').checked = ntpServeEnabled;
            document.getElementById('conf-sntp-unicast').checked = state.global.time?.sntp?.unicastClient || false;
            document.getElementById('conf-sntp-interval').value = state.global.time?.sntp?.interval || '';
            
            // SNMP Configuration
            document.getElementById('conf-snmp-location').value = state.global.snmp?.location || '';
            document.getElementById('conf-snmp-contact').value = state.global.snmp?.contact || '';
            document.getElementById('conf-snmp-sysname').value = state.global.snmp?.sysname || '';
            document.getElementById('conf-snmp-enable-vlan').value = state.global.snmp?.enableVlan || '';
            // Load first community (prefer RO, otherwise first one)
            const firstCommunity = state.global.snmp?.communities && state.global.snmp.communities.length > 0 
                ? state.global.snmp.communities.find(c => c.access === 'ro') || state.global.snmp.communities[0]
                : null;
            // SNMP communities are now managed via renderSnmpCommunitiesList() - no need to load into form inputs
            
            // Management Interfaces
            document.getElementById('conf-web-http').checked = state.global.management?.web?.http !== false;
            document.getElementById('conf-web-http-port').value = state.global.management?.web?.httpPort || '';
            document.getElementById('conf-web-https').checked = state.global.management?.web?.https || false;
            document.getElementById('conf-web-https-port').value = state.global.management?.web?.httpsPort || '';
            document.getElementById('conf-ssh-enabled').checked = state.global.management?.remote?.ssh !== null && state.global.management.remote.ssh !== false;
            document.getElementById('conf-ssh-timeout').value = state.global.management?.remote?.sshTimeout || '';
            document.getElementById('conf-telnet-enabled').checked = state.global.management?.remote?.telnet !== null && state.global.management.remote.telnet !== false;
            document.getElementById('conf-console-timeout').value = state.global.management?.remote?.consoleTimeout || '';
            
            // Layer 2 Protocols
            const igmpEnabled = document.getElementById('conf-igmp-enabled');
            if (igmpEnabled) igmpEnabled.checked = state.global.layer2?.igmp?.enabled || false;
            const igmpSnooping = document.getElementById('conf-igmp-snooping');
            if (igmpSnooping) igmpSnooping.checked = state.global.layer2?.igmp?.snooping || false;
            const igmpQuerierEnabled = document.getElementById('conf-igmp-querier-enabled');
            if (igmpQuerierEnabled) igmpQuerierEnabled.checked = state.global.layer2?.igmp?.querier?.enabled || false;
            const igmpQuerierInterval = document.getElementById('conf-igmp-querier-interval');
            if (igmpQuerierInterval) igmpQuerierInterval.value = state.global.layer2?.igmp?.querier?.queryInterval || '';
            const stpEnabled = document.getElementById('conf-stp-enabled');
            if (stpEnabled) stpEnabled.checked = state.global.layer2?.spanningTree?.enabled || false;
            const stpPriority = document.getElementById('conf-stp-priority');
            if (stpPriority) stpPriority.value = state.global.layer2?.spanningTree?.priority || '';
            
            // Router Protocols
            const routerRip = document.getElementById('conf-router-rip');
            if (routerRip) routerRip.checked = state.global.network?.routerProtocols?.rip || false;
            const routerOspf = document.getElementById('conf-router-ospf');
            if (routerOspf) routerOspf.checked = state.global.network?.routerProtocols?.ospf || false;
            const routerIpv6Ospf = document.getElementById('conf-router-ipv6-ospf');
            if (routerIpv6Ospf) routerIpv6Ospf.checked = state.global.network?.routerProtocols?.ipv6Ospf || false;
            
            // Custom Config
            document.getElementById('conf-custom').value = state.global.customConfig || '';
            
            // Ensure nested structures exist for backward compatibility
            if (!state.global.network) state.global.network = { gateway: '', dns: [], domainName: '', defaultNetwork: null, staticRoutes: [], routerProtocols: { rip: false, ospf: false, ipv6Ospf: false }, ipRouting: false };
            if (!state.global.time) state.global.time = { timezone: null, daylightTime: null, ntp: [], sntp: { interval: null, unicastClient: false, servers: [] } };
            if (!state.global.management) state.global.management = { web: { http: true, httpPort: null, https: false, httpsPort: null, ssl: false }, remote: { ssh: null, sshTimeout: null, sshVrf: null, telnet: null, consoleTimeout: null, serialTimeout: null, cliTimeout: null }, managerRegistrar: null, flashTimeout: null };
            if (!state.global.layer2) state.global.layer2 = { igmp: { enabled: false, snooping: false, querier: { enabled: false, queryInterval: null } }, spanningTree: { enabled: false, mode: null, priority: null, systemMax: null, trapErrantBpdu: false, bpduProtectionTimeout: null }, loopProtect: { disableTimer: null, trapLoopDetected: false }, voiceVlan: null };
            
            renderL3List();
            renderSnmpCommunitiesList();
            renderStaticRoutesList();
        }
        
        function saveSettings() { 
            // Ensure nested structures exist
            if (!state.global.network) state.global.network = { gateway: '', dns: [], domainName: '', defaultNetwork: null, staticRoutes: [], routerProtocols: { rip: false, ospf: false, ipv6Ospf: false }, ipRouting: false };
            if (!state.global.time) state.global.time = { timezone: null, daylightTime: null, ntp: [], sntp: { interval: null, unicastClient: false, servers: [] } };
            if (!state.global.management) state.global.management = { web: { http: true, httpPort: null, https: false, httpsPort: null, ssl: false }, remote: { ssh: null, sshTimeout: null, sshVrf: null, telnet: null, consoleTimeout: null, serialTimeout: null, cliTimeout: null }, managerRegistrar: null, flashTimeout: null };
            if (!state.global.snmp) state.global.snmp = { location: '', contact: '', sysname: '', communities: [], enableVlan: null, hosts: [], users: [] };
            if (!state.global.layer2) state.global.layer2 = { igmp: { enabled: false, snooping: false, querier: { enabled: false, queryInterval: null } }, spanningTree: { enabled: false, mode: null, priority: null, systemMax: null, trapErrantBpdu: false, bpduProtectionTimeout: null }, loopProtect: { disableTimer: null, trapLoopDetected: false }, voiceVlan: null };
            
            // Device Basics
            state.global.hostname = document.getElementById('conf-hostname').value;
            state.global.network.domainName = document.getElementById('conf-domain-name').value;
            
            // Network Configuration
            state.global.network.gateway = document.getElementById('conf-gateway').value;
            const dnsInput = document.getElementById('conf-dns').value.trim();
            if (dnsInput) {
                state.global.network.dns = dnsInput.split(',').map(s => s.trim()).filter(s => s);
            }
            state.global.network.ipRouting = document.getElementById('conf-ip-routing').checked;
            
            // Time Configuration
            state.global.time.timezone = document.getElementById('conf-timezone').value || null;
            // NTP servers are saved via renderNtpServersList() - they're already in state
            // Apply the "serve" setting to all NTP entries
            const ntpServeEnabled = document.getElementById('conf-ntp-serve').checked;
            if (state.global.time.ntp && state.global.time.ntp.length > 0) {
                state.global.time.ntp.forEach(ntp => {
                    ntp.disableServe = !ntpServeEnabled;
                });
            }
            state.global.time.sntp.unicastClient = document.getElementById('conf-sntp-unicast').checked;
            const sntpInterval = document.getElementById('conf-sntp-interval').value.trim();
            state.global.time.sntp.interval = sntpInterval ? parseInt(sntpInterval) : null;
            
            // SNMP Configuration
            state.global.snmp.location = document.getElementById('conf-snmp-location').value;
            state.global.snmp.contact = document.getElementById('conf-snmp-contact').value;
            state.global.snmp.sysname = document.getElementById('conf-snmp-sysname').value;
            const snmpVlan = document.getElementById('conf-snmp-enable-vlan').value.trim();
            state.global.snmp.enableVlan = snmpVlan ? parseInt(snmpVlan) : null;
            // SNMP communities are now managed via renderSnmpCommunitiesList() - no need to save from form inputs
            
            // Management Interfaces
            state.global.management.web.http = document.getElementById('conf-web-http').checked;
            const httpPort = document.getElementById('conf-web-http-port').value.trim();
            state.global.management.web.httpPort = httpPort ? parseInt(httpPort) : null;
            state.global.management.web.https = document.getElementById('conf-web-https').checked;
            const httpsPort = document.getElementById('conf-web-https-port').value.trim();
            state.global.management.web.httpsPort = httpsPort ? parseInt(httpsPort) : null;
            state.global.management.remote.ssh = document.getElementById('conf-ssh-enabled').checked;
            const sshTimeout = document.getElementById('conf-ssh-timeout').value.trim();
            state.global.management.remote.sshTimeout = sshTimeout ? parseInt(sshTimeout) : null;
            state.global.management.remote.telnet = document.getElementById('conf-telnet-enabled').checked;
            const consoleTimeout = document.getElementById('conf-console-timeout').value.trim();
            state.global.management.remote.consoleTimeout = consoleTimeout ? parseInt(consoleTimeout) : null;
            
            // Layer 2 Protocols
            state.global.layer2.igmp.enabled = document.getElementById('conf-igmp-enabled').checked;
            state.global.layer2.igmp.snooping = document.getElementById('conf-igmp-snooping').checked;
            state.global.layer2.igmp.querier.enabled = document.getElementById('conf-igmp-querier-enabled').checked;
            const igmpQuerierInterval = document.getElementById('conf-igmp-querier-interval').value.trim();
            state.global.layer2.igmp.querier.queryInterval = igmpQuerierInterval ? parseInt(igmpQuerierInterval) : null;
            state.global.layer2.spanningTree.enabled = document.getElementById('conf-stp-enabled').checked;
            const stpPriority = document.getElementById('conf-stp-priority').value.trim();
            state.global.layer2.spanningTree.priority = stpPriority ? parseInt(stpPriority) : null;
            
            // Router Protocols
            state.global.network.routerProtocols.rip = document.getElementById('conf-router-rip').checked;
            state.global.network.routerProtocols.ospf = document.getElementById('conf-router-ospf').checked;
            state.global.network.routerProtocols.ipv6Ospf = document.getElementById('conf-router-ipv6-ospf').checked;
            
            // Custom Config
            state.global.customConfig = document.getElementById('conf-custom').value;
            
            closeSettingsModal(); 
        }

        function renderL3List() {
            const l3List = document.getElementById('l3-interfaces-list');
            if (!l3List) return;
            l3List.innerHTML = '';
            state.routedInterfaces.forEach((int, index) => {
                const row = document.createElement('div');
                row.className = "flex gap-2 items-center bg-obsidian-pane p-2 rounded border border-obsidian-border";
                
                // VLAN Selector
                let vlanOpts = `<option value="">Select VLAN...</option>`;
                state.vlans.forEach(v => {
                    const sel = int.id === v.id ? 'selected' : '';
                    vlanOpts += `<option value="${v.id}" ${sel}>${v.name} (${v.vid})</option>`;
                });
                
                row.innerHTML = `
                    <div class="flex gap-2 items-center w-full">
                        <select onchange="updateRoutedInterface(${index}, 'id', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1">
                            ${vlanOpts}
                        </select>
                        <input type="text" value="${int.ip || ''}" placeholder="IP/CIDR (e.g. 192.168.1.1/24)" onchange="updateRoutedInterface(${index}, 'ip', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1 font-mono">
                        <button onclick="removeRoutedInterface(${index})" class="text-red-400 hover:text-red-300 text-xs px-2"><i class="fa-solid fa-trash"></i></button>
                    </div>
                    <div class="flex gap-2 items-center">
                        <input type="text" value="${int.description || ''}" placeholder="Description" onchange="updateRoutedInterface(${index}, 'description', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1">
                        <input type="text" value="${int.portName || ''}" placeholder="Port Name" onchange="updateRoutedInterface(${index}, 'portName', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1 font-mono">
                    </div>
                    <div class="flex gap-2 items-center">
                        <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                            <input type="checkbox" ${int.dhcp ? 'checked' : ''} onchange="updateRoutedInterface(${index}, 'dhcp', this.checked)" class="rounded bg-obsidian-pane border-obsidian-border"> DHCP
                        </label>
                        <label class="flex items-center gap-2 text-xs text-gray-400 cursor-pointer">
                            <input type="checkbox" ${int.shutdown ? 'checked' : ''} onchange="updateRoutedInterface(${index}, 'shutdown', this.checked)" class="rounded bg-obsidian-pane border-obsidian-border"> Shutdown
                        </label>
                    </div>
                    <div class="border-t border-white/5 pt-2 mt-2">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-[10px] text-gray-400">IP Helper Addresses (DHCP Relay)</label>
                            <button onclick="addIpHelper(${index})" class="text-[10px] bg-green-900/30 text-green-400 border border-green-900 px-2 py-0.5 rounded hover:bg-green-900/50"><i class="fa-solid fa-plus"></i> Add</button>
                        </div>
                        <div id="ip-helpers-${index}" class="space-y-1">
                            ${(int.ipHelperAddresses || []).map((helper, helperIndex) => `
                                <div class="flex gap-1 items-center">
                                    <input type="text" value="${helper}" placeholder="IP Address" onchange="updateIpHelper(${index}, ${helperIndex}, this.value)" class="bg-obsidian-pane text-white text-[10px] border border-obsidian-border rounded p-1 flex-1 font-mono">
                                    <button onclick="removeIpHelper(${index}, ${helperIndex})" class="text-red-400 hover:text-red-300 text-[10px] px-2"><i class="fa-solid fa-trash"></i></button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                row.className = "flex flex-col gap-2 bg-obsidian-pane p-3 rounded border border-obsidian-border";
                l3List.appendChild(row);
            });
        }

        function addRoutedInterface() {
            state.routedInterfaces.push({id: 'vlan-1', ip: '', description: '', portName: '', shutdown: false, dhcp: false, ipHelperAddresses: []});
            renderL3List();
        }
        
        function removeRoutedInterface(index) {
            state.routedInterfaces.splice(index, 1);
            renderL3List();
        }
        
        function updateRoutedInterface(index, field, val) {
            state.routedInterfaces[index][field] = val;
        }

        function addIpHelper(intIndex) {
            if (!state.routedInterfaces[intIndex].ipHelperAddresses) {
                state.routedInterfaces[intIndex].ipHelperAddresses = [];
            }
            state.routedInterfaces[intIndex].ipHelperAddresses.push('');
            renderL3List();
        }
        
        function removeIpHelper(intIndex, helperIndex) {
            if (state.routedInterfaces[intIndex].ipHelperAddresses) {
                state.routedInterfaces[intIndex].ipHelperAddresses.splice(helperIndex, 1);
                renderL3List();
            }
        }
        
        function updateIpHelper(intIndex, helperIndex, val) {
            if (!state.routedInterfaces[intIndex].ipHelperAddresses) {
                state.routedInterfaces[intIndex].ipHelperAddresses = [];
            }
            state.routedInterfaces[intIndex].ipHelperAddresses[helperIndex] = val.trim();
        }

        function renderStaticRoutesList() {
            const routesList = document.getElementById('static-routes-list');
            if (!routesList) return;
            routesList.innerHTML = '';
            
            if (!state.global.network || !state.global.network.staticRoutes || state.global.network.staticRoutes.length === 0) {
                routesList.innerHTML = '<div class="text-xs text-gray-500 italic p-2">No static routes configured</div>';
                return;
            }
            
            state.global.network.staticRoutes.forEach((route, index) => {
                const row = document.createElement('div');
                row.innerHTML = `
                    <div class="flex gap-2 items-center">
                        <input type="text" value="${route.network || ''}" placeholder="Network (e.g. 0.0.0.0)" onchange="updateStaticRoute(${index}, 'network', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1 font-mono">
                        <input type="text" value="${route.mask || ''}" placeholder="Mask (e.g. 0.0.0.0)" onchange="updateStaticRoute(${index}, 'mask', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1 font-mono">
                        <input type="text" value="${route.gateway || ''}" placeholder="Gateway" onchange="updateStaticRoute(${index}, 'gateway', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1 font-mono">
                        <button onclick="removeStaticRoute(${index})" class="text-red-400 hover:text-red-300 text-xs px-2"><i class="fa-solid fa-trash"></i></button>
                    </div>
                `;
                row.className = "flex flex-col gap-2 bg-obsidian-pane p-3 rounded border border-obsidian-border";
                routesList.appendChild(row);
            });
        }

        function addStaticRoute() {
            if (!state.global.network) state.global.network = { gateway: '', dns: [], domainName: '', defaultNetwork: null, staticRoutes: [], routerProtocols: { rip: false, ospf: false, ipv6Ospf: false }, ipRouting: false };
            if (!state.global.network.staticRoutes) state.global.network.staticRoutes = [];
            state.global.network.staticRoutes.push({ network: '', mask: '', gateway: '' });
            renderStaticRoutesList();
        }
        
        function removeStaticRoute(index) {
            if (state.global.network && state.global.network.staticRoutes) {
                state.global.network.staticRoutes.splice(index, 1);
                renderStaticRoutesList();
            }
        }
        
        function updateStaticRoute(index, field, val) {
            if (state.global.network && state.global.network.staticRoutes && state.global.network.staticRoutes[index]) {
                state.global.network.staticRoutes[index][field] = val.trim();
            }
        }

        function renderNtpServersList() {
            const ntpList = document.getElementById('ntp-servers-list');
            if (!ntpList) return;
            ntpList.innerHTML = '';
            
            if (!state.global.time || !state.global.time.ntp || state.global.time.ntp.length === 0) {
                ntpList.innerHTML = '<div class="text-xs text-gray-500 italic p-2">No NTP servers configured</div>';
                return;
            }
            
            state.global.time.ntp.forEach((ntp, index) => {
                const row = document.createElement('div');
                row.innerHTML = `
                    <div class="flex gap-2 items-center">
                        <input type="text" value="${ntp.server || ''}" placeholder="NTP Server (e.g. pool.ntp.org)" onchange="updateNtpServer(${index}, 'server', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1 font-mono">
                        <button onclick="removeNtpServer(${index})" class="text-red-400 hover:text-red-300 text-xs px-2"><i class="fa-solid fa-trash"></i></button>
                    </div>
                `;
                row.className = "flex flex-col gap-2 bg-obsidian-pane p-3 rounded border border-obsidian-border";
                ntpList.appendChild(row);
            });
        }

        function addNtpServer() {
            if (!state.global.time) state.global.time = { timezone: null, daylightTime: null, ntp: [], sntp: { interval: null, unicastClient: false, servers: [] } };
            if (!state.global.time.ntp) state.global.time.ntp = [];
            state.global.time.ntp.push({ server: '', priority: null, disableServe: false });
            renderNtpServersList();
        }
        
        function removeNtpServer(index) {
            if (state.global.time && state.global.time.ntp) {
                state.global.time.ntp.splice(index, 1);
                renderNtpServersList();
            }
        }
        
        function updateNtpServer(index, field, val) {
            if (state.global.time && state.global.time.ntp && state.global.time.ntp[index]) {
                state.global.time.ntp[index][field] = val.trim();
            }
        }

        function renderSnmpCommunitiesList() {
            const snmpList = document.getElementById('snmp-communities-list');
            if (!snmpList) return;
            snmpList.innerHTML = '';
            
            if (!state.global.snmp || !state.global.snmp.communities || state.global.snmp.communities.length === 0) {
                snmpList.innerHTML = '<div class="text-xs text-gray-500 italic p-2">No SNMP communities configured</div>';
                return;
            }
            
            state.global.snmp.communities.forEach((comm, index) => {
                const row = document.createElement('div');
                row.className = "flex flex-col gap-2 bg-obsidian-pane p-3 rounded border border-obsidian-border";
                
                const accessLabels = {
                    'ro': 'Read-Only (RO)',
                    'rw': 'Read-Write (RW)',
                    'operator': 'Operator',
                    'unrestricted': 'Unrestricted'
                };
                
                row.innerHTML = `
                    <div class="flex gap-2 items-center w-full">
                        <input type="text" value="${comm.community || ''}" placeholder="Community string" onchange="updateSnmpCommunity(${index}, 'community', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1 flex-1 font-mono">
                        <select onchange="updateSnmpCommunity(${index}, 'access', this.value)" class="bg-obsidian-pane text-white text-xs border border-obsidian-border rounded p-1">
                            <option value="ro" ${comm.access === 'ro' ? 'selected' : ''}>Read-Only (RO)</option>
                            <option value="rw" ${comm.access === 'rw' ? 'selected' : ''}>Read-Write (RW)</option>
                            <option value="operator" ${comm.access === 'operator' ? 'selected' : ''}>Operator</option>
                            <option value="unrestricted" ${comm.access === 'unrestricted' ? 'selected' : ''}>Unrestricted</option>
                        </select>
                        <button onclick="removeSnmpCommunity(${index})" class="text-red-400 hover:text-red-300 text-xs px-2"><i class="fa-solid fa-trash"></i></button>
                    </div>
                    <div class="text-[10px] text-gray-500">
                        Access Level: <span class="text-gray-400">${accessLabels[comm.access] || comm.access}</span>
                    </div>
                `;
                snmpList.appendChild(row);
            });
        }
        
        function addSnmpCommunity() {
            if (!state.global.snmp) state.global.snmp = { location: '', contact: '', sysname: '', communities: [], enableVlan: null, hosts: [], users: [] };
            if (!state.global.snmp.communities) state.global.snmp.communities = [];
            state.global.snmp.communities.push({ community: '', access: 'ro' });
            renderSnmpCommunitiesList();
        }
        
        function removeSnmpCommunity(index) {
            if (state.global.snmp && state.global.snmp.communities) {
                state.global.snmp.communities.splice(index, 1);
                renderSnmpCommunitiesList();
            }
        }
        
        function updateSnmpCommunity(index, field, value) {
            if (state.global.snmp && state.global.snmp.communities && state.global.snmp.communities[index]) {
                state.global.snmp.communities[index][field] = value;
            }
        }

        function downloadJson() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
            const dl = document.createElement('a'); dl.href = dataStr; dl.download = "switch_config.json"; dl.click();
        }
        function triggerImport() { document.getElementById('json-input').click(); }
        
        function importJson(input) {
            const file = input.files[0]; 
            if(!file) return;
            const r = new FileReader();
            r.onload = e => { 
                try { 
                    const loaded = JSON.parse(e.target.result); 
                    state = loaded;
                    // Ensure basic structure exists with new consolidated format
                    if (!state.global) state.global = { 
                        hostname: '',
                        network: { gateway: '', dns: [], domainName: '', defaultNetwork: null, staticRoutes: [], routerProtocols: { rip: false, ospf: false, ipv6Ospf: false }, ipRouting: false },
                        time: { timezone: null, daylightTime: null, ntp: [], sntp: { interval: null, unicastClient: false, servers: [] } },
                        management: { web: { http: true, httpPort: null, https: false, httpsPort: null, ssl: false }, remote: { ssh: null, sshTimeout: null, sshVrf: null, telnet: null, consoleTimeout: null, serialTimeout: null, cliTimeout: null }, managerRegistrar: null, flashTimeout: null },
                        snmp: { location: '', contact: '', sysname: '', communities: [], enableVlan: null, hosts: [], users: [] },
                        authentication: { users: [], passwords: { manager: null, operator: null }, aaa: { login: null, webServer: null, snmpServer: null } },
                        layer2: { igmp: { enabled: false, snooping: false, querier: { enabled: false, queryInterval: null } }, spanningTree: { enabled: false, mode: null, priority: null, systemMax: null, trapErrantBpdu: false, bpduProtectionTimeout: null }, loopProtect: { disableTimer: null, trapLoopDetected: false }, voiceVlan: null },
                        qos: { classOfService: { dot1pMapping: [], ipDscpMapping: [], trust: null }, cosQueue: { strict: [] } },
                        services: { restInterface: null, restconf: null, arubaCentral: null, tftpServer: null, tftpBlocksize: null, dhcpConfigFileUpdate: null, dhcpImageFileUpdate: null, dhcpTr69AcsUrl: null, provision: null, keepalive: null, syslogServer: null },
                        stack: { member: null },
                        customConfig: ''
                    };
                    if (!state.vlans || !Array.isArray(state.vlans)) {
                        state.vlans = [{ 
                            id: 'vlan-1', name: 'Default', vid: 1, color: '#64748b',
                            ip: '', ipHelperAddresses: [], noIpAddress: false, routingInstance: null,
                            igmp: { enabled: false, querier: false, fastLeave: false, reportSuppression: false },
                            qos: { priority: '' }, voice: false, stp: { mode: null, priority: null }
                        }];
                    }
                    if (!state.lags || !Array.isArray(state.lags)) state.lags = [];
                    if (!state.ports) state.ports = {};
                    if (!state.routedInterfaces || !Array.isArray(state.routedInterfaces)) {
                        state.routedInterfaces = [{ id: 'vlan-1', ip: '', description: '', portName: '', shutdown: false, dhcp: false, ipHelperAddresses: [] }];
                    }
                    init(); 
                    alert('Configuration loaded successfully!'); 
                } catch(e){
                    alert('Error loading JSON: ' + e.message); 
                } 
            };
            r.readAsText(file); 
            input.value = '';
        }

        function openImporterModal() { document.getElementById('importer-modal').classList.remove('hidden'); }
        function closeImporterModal() { document.getElementById('importer-modal').classList.add('hidden'); }
        
        // --- Helper Functions for Parsing ---
        function expandPortRanges(rangeStr) {
            // Expands "1-4,6,8-10" to [1,2,3,4,6,8,9,10]
            const ports = [];
            const parts = rangeStr.split(',');
            parts.forEach(part => {
                part = part.trim();
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(n => parseInt(n.trim()));
                    for (let i = start; i <= end; i++) ports.push(i);
                } else {
                    ports.push(parseInt(part));
                }
            });
            return ports.sort((a, b) => a - b);
        }
        
        function condensePortRanges(portArray) {
            // Condenses [1,2,3,4,6,8,9,10] to "1-4,6,8-10"
            if (!portArray || portArray.length === 0) return '';
            const sorted = [...new Set(portArray)].map(p => parseInt(p)).sort((a, b) => a - b);
            const ranges = [];
            let start = sorted[0];
            let end = sorted[0];
            
            for (let i = 1; i < sorted.length; i++) {
                if (sorted[i] === end + 1) {
                    end = sorted[i];
                } else {
                    if (start === end) {
                        ranges.push(start.toString());
                    } else {
                        ranges.push(`${start}-${end}`);
                    }
                    start = sorted[i];
                    end = sorted[i];
                }
            }
            // Add the last range
            if (start === end) {
                ranges.push(start.toString());
            } else {
                ranges.push(`${start}-${end}`);
            }
            return ranges.join(',');
        }

        function parseIpWithMask(ipStr, maskStr) {
            // Converts IP and mask to CIDR format
            if (!ipStr) return '';
            if (maskStr) {
                const maskParts = maskStr.split('.');
                let cidr = 0;
                maskParts.forEach(octet => {
                    const bin = parseInt(octet).toString(2);
                    cidr += (bin.match(/1/g) || []).length;
                });
                return `${ipStr}/${cidr}`;
            }
            return ipStr;
        }

        function findMaxPort(configText) {
            // Find the highest port number to determine switch size
            const portPatterns = [
                /interface\s+ethernet\s+1\/g(\d+)/gi,  // Dell: interface ethernet 1/g24
                /interface\s+(\d+)\s*$/gim,            // HP: interface 48
                /interface\s+ethernet\s+1\/\d+\/(\d+)/gi, // Ruckus: interface ethernet 1/X/Y (all modules)
                /interface\s+1\/0\/(\d+)/gi             // Netgear: interface 1/0/48
            ];
            let maxPort = 0;
            portPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(configText)) !== null) {
                    const port = parseInt(match[1]);
                    if (port > maxPort) maxPort = port;
                }
            });
            
            // For Ruckus, calculate sequential port numbers based on actual module port counts
            const modulePorts = {}; // Track max port per module: {1: 48, 2: 2, 3: 4}
            const ruckusVlanPortPattern = /(?:ethe|ethernet)\s+1\/(\d+)\/(\d+)/gi;
            let vlanMatch;
            while ((vlanMatch = ruckusVlanPortPattern.exec(configText)) !== null) {
                const module = parseInt(vlanMatch[1]);
                const port = parseInt(vlanMatch[2]);
                if (!modulePorts[module] || port > modulePorts[module]) {
                    modulePorts[module] = port;
                }
            }
            
            // Calculate total sequential ports
            let totalPorts = 0;
            const sortedModules = Object.keys(modulePorts).map(m => parseInt(m)).sort((a, b) => a - b);
            sortedModules.forEach(module => {
                totalPorts += modulePorts[module];
            });
            if (totalPorts > maxPort) maxPort = totalPorts;
            
            return maxPort;
        }
        
        // Cache for module port counts (calculated during parsing) - vendor-agnostic
        let modulePortCounts = {};
        
        function calculateRuckusModulePorts(configText) {
            // Parse module declarations from stack unit section to get actual port counts
            // This is Ruckus-specific parsing, but the data structure is vendor-agnostic
            modulePortCounts = {};
            
            // Pattern: module 1 icx7150-24p-poe-port-management-module
            // Pattern: module 2 icx7150-2-copper-port-2g-module
            // Pattern: module 3 icx7150-4-sfp-plus-port-40g-module
            // Extract port count from module name (e.g., "24p" = 24 ports, "2-copper" = 2 ports, "4-sfp" = 4 ports)
            const modulePattern = /module\s+(\d+)\s+icx[^\s]*-(\d+)(?:p|-copper|-sfp)/gi;
            let match;
            while ((match = modulePattern.exec(configText)) !== null) {
                const module = parseInt(match[1]);
                const portCount = parseInt(match[2]);
                modulePortCounts[module] = portCount;
            }
            
            // Fallback: if module declarations not found, scan for ports in use
            if (Object.keys(modulePortCounts).length === 0) {
                const ruckusPortPattern = /(?:ethe|ethernet|interface\s+ethernet)\s+1\/(\d+)\/(\d+)/gi;
                let portMatch;
                while ((portMatch = ruckusPortPattern.exec(configText)) !== null) {
                    const module = parseInt(portMatch[1]);
                    const port = parseInt(portMatch[2]);
                    if (!modulePortCounts[module] || port > modulePortCounts[module]) {
                        modulePortCounts[module] = port;
                    }
                }
            }
        }
        
        function ruckusPortToNumber(module, port) {
            // Convert Ruckus module/port format (1/X/Y) to sequential port number
            // Module 1 ports 1-24 = ports 1-24
            // Module 2 ports 1-2 = ports 25-26
            // Module 3 ports 1-4 = ports 27-30
            let offset = 0;
            const sortedModules = Object.keys(modulePortCounts).map(m => parseInt(m)).sort((a, b) => a - b);
            for (const mod of sortedModules) {
                if (mod < module) {
                    offset += modulePortCounts[mod];
                } else {
                    break;
                }
            }
            return offset + port;
        }
        
        function getModuleForPort(portNum) {
            // Determine which module/group a sequential port number belongs to (vendor-agnostic)
            let currentPort = 0;
            const sortedModules = Object.keys(modulePortCounts).map(m => parseInt(m)).sort((a, b) => a - b);
            for (const mod of sortedModules) {
                const modulePortCount = modulePortCounts[mod];
                if (portNum <= currentPort + modulePortCount) {
                    return mod;
                }
                currentPort += modulePortCount;
            }
            return null;
        }

        function setPortCountFromMax(maxPort) {
            // Set portCount to the actual maximum port number found
            // This allows for switches with any number of ports (e.g., 54, 52, etc.)
            if (maxPort > 0) {
                state.portCount = maxPort;
            } else {
                state.portCount = 24; // Default fallback
            }
        }

        // --- Vendor-Specific Parsers ---
        function parseDellConfig(configText) {
            // Reset state
            state.vlans = [];
            state.ports = {};
            state.routedInterfaces = [];
            
            // Global Settings
            const hostnameMatch = configText.match(/hostname\s+"([^"]+)"/i);
            if (hostnameMatch) state.global.hostname = hostnameMatch[1];
            
            const gatewayMatch = configText.match(/ip\s+default-gateway\s+(\S+)/i);
            if (gatewayMatch) state.global.network.gateway = gatewayMatch[1];
            
            const ipMatch = configText.match(/ip\s+address\s+(\S+)\s+(\S+)/i);
            if (ipMatch) {
                const cidr = parseIpWithMask(ipMatch[1], ipMatch[2]);
                state.routedInterfaces.push({ id: 'vlan-1', ip: cidr, description: '', portName: '', shutdown: false, dhcp: false, ipHelperAddresses: [] });
            }
            
            // SNMP
            const snmpContactMatch = configText.match(/snmp-server\s+contact\s+"([^"]+)"/i);
            if (snmpContactMatch) state.global.snmp.contact = snmpContactMatch[1];
            
            // SNMP communities
            const snmpCommunityMatches = configText.matchAll(/snmp-server\s+community\s+(\S+)\s+(\S+)(?:\s+(\S+))?/gi);
            const seenCommunities = new Set();
            for (const match of snmpCommunityMatches) {
                const community = match[1];
                // Skip duplicates
                if (seenCommunities.has(community)) continue;
                seenCommunities.add(community);
                state.global.snmp.communities.push({
                    community: community,
                    access: match[2] === 'rw' ? 'rw' : 'ro',
                    index: state.global.snmp.communities.length
                });
            }
            
            // SNMP hosts
            const snmpHostMatches = configText.matchAll(/snmp-server\s+host\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/gi);
            for (const match of snmpHostMatches) {
                state.global.snmp.hosts.push({
                    host: match[1],
                    community: match[2],
                    type: match[3], // 'traps'
                    version: match[4] // 'v2'
                });
            }
            
            // Username entries
            const usernameMatches = configText.matchAll(/username\s+"([^"]+)"\s+password\s+(\S+)\s+level\s+(\d+)\s+encrypted/gi);
            for (const match of usernameMatches) {
                if (!state.global.authentication) state.global.authentication = { users: [], passwords: { manager: null, operator: null }, aaa: { login: null, webServer: null, snmpServer: null } };
                if (!state.global.authentication.users) state.global.authentication.users = [];
                state.global.authentication.users.push({
                    username: match[1],
                    password: match[2],
                    level: parseInt(match[3]),
                    encrypted: true
                });
            }
            
            // SNTP
            if (configText.match(/sntp\s+unicast\s+client\s+enable/i)) {
                state.global.time.sntp.unicastClient = true;
            }
            const sntpServerMatch = configText.match(/sntp\s+server\s+(\S+)/i);
            if (sntpServerMatch) state.global.time.sntp.servers.push({ server: sntpServerMatch[1], priority: null });
            
            // Clock summer-time (daylight saving time)
            const summerTimeMatch = configText.match(/clock\s+summer-time\s+recurring\s+USA\s+zone\s+"([^"]+)"/i);
            if (summerTimeMatch) {
                state.global.time.daylightTime = true;
            }
            
            // Timezone
            const tzMatch = configText.match(/clock\s+timezone\s+(-?\d+)\s+minutes\s+\d+\s+zone\s+"([^"]+)"/i);
            if (tzMatch) {
                const offset = parseInt(tzMatch[1]);
                if (offset === -6) state.global.time.timezone = 'us central';
                else if (offset === -5) state.global.time.timezone = 'us eastern';
                else if (offset === -8) state.global.time.timezone = 'us pacific';
                else if (offset === -7) state.global.time.timezone = 'us mountain';
            }
            
            // Stack
            const stackMatch = configText.match(/stack\s+member\s+(\d+)\s+(\d+)/i);
            if (stackMatch) state.global.stack.member = { unit: parseInt(stackMatch[1]), member: parseInt(stackMatch[2]) };
            
            // Global STP
            if (configText.match(/no\s+spanning-tree/i)) {
                state.global.layer2.spanningTree.enabled = false;
            }
            
            // Global Voice VLAN
            if (configText.match(/^voice\s+vlan$/m)) {
                state.global.layer2.voiceVlan = 100; // Default, will be updated from port configs
            }
            
            // QoS
            const dot1pMatch = configText.match(/classofservice\s+dot1p-mapping\s+(\d+)\s+(\d+)/i);
            if (dot1pMatch) {
                state.global.qos.classOfService.dot1pMapping.push({ dot1p: parseInt(dot1pMatch[1]), queue: parseInt(dot1pMatch[2]) });
            }
            const dscpMatch = configText.match(/classofservice\s+ip-dscp-mapping\s+(\d+)\s+(\d+)/i);
            if (dscpMatch) {
                state.global.qos.classOfService.ipDscpMapping.push({ dscp: parseInt(dscpMatch[1]), queue: parseInt(dscpMatch[2]) });
            }
            const trustMatch = configText.match(/classofservice\s+trust\s+(\S+)/i);
            if (trustMatch) state.global.qos.classOfService.trust = trustMatch[1];
            const cosQueueMatch = configText.match(/cos-queue\s+strict\s+(\d+)/i);
            if (cosQueueMatch) state.global.qos.cosQueue.strict.push(parseInt(cosQueueMatch[1]));
            
            // VLANs
            const vlanDbMatch = configText.match(/vlan\s+database\s+([\s\S]*?)exit/i);
            if (vlanDbMatch) {
                const vlanList = vlanDbMatch[1].match(/vlan\s+([\d,\-\s]+)/i);
                if (vlanList) {
                    const vlanIds = expandPortRanges(vlanList[1].replace(/\s+/g, ''));
                    vlanIds.forEach(vid => {
                        const vlanNameMatch = configText.match(new RegExp(`interface\\s+vlan\\s+${vid}\\s+name\\s+"([^"]+)"`, 'i'));
                        const name = vlanNameMatch ? vlanNameMatch[1] : `VLAN ${vid}`;
                        const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6,'0')}`;
                        state.vlans.push({
                            id: `vlan-${vid}`,
                            name: name,
                            vid: vid,
                            color: color,
                            ip: '',
                            ipHelperAddresses: [],
                            noIpAddress: false,
                            routingInstance: null,
                            igmp: { enabled: false, querier: false, fastLeave: false, reportSuppression: false },
                            qos: { priority: '' },
                            voice: false,
                            stp: { mode: null, priority: null }
                        });
                    });
                }
            }
            
            // Port Configurations
            const portMatches = configText.matchAll(/interface\s+ethernet\s+1\/g(\d+)([\s\S]*?)exit/gi);
            for (const match of portMatches) {
                const portNum = parseInt(match[1]);
                const portConfig = match[2];
                
                if (!state.ports[portNum]) {
                    state.ports[portNum] = {
                        nativeVlanId: null,
                        taggedVlans: [],
                        excludedVlans: [],
                        customLabel: null,
                        portMode: null,
                        poe: { enabled: undefined, priority: null },
                        lagId: null,
                        loopProtect: { enabled: false, action: null },
                        bpduProtection: true,
                        stp: { edgePort: false, pt2ptMac: false, portfast: false },
                        voice: { vlanId: null, lldpMed: null },
                        routing: null,
                        trunkNativeVlan: null,
                        shutdown: false,
                        mtu: null,
                        speed: null,
                        duplex: null,
                        autoNegotiate: null,
                        lldp: { transmitTlv: [], transmitMgmt: false },
                        keepalive: null,
                        vlanParticipationAuto: null,
                        ptp: null
                    };
                }
                const port = state.ports[portNum];
                
                // Portfast
                if (portConfig.match(/spanning-tree\s+portfast/i)) {
                    port.stp.portfast = true;
                }
                
                // PVID (Native VLAN)
                const pvidMatch = portConfig.match(/switchport\s+general\s+pvid\s+(\d+)/i);
                if (pvidMatch) {
                    const vid = parseInt(pvidMatch[1]);
                    const vlan = state.vlans.find(v => v.vid === vid);
                    if (vlan) port.nativeVlanId = vlan.id;
                }
                
                // Tagged VLANs (general mode) - can have multiple lines
                const taggedMatches = portConfig.matchAll(/switchport\s+general\s+allowed\s+vlan\s+add\s+([\d,\-\s]+)\s+tagged/gi);
                for (const match of taggedMatches) {
                    const vlanIds = expandPortRanges(match[1].replace(/\s+/g, ''));
                    vlanIds.forEach(vid => {
                        const vlan = state.vlans.find(v => v.vid === vid);
                        if (vlan && port.taggedVlans.indexOf(vlan.id) === -1) {
                            port.taggedVlans.push(vlan.id);
                        }
                    });
                }
                
                // Tagged VLANs (trunk mode)
                const trunkTaggedMatches = portConfig.matchAll(/switchport\s+trunk\s+allowed\s+vlan\s+add\s+([\d,\-\s]+)/gi);
                for (const match of trunkTaggedMatches) {
                    const vlanIds = expandPortRanges(match[1].replace(/\s+/g, ''));
                    vlanIds.forEach(vid => {
                        const vlan = state.vlans.find(v => v.vid === vid);
                        if (vlan && port.taggedVlans.indexOf(vlan.id) === -1) {
                            port.taggedVlans.push(vlan.id);
                        }
                    });
                }
                
                // Excluded VLANs
                const excludeMatch = portConfig.match(/switchport\s+general\s+allowed\s+vlan\s+remove\s+(\d+)/i);
                if (excludeMatch) {
                    port.excludedVlans.push(parseInt(excludeMatch[1]));
                }
                
                // Voice VLAN
                const voiceMatch = portConfig.match(/voice\s+vlan\s+(\d+)/i);
                if (voiceMatch) {
                    port.voice.vlanId = parseInt(voiceMatch[1]);
                }
                
                // LLDP settings
                const lldpTlvMatch = portConfig.match(/lldp\s+transmit-tlv\s+(.+?)(?:\s+lldp|\s+voice|\s+exit|$)/i);
                if (lldpTlvMatch) {
                    // Split by spaces to get individual TLV values (e.g., "port-desc sys-name")
                    const tlvValues = lldpTlvMatch[1].trim().split(/\s+/);
                    tlvValues.forEach(tlv => {
                        if (port.lldp.transmitTlv.indexOf(tlv) === -1) {
                            port.lldp.transmitTlv.push(tlv);
                        }
                    });
                }
                if (portConfig.match(/lldp\s+transmit-mgmt/i)) {
                    port.lldp.transmitMgmt = true;
                }
                
                // Port mode
                if (portConfig.match(/switchport\s+mode\s+trunk/i)) {
                    port.portMode = 'trunk';
                } else if (portConfig.match(/switchport\s+mode\s+general/i)) {
                    port.portMode = 'general';
                }
            }
            
            // SNMP Communities
            const snmpCommMatches = configText.matchAll(/snmp-server\s+community\s+([^\s]+)\s+(\S+)/gi);
            for (const match of snmpCommMatches) {
                const community = match[1].replace(/["']/g, '');
                const access = match[2].toLowerCase();
                state.global.snmp.communities.push({ community: community, access: access === 'rw' ? 'rw' : 'ro' });
            }
            
            // Determine port count
            const maxPort = findMaxPort(configText);
            if (maxPort > 0) setPortCountFromMax(maxPort);
        }

        function parseNetgearConfig(configText) {
            // Reset state
            state.vlans = [];
            state.ports = {};
            state.routedInterfaces = [];
            
            // Initialize layer2 if not exists
            if (!state.global.layer2) {
                state.global.layer2 = { 
                    igmp: { enabled: false, snooping: false, querier: { enabled: false, queryInterval: null } }, 
                    spanningTree: { enabled: false, mode: null, priority: null, systemMax: null, trapErrantBpdu: false, bpduProtectionTimeout: null }, 
                    loopProtect: { disableTimer: null, trapLoopDetected: false }, 
                    voiceVlan: null 
                };
            }
            
            // Global Settings
            const hostnameMatch = configText.match(/hostname\s+"([^"]+)"/i);
            if (hostnameMatch) state.global.hostname = hostnameMatch[1];
            
            const gatewayMatch = configText.match(/ip\s+default-gateway\s+(\S+)/i);
            if (gatewayMatch) state.global.network.gateway = gatewayMatch[1];
            
            // DNS
            const dnsMatches = configText.matchAll(/ip\s+dns\s+server-address\s+([\d\.\s]+)/gi);
            for (const match of dnsMatches) {
                const dnsServers = match[1].trim().split(/\s+/);
                dnsServers.forEach(server => {
                    if (server && !state.global.network.dns.includes(server)) {
                        state.global.network.dns.push(server);
                    }
                });
            }
            
            // IP Routing
            if (configText.match(/no\s+ip\s+routing/i)) {
                state.global.network.ipRouting = false;
            } else if (configText.match(/ip\s+routing/i)) {
                state.global.network.ipRouting = true;
            }
            
            // HTTP/HTTPS Ports
            const httpPortMatch = configText.match(/ip\s+http\s+port\s+(\d+)/i);
            if (httpPortMatch) state.global.management.web.httpPort = parseInt(httpPortMatch[1]);
            const httpsPortMatch = configText.match(/ip\s+http\s+secure-port\s+(\d+)/i);
            if (httpsPortMatch) state.global.management.web.httpsPort = parseInt(httpsPortMatch[1]);
            
            // SSH
            if (configText.match(/ip\s+ssh\s+server\s+enable/i)) {
                state.global.management.remote.ssh = true;
            }
            const sshTimeoutMatch = configText.match(/sshcon\s+timeout\s+(\d+)/i);
            if (sshTimeoutMatch) state.global.management.remote.sshTimeout = parseInt(sshTimeoutMatch[1]);
            
            // Telnet
            if (configText.match(/no\s+ip\s+telnet\s+server\s+enable/i)) {
                state.global.management.remote.telnet = false;
            }
            
            // Timezone
            const tzMatch = configText.match(/clock\s+timezone\s+(-?\d+)\s+minutes\s+\d+\s+zone\s+"([^"]+)"/i);
            if (tzMatch) {
                const offset = parseInt(tzMatch[1]);
                if (offset === -6) state.global.time.timezone = 'us central';
                else if (offset === -5) state.global.time.timezone = 'us eastern';
                else if (offset === -8) state.global.time.timezone = 'us pacific';
                else if (offset === -7) state.global.time.timezone = 'us mountain';
            }
            
            // Clock summer-time (daylight saving time)
            if (configText.match(/clock\s+summer-time\s+recurring\s+USA\s+offset\s+60/i)) {
                state.global.time.daylightTime = true;
            }
            
            // Serial timeout (console timeout)
            const serialTimeoutMatch = configText.match(/serial\s+timeout\s+(\d+)/i);
            if (serialTimeoutMatch) state.global.management.remote.consoleTimeout = parseInt(serialTimeoutMatch[1]);
            
            // SNTP
            if (configText.match(/sntp\s+unicast-client\s+enable/i)) {
                state.global.time.sntp.unicastClient = true;
            }
            const sntpIntervalMatch = configText.match(/sntp\s+interval\s+(\d+)/i);
            if (sntpIntervalMatch) state.global.time.sntp.interval = parseInt(sntpIntervalMatch[1]);
            const sntpServerMatches = configText.matchAll(/sntp\s+server\s+(\S+)/gi);
            for (const match of sntpServerMatches) {
                state.global.time.sntp.servers.push({ server: match[1], priority: null });
            }
            
            // SNMP
            const snmpSysnameMatch = configText.match(/snmp-server\s+sysname\s+"([^"]+)"/i);
            if (snmpSysnameMatch) state.global.snmp.sysname = snmpSysnameMatch[1];
            const snmpLocationMatch = configText.match(/snmp-server\s+location\s+"([^"]+)"/i);
            if (snmpLocationMatch) state.global.snmp.location = snmpLocationMatch[1];
            const snmpContactMatch = configText.match(/snmp-server\s+contact\s+"([^"]+)"/i);
            if (snmpContactMatch) state.global.snmp.contact = snmpContactMatch[1];
            const snmpCommMatch = configText.match(/snmp-server\s+community\s+"([^"]+)"/i);
            if (snmpCommMatch) state.global.snmp.communities.push({ community: snmpCommMatch[1], access: 'ro' });
            
            // Stack
            const stackMatch = configText.match(/stack\s+member\s+(\d+)\s+(\d+)/i);
            if (stackMatch) state.global.stack.member = { unit: parseInt(stackMatch[1]), member: parseInt(stackMatch[2]) };
            
            // Global IGMP Snooping
            if (configText.match(/ip\s+igmp\s+snooping/i)) {
                state.global.layer2.igmp.snooping = true;
            }
            
            // Global Keepalive
            if (configText.match(/^keepalive$/m)) {
                if (!state.global.services) state.global.services = {};
                state.global.services.keepalive = true;
            }
            
            // IGMP Querier (global)
            const igmpQuerierMatch = configText.match(/set\s+igmp\s+querier\s+query-interval\s+(\d+)/i);
            if (igmpQuerierMatch) {
                state.global.layer2.igmp.querier.enabled = true;
                state.global.layer2.igmp.querier.queryInterval = parseInt(igmpQuerierMatch[1]);
            }
            
            // Router Protocols
            if (configText.match(/router\s+rip/i)) state.global.network.routerProtocols.rip = true;
            if (configText.match(/router\s+ospf/i)) state.global.network.routerProtocols.ospf = true;
            if (configText.match(/ipv6\s+router\s+ospf/i)) state.global.network.routerProtocols.ipv6Ospf = true;
            
            // IP Routes - parse into staticRoutes array
            const routeMatches = configText.matchAll(/ip\s+route\s+(\S+)\s+(\S+)\s+(\S+)/gi);
            for (const match of routeMatches) {
                state.global.network.staticRoutes.push({
                    network: match[1],
                    mask: match[2],
                    gateway: match[3]
                });
            }
            
            // QoS - Class of Service mappings
            const dscpMatches = configText.matchAll(/classofservice\s+ip-dscp-mapping\s+(\d+)\s+(\d+)/gi);
            for (const match of dscpMatches) {
                if (!state.global.qos.classOfService.ipDscpMapping) {
                    state.global.qos.classOfService.ipDscpMapping = [];
                }
                state.global.qos.classOfService.ipDscpMapping.push({
                    dscp: parseInt(match[1]),
                    queue: parseInt(match[2])
                });
            }
            
            // QoS - COS Queue strict
            const cosQueueMatch = configText.match(/cos-queue\s+strict\s+([\d\s]+)/i);
            if (cosQueueMatch) {
                const queues = cosQueueMatch[1].trim().split(/\s+/).map(q => parseInt(q));
                state.global.qos.cosQueue.strict = queues;
            }
            
            // VLANs
            const vlanDbMatch = configText.match(/vlan\s+database\s+([\s\S]*?)exit/i);
            if (vlanDbMatch) {
                const vlanList = vlanDbMatch[1].match(/vlan\s+([\d,\-\s]+)/i);
                if (vlanList) {
                    const vlanIds = expandPortRanges(vlanList[1].replace(/\s+/g, ''));
                    vlanIds.forEach(vid => {
                        const vlanNameMatch = configText.match(new RegExp(`vlan\\s+name\\s+${vid}\\s+"([^"]+)"`, 'i'));
                        const name = vlanNameMatch ? vlanNameMatch[1] : `VLAN ${vid}`;
                        const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6,'0')}`;
                        
                        // Check for IGMP-plus
                        const igmpPlus = configText.match(new RegExp(`set\\s+igmp-plus\\s+${vid}`, 'i'));
                        
                        // Check for routing instance
                        const routingMatch = configText.match(new RegExp(`vlan\\s+routing\\s+${vid}\\s+(\\d+)`, 'i'));
                        
                        state.vlans.push({
                            id: `vlan-${vid}`,
                            name: name,
                            vid: vid,
                            color: color,
                            ip: '',
                            ipHelperAddresses: [],
                            noIpAddress: false,
                            routingInstance: routingMatch ? parseInt(routingMatch[1]) : null,
                            igmp: { 
                                enabled: !!igmpPlus, 
                                querier: false, 
                                fastLeave: false, 
                                reportSuppression: false 
                            },
                            qos: { priority: '' },
                            voice: false,
                            stp: { mode: null, priority: null }
                        });
                    });
                }
            }
            
            // Routed Interfaces
            const vlanInterfaceMatches = configText.matchAll(/interface\s+vlan\s+(\d+)([\s\S]*?)exit/gi);
            for (const match of vlanInterfaceMatches) {
                const vid = parseInt(match[1]);
                const intConfig = match[2];
                const vlan = state.vlans.find(v => v.vid === vid);
                
                if (vlan) {
                    // Check for routing command
                    if (intConfig.match(/^\s*routing\s*$/m)) {
                        // Mark that this VLAN interface has routing enabled
                        // This is used for generation
                    }
                    
                    const dhcpMatch = intConfig.match(/ip\s+address\s+dhcp/i);
                    const ipMatch = intConfig.match(/ip\s+address\s+(\S+)\s+(\S+)/i);
                    
                    if (dhcpMatch) {
                        vlan.ip = 'dhcp';
                        state.routedInterfaces.push({ 
                            id: vlan.id, 
                            ip: 'dhcp', 
                            description: '', 
                            portName: '', 
                            shutdown: false, 
                            dhcp: true, 
                            ipHelperAddresses: [] 
                        });
                    } else if (ipMatch) {
                        const cidr = parseIpWithMask(ipMatch[1], ipMatch[2]);
                        vlan.ip = cidr;
                        state.routedInterfaces.push({ 
                            id: vlan.id, 
                            ip: cidr, 
                            description: '', 
                            portName: '', 
                            shutdown: false, 
                            dhcp: false, 
                            ipHelperAddresses: [] 
                        });
                    }
                    
                    // IGMP Snooping settings on VLAN interface
                    if (!vlan.igmp) vlan.igmp = { enabled: false, querier: false, fastLeave: false, reportSuppression: false };
                    
                    if (intConfig.match(/ip\s+igmp\s+snooping\s+enable/i)) {
                        vlan.igmp.enabled = true;
                    }
                    if (intConfig.match(/ip\s+igmp\s+snooping\s+querier/i)) {
                        vlan.igmp.querier = true;
                    }
                    if (intConfig.match(/ip\s+igmp\s+snooping\s+fast-leave/i)) {
                        vlan.igmp.fastLeave = true;
                    }
                    if (intConfig.match(/ip\s+igmp\s+snooping\s+report-suppression/i)) {
                        vlan.igmp.reportSuppression = true;
                    }
                }
            }
            
            // Port Configurations
            const portMatches = configText.matchAll(/interface\s+1\/0\/(\d+)([\s\S]*?)exit/gi);
            for (const match of portMatches) {
                const portNum = parseInt(match[1]);
                const portConfig = match[2];
                
                if (!state.ports[portNum]) {
                    state.ports[portNum] = {
                        nativeVlanId: null,
                        taggedVlans: [],
                        excludedVlans: [],
                        customLabel: null,
                        portMode: null,
                        poe: { enabled: undefined, priority: null },
                        lagId: null,
                        loopProtect: { enabled: false, action: null },
                        bpduProtection: true,
                        stp: { edgePort: false, pt2ptMac: false, portfast: false },
                        voice: { vlanId: null, lldpMed: null },
                        routing: null,
                        trunkNativeVlan: null,
                        shutdown: false,
                        mtu: null,
                        speed: null,
                        duplex: null,
                        autoNegotiate: null,
                        lldp: { transmitTlv: [], transmitMgmt: false },
                        keepalive: null,
                        vlanParticipationAuto: null,
                        ptp: null
                    };
                }
                const port = state.ports[portNum];
                
                // Description
                const descMatch = portConfig.match(/description\s+'([^']+)'/i);
                if (descMatch) port.customLabel = descMatch[1];
                
                // PVID (Native VLAN) - set first, but may be overridden by participation include logic
                const pvidMatch = portConfig.match(/vlan\s+pvid\s+(\d+)/i);
                if (pvidMatch) {
                    const vid = parseInt(pvidMatch[1]);
                    const vlan = state.vlans.find(v => v.vid === vid);
                    if (vlan) port.nativeVlanId = vlan.id;
                }
                
                // VLAN participation include - determines which VLANs the port participates in
                const includeMatch = portConfig.match(/vlan\s+participation\s+include\s+([\d,\-\s]+)/i);
                let includedVlanIds = [];
                if (includeMatch) {
                    includedVlanIds = expandPortRanges(includeMatch[1].replace(/\s+/g, ''));
                }
                
                // Tagged VLANs
                const taggedMatch = portConfig.match(/vlan\s+tagging\s+([\d,\-\s]+)/i);
                let taggedVlanIds = [];
                if (taggedMatch) {
                    taggedVlanIds = expandPortRanges(taggedMatch[1].replace(/\s+/g, ''));
                    taggedVlanIds.forEach(vid => {
                        const vlan = state.vlans.find(v => v.vid === vid);
                        if (vlan && port.taggedVlans.indexOf(vlan.id) === -1) {
                            port.taggedVlans.push(vlan.id);
                        }
                    });
                }
                
                // If we have participation include but no PVID set, determine native VLAN
                // Native VLAN is the one in include list but not in tagging list
                if (includedVlanIds.length > 0 && !pvidMatch) {
                    // Find VLANs that are included but not tagged
                    const untaggedVlans = includedVlanIds.filter(vid => !taggedVlanIds.includes(vid));
                    if (untaggedVlans.length > 0) {
                        // Use the first untagged VLAN as native
                        const nativeVid = untaggedVlans[0];
                        const vlan = state.vlans.find(v => v.vid === nativeVid);
                        if (vlan) port.nativeVlanId = vlan.id;
                    }
                }
                
                // Excluded VLANs
                const excludeMatch = portConfig.match(/vlan\s+participation\s+exclude\s+(\d+)/i);
                if (excludeMatch) {
                    port.excludedVlans.push(parseInt(excludeMatch[1]));
                }
                
                // Keepalive
                if (portConfig.match(/keepalive\s+action\s+both/i)) {
                    port.keepalive = 'both';
                }
                
                // VLAN participation auto
                if (portConfig.match(/vlan\s+participation\s+auto\s+1/i)) {
                    port.vlanParticipationAuto = 1;
                }
                
                // PTP
                if (portConfig.match(/ptp\s+clock\s+e2e-transparent/i)) {
                    port.ptp = 'e2e-transparent';
                }
                
                // Speed/Duplex
                const speedMatch = portConfig.match(/speed\s+(\d+)\s+(\S+)/i);
                if (speedMatch) {
                    port.speed = parseInt(speedMatch[1]);
                    port.duplex = speedMatch[2];
                }
                
                // Auto-negotiate
                if (portConfig.match(/no\s+auto-negotiate/i)) {
                    port.autoNegotiate = false;
                }
                
                // MTU
                const mtuMatch = portConfig.match(/mtu\s+(\d+)/i);
                if (mtuMatch) port.mtu = parseInt(mtuMatch[1]);
            }
                
                // LAGs
            const lagMatches = configText.matchAll(/interface\s+lag\s+(\d+)([\s\S]*?)exit/gi);
            for (const match of lagMatches) {
                const lagId = parseInt(match[1]);
                const lagConfig = match[2];
                
                // Create LAG entry if it doesn't exist
                let lag = state.lags.find(l => l.id === lagId);
                if (!lag) {
                    lag = { 
                        id: lagId, 
                        name: `LAG ${lagId}`, 
                        type: 'lacp',
                        stpPriority: null,
                        uplink: false,
                        nativeVlanId: null,
                        taggedVlanIds: []  // Store tagged VLAN IDs directly on LAG
                    };
                    state.lags.push(lag);
                }
                
                // Parse LAG VLAN participation include
                const lagIncludeMatch = lagConfig.match(/vlan\s+participation\s+include\s+([\d,\-\s]+)/i);
                let lagIncludedVlanIds = [];
                if (lagIncludeMatch) {
                    lagIncludedVlanIds = expandPortRanges(lagIncludeMatch[1].replace(/\s+/g, ''));
                }
                
                // Parse LAG VLAN tagging
                const lagTaggedMatch = lagConfig.match(/vlan\s+tagging\s+([\d,\-\s]+)/i);
                let lagTaggedVlanIds = [];
                if (lagTaggedMatch) {
                    lagTaggedVlanIds = expandPortRanges(lagTaggedMatch[1].replace(/\s+/g, ''));
                    // Store tagged VLAN IDs on the LAG object
                    lag.taggedVlanIds = lagTaggedVlanIds.map(vid => {
                        const vlan = state.vlans.find(v => v.vid === vid);
                        return vlan ? vlan.id : null;
                    }).filter(id => id !== null);
                }
                
                // Determine if this is an uplink LAG (one untagged, multiple tagged)
                if (lagIncludedVlanIds.length > 0 && lagTaggedVlanIds.length > 0) {
                    const untaggedVlans = lagIncludedVlanIds.filter(vid => !lagTaggedVlanIds.includes(vid));
                    if (untaggedVlans.length === 1 && lagTaggedVlanIds.length > 0) {
                        // This looks like an uplink: one native VLAN, others tagged
                        lag.uplink = true;
                        const nativeVid = untaggedVlans[0];
                        const nativeVlan = state.vlans.find(v => v.vid === nativeVid);
                        if (nativeVlan) lag.nativeVlanId = nativeVlan.id;
                    } else if (untaggedVlans.length === 0 && lagTaggedVlanIds.length > 0) {
                        // All VLANs are tagged (no native VLAN)
                        lag.nativeVlanId = null;
                    }
                }
                
                // Try to find member ports by looking for ports with LAG configuration
                // In Netgear, LAG members might be configured elsewhere, but we'll try to infer
                // by looking for ports that reference this LAG
                // Note: This might not always work as LAG members may not be in running config
            }
            
            // Determine port count
            // For Netgear, parse system description to find copper port count
            // System description format: "M4300-52G-PoE+ ProSAFE 48-port 1G PoE+ and 2-port 10GBASE-T and 2-port 10G SFP+"
            const sysDescMatch = configText.match(/System Description\s+"[^"]*"/i);
            if (sysDescMatch) {
                const sysDesc = sysDescMatch[0];
                // Look for the main copper port count (e.g., "48-port 1G" indicates 48 copper PoE+ ports)
                const copperPortMatch = sysDesc.match(/(\d+)-port\s+1G/i);
                if (copperPortMatch) {
                    const copperPorts = parseInt(copperPortMatch[1]);
                    state.portCount = copperPorts;
                } else {
                    // Fallback: use max port found
                    const maxPort = findMaxPort(configText);
                    if (maxPort > 0) setPortCountFromMax(maxPort);
                }
            } else {
                // No system description, use max port found
                const maxPort = findMaxPort(configText);
                if (maxPort > 0) setPortCountFromMax(maxPort);
            }
        }

        function parseHPConfig(configText) {
            // Reset state
            state.vlans = [];
            state.ports = {};
            state.routedInterfaces = [];
            
            // Global Settings
            const hostnameMatch = configText.match(/hostname\s+"([^"]+)"/i);
            if (hostnameMatch) state.global.hostname = hostnameMatch[1];
            
            const gatewayMatch = configText.match(/ip\s+default-gateway\s+(\S+)/i);
            if (gatewayMatch) state.global.network.gateway = gatewayMatch[1];
            
            // Timezone
            const tzMatch = configText.match(/time\s+timezone\s+(-?\d+)/i);
            if (tzMatch) {
                const offset = parseInt(tzMatch[1]);
                if (offset === -360) state.global.time.timezone = 'us central';
                else if (offset === -300) state.global.time.timezone = 'us eastern';
                else if (offset === -480) state.global.time.timezone = 'us pacific';
                else if (offset === -420) state.global.time.timezone = 'us mountain';
            }
            
            // SNTP
            if (configText.match(/sntp\s+unicast/i)) {
                state.global.time.sntp.unicastClient = true;
            }
            const sntpServerMatches = configText.matchAll(/sntp\s+server\s+priority\s+(\d+)\s+(\S+)/gi);
            for (const match of sntpServerMatches) {
                state.global.time.sntp.servers.push({ server: match[2], priority: parseInt(match[1]) });
            }
            
            // Telnet
            if (configText.match(/no\s+telnet-server/i)) {
                state.global.management.remote.telnet = false;
            }
            
            // Console timeout
            const consoleTimeoutMatch = configText.match(/console\s+idle-timeout\s+(\d+)/i);
            if (consoleTimeoutMatch) state.global.management.remote.consoleTimeout = parseInt(consoleTimeoutMatch[1]);
            
            // SNMP - Parse all communities (including those without access level)
            // Pattern: snmp-server community "string" [operator|manager] [unrestricted]
            const snmpCommLines = configText.split('\n').filter(line => line.match(/snmp-server\s+community/i));
            snmpCommLines.forEach(line => {
                // Match: snmp-server community "community_string" [access_level] [unrestricted]
                const match = line.match(/snmp-server\s+community\s+"([^"]+)"(?:\s+(\S+))?(?:\s+(\S+))?/i);
                if (match) {
                    const community = match[1];
                    let access = 'ro'; // Default to read-only
                    
                    if (match[2]) {
                        if (match[2].toLowerCase() === 'operator') {
                            access = match[3] && match[3].toLowerCase() === 'unrestricted' ? 'unrestricted' : 'operator';
                        } else if (match[2].toLowerCase() === 'manager') {
                            access = 'rw';
                        } else if (match[2].toLowerCase() === 'unrestricted') {
                            access = 'unrestricted';
                        }
                    }
                    
                    state.global.snmp.communities.push({ community: community, access: access });
                }
            });
            
            // SNMP Contact and Location (can be on same line or separate)
            const snmpContactLocationMatch = configText.match(/snmp-server\s+contact\s+"([^"]+)"\s+location\s+"([^"]+)"/i);
            if (snmpContactLocationMatch) {
                state.global.snmp.contact = snmpContactLocationMatch[1];
                state.global.snmp.location = snmpContactLocationMatch[2];
            } else {
                const snmpContactMatch = configText.match(/snmp-server\s+contact\s+"([^"]+)"/i);
                if (snmpContactMatch) state.global.snmp.contact = snmpContactMatch[1];
                const snmpLocationMatch = configText.match(/snmp-server\s+location\s+"([^"]+)"/i);
                if (snmpLocationMatch) state.global.snmp.location = snmpLocationMatch[1];
            }
            
            // Global STP
            if (configText.match(/spanning-tree$/m)) {
                state.global.layer2.spanningTree.enabled = true;
            }
            const stpTrapMatch = configText.match(/spanning-tree\s+trap\s+errant-bpdu/i);
            if (stpTrapMatch) state.global.layer2.spanningTree.trapErrantBpdu = true;
            const stpTimeoutMatch = configText.match(/spanning-tree\s+bpdu-protection-timeout\s+(\d+)/i);
            if (stpTimeoutMatch) state.global.layer2.spanningTree.bpduProtectionTimeout = parseInt(stpTimeoutMatch[1]);
            
            // Loop Protect
            const loopProtectMatch = configText.match(/loop-protect\s+([\d,\-\s]+)/i);
            if (loopProtectMatch) {
                const ports = expandPortRanges(loopProtectMatch[1].replace(/\s+/g, ''));
                ports.forEach(portNum => {
                    if (!state.ports[portNum]) {
                        state.ports[portNum] = {
                            nativeVlanId: null,
                            taggedVlans: [],
                            excludedVlans: [],
                            customLabel: null,
                            portMode: null,
                            poe: { enabled: undefined, priority: null },
                            lagId: null,
                            loopProtect: { enabled: true, action: null },
                            bpduProtection: true,
                            stp: { edgePort: false, pt2ptMac: false, portfast: false },
                            voice: { vlanId: null, lldpMed: null },
                            routing: null,
                            trunkNativeVlan: null,
                            shutdown: false,
                            mtu: null,
                            speed: null,
                            duplex: null,
                            autoNegotiate: null,
                            lldp: { transmitTlv: [], transmitMgmt: false },
                            keepalive: null,
                            vlanParticipationAuto: null,
                            ptp: null
                        };
                    } else {
                        state.ports[portNum].loopProtect.enabled = true;
                    }
                });
            }
            const loopProtectTimerMatch = configText.match(/loop-protect\s+disable-timer\s+(\d+)/i);
            if (loopProtectTimerMatch) state.global.layer2.loopProtect.disableTimer = parseInt(loopProtectTimerMatch[1]);
            if (configText.match(/loop-protect\s+trap\s+loop-detected/i)) {
                state.global.layer2.loopProtect.trapLoopDetected = true;
            }
            
            // Services
            if (configText.match(/aruba-central\s+disable/i)) state.global.services.arubaCentral = false;
            if (configText.match(/no\s+rest-interface/i)) state.global.services.restInterface = false;
            if (configText.match(/no\s+tftp\s+server/i)) state.global.services.tftpServer = false;
            if (configText.match(/no\s+dhcp\s+config-file-update/i)) state.global.services.dhcpConfigFileUpdate = false;
            if (configText.match(/no\s+dhcp\s+image-file-update/i)) state.global.services.dhcpImageFileUpdate = false;
            if (configText.match(/no\s+dhcp\s+tr69-acs-url/i)) state.global.services.dhcpTr69AcsUrl = false;
            if (configText.match(/activate\s+provision\s+disable/i)) state.global.services.provision = false;
            
            // Console timeout serial-usb
            const consoleSerialTimeoutMatch = configText.match(/console\s+idle-timeout\s+serial-usb\s+(\d+)/i);
            if (consoleSerialTimeoutMatch) state.global.management.remote.serialTimeout = parseInt(consoleSerialTimeoutMatch[1]);
            
            // Daylight time rule
            const daylightMatch = configText.match(/time\s+daylight-time-rule\s+(\S+)/i);
            if (daylightMatch) state.global.time.daylightTime = daylightMatch[1];
            
            // Password manager/operator
            if (configText.match(/password\s+manager$/m)) state.global.authentication.passwords.manager = true;
            if (configText.match(/password\s+operator$/m)) state.global.authentication.passwords.operator = true;
            
            // LAGs - Parse trunk commands and assign ports to LAGs
            const trunkMatches = configText.matchAll(/trunk\s+([\d,\-\s]+)\s+(\S+)\s+(\S+)/gi);
            for (const match of trunkMatches) {
                const portRange = match[1];
                const lagName = match[2];
                const lagType = match[3];
                
                // Extract numeric ID from lagName (e.g., "trk1" -> "1", "Trk1" -> "1")
                const lagIdMatch = lagName.match(/(\d+)/i);
                const lagId = lagIdMatch ? lagIdMatch[1] : lagName.replace(/trk/i, '');
                
                // Create LAG if it doesn't exist (ensure lagId is string for consistency)
                const lagIdStr = String(lagId);
                let lag = state.lags.find(l => String(l.id) === lagIdStr);
                if (!lag) {
                    lag = { id: lagIdStr, name: lagName, type: lagType, stpPriority: null, uplink: false, nativeVlanId: null };
                    state.lags.push(lag);
                }
                
                // Parse STP priority for this LAG
                const stpPriorityMatch = configText.match(new RegExp(`spanning-tree\\s+${lagName}\\s+priority\\s+(\\d+)`, 'i'));
                if (stpPriorityMatch) {
                    lag.stpPriority = parseInt(stpPriorityMatch[1]);
                }
                
                // Assign ports to this LAG
                const ports = expandPortRanges(portRange.replace(/\s+/g, ''));
                ports.forEach(portNum => {
                    if (!state.ports[portNum]) {
                        state.ports[portNum] = {
                            nativeVlanId: null,
                            taggedVlans: [],
                            excludedVlans: [],
                            customLabel: null,
                            portMode: null,
                            poe: { enabled: undefined, priority: null },
                            lagId: lagIdStr,
                            loopProtect: { enabled: false, action: null },
                            bpduProtection: true,
                            stp: { edgePort: false, pt2ptMac: false, portfast: false },
                            voice: { vlanId: null, lldpMed: null },
                            routing: null,
                            trunkNativeVlan: null,
                            shutdown: false,
                            mtu: null,
                            speed: null,
                            duplex: null,
                            autoNegotiate: null,
                            lldp: { transmitTlv: [], transmitMgmt: false },
                            keepalive: null,
                            vlanParticipationAuto: null,
                            ptp: null
                        };
                    } else {
                        state.ports[portNum].lagId = lagIdStr;
                    }
                });
            }
            
            // VLANs
            const vlanMatches = configText.matchAll(/vlan\s+(\d+)([\s\S]*?)exit/gi);
            for (const match of vlanMatches) {
                const vid = parseInt(match[1]);
                const vlanConfig = match[2];
                
                const nameMatch = vlanConfig.match(/name\s+"([^"]+)"/i);
                const name = nameMatch ? nameMatch[1] : `VLAN ${vid}`;
                const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6,'0')}`;
                
                // IP Address - Must be more specific to avoid matching "qos priority 0"
                // Pattern: ip address X.X.X.X X.X.X.X (not qos priority)
                const ipMatch = vlanConfig.match(/ip\s+address\s+(\d+\.\d+\.\d+\.\d+)\s+(\d+\.\d+\.\d+\.\d+)/i);
                const noIpMatch = vlanConfig.match(/no\s+ip\s+address/i);
                const qosMatch = vlanConfig.match(/qos\s+priority\s+(\d+)/i);
                
                const vlan = {
                    id: `vlan-${vid}`,
                    name: name,
                    vid: vid,
                    color: color,
                    ip: ipMatch ? parseIpWithMask(ipMatch[1], ipMatch[2]) : '',
                    ipHelperAddresses: [],
                    noIpAddress: !!noIpMatch,
                    routingInstance: null,
                    igmp: { enabled: false, querier: false, fastLeave: false, reportSuppression: false },
                    qos: { priority: qosMatch ? qosMatch[1] : '' },
                    voice: false,
                    stp: { enabled: false, priority: null }
                };
                
                state.vlans.push(vlan);
                
                // Add routed interface if IP exists (only if valid IP address)
                if (ipMatch && ipMatch[1].match(/^\d+\.\d+\.\d+\.\d+$/)) {
                    state.routedInterfaces.push({
                        id: vlan.id,
                        ip: parseIpWithMask(ipMatch[1], ipMatch[2]),
                        description: '',
                        portName: '',
                        shutdown: false,
                        dhcp: false,
                        ipHelperAddresses: []
                    });
                }
            }
            
            // Port Configurations
            const portMatches = configText.matchAll(/interface\s+(\d+)([\s\S]*?)exit/gi);
            for (const match of portMatches) {
                const portNum = parseInt(match[1]);
                const portConfig = match[2];
                
                if (!state.ports[portNum]) {
                    state.ports[portNum] = {
                        nativeVlanId: null,
                        taggedVlans: [],
                        excludedVlans: [],
                        customLabel: null,
                        portMode: null,
                        poe: { enabled: undefined, priority: null },
                        lagId: null,
                        loopProtect: { enabled: false, action: null },
                        bpduProtection: true,
                        bpduFilter: false,
                        stp: { edgePort: false, pt2ptMac: false, portfast: false },
                        voice: { vlanId: null, lldpMed: null },
                        routing: null,
                        trunkNativeVlan: null,
                        shutdown: false,
                        mtu: null,
                        speed: null,
                        duplex: null,
                        autoNegotiate: null,
                        lldp: { transmitTlv: [], transmitMgmt: false },
                        keepalive: null,
                        vlanParticipationAuto: null,
                        ptp: null
                    };
                }
                const port = state.ports[portNum];
                
                // Port name
                const nameMatch = portConfig.match(/name\s+"([^"]+)"/i);
                if (nameMatch) port.customLabel = nameMatch[1];
                
                // BPDU Protection (from spanning-tree X bpdu-protection)
                const bpduProtMatch = configText.match(new RegExp(`spanning-tree\\s+${portNum}\\s+bpdu-protection`, 'i'));
                if (bpduProtMatch) {
                    port.bpduProtection = true;
                }
                // BPDU Filter (different from bpdu-protection)
                const bpduFilterPortMatch = configText.match(new RegExp(`spanning-tree\\s+${portNum}\\s+bpdu-filter`, 'i'));
                if (bpduFilterPortMatch) {
                    port.bpduFilter = true;
                }
            }
            
            // VLAN Port Assignments (from VLAN config blocks)
            const vlanPortMatches = configText.matchAll(/vlan\s+(\d+)([\s\S]*?)exit/gi);
            for (const match of vlanPortMatches) {
                const vid = parseInt(match[1]);
                const vlanConfig = match[2];
                const vlan = state.vlans.find(v => v.vid === vid);
                if (!vlan) continue;
                
                // Untagged ports
                const untaggedMatch = vlanConfig.match(/untagged\s+([\d,\-\s,Trk\w]+)/i);
                if (untaggedMatch) {
                    const portList = untaggedMatch[1];
                    const ports = expandPortRanges(portList.replace(/Trk\d+/gi, '').replace(/\s+/g, ''));
                    ports.forEach(portNum => {
                        if (!state.ports[portNum]) {
                            state.ports[portNum] = {
                                nativeVlanId: vlan.id,
                                taggedVlans: [],
                                excludedVlans: [],
                                customLabel: null,
                                portMode: null,
                                poe: { enabled: undefined, priority: null },
                                lagId: null,
                                loopProtect: { enabled: false, action: null },
                                bpduProtection: true,
                                stp: { edgePort: false, pt2ptMac: false, portfast: false },
                                voice: { vlanId: null, lldpMed: null },
                                routing: null,
                                trunkNativeVlan: null,
                                shutdown: false,
                                mtu: null,
                                speed: null,
                                duplex: null,
                                autoNegotiate: null,
                                lldp: { transmitTlv: [], transmitMgmt: false },
                                keepalive: null,
                                vlanParticipationAuto: null,
                                ptp: null
                            };
                        } else {
                            state.ports[portNum].nativeVlanId = vlan.id;
                        }
                    });
                }
                
                // Tagged ports
                const taggedMatch = vlanConfig.match(/tagged\s+([\d,\-\s,Trk\w]+)/i);
                if (taggedMatch) {
                    const portList = taggedMatch[1];
                    const ports = expandPortRanges(portList.replace(/Trk\d+/gi, '').replace(/\s+/g, ''));
                    ports.forEach(portNum => {
                        if (!state.ports[portNum]) {
                            state.ports[portNum] = {
                                nativeVlanId: null,
                                taggedVlans: [vlan.id],
                                excludedVlans: [],
                                customLabel: null,
                                portMode: null,
                                poe: { enabled: undefined, priority: null },
                                lagId: null,
                                loopProtect: { enabled: false, action: null },
                                bpduProtection: true,
                                stp: { edgePort: false, pt2ptMac: false, portfast: false },
                                voice: { vlanId: null, lldpMed: null },
                                routing: null,
                                trunkNativeVlan: null,
                                shutdown: false,
                                mtu: null,
                                speed: null,
                                duplex: null,
                                autoNegotiate: null,
                                lldp: { transmitTlv: [], transmitMgmt: false },
                                keepalive: null,
                                vlanParticipationAuto: null,
                                ptp: null
                            };
                        } else {
                            if (state.ports[portNum].taggedVlans.indexOf(vlan.id) === -1) {
                                state.ports[portNum].taggedVlans.push(vlan.id);
                            }
                        }
                    });
                }
                
                // No untagged (excluded ports)
                const noUntaggedMatch = vlanConfig.match(/no\s+untagged\s+([\d,\-\s]+)/i);
                if (noUntaggedMatch) {
                    const ports = expandPortRanges(noUntaggedMatch[1].replace(/\s+/g, ''));
                    ports.forEach(portNum => {
                        if (state.ports[portNum]) {
                            if (state.ports[portNum].nativeVlanId === vlan.id) {
                                state.ports[portNum].nativeVlanId = null;
                            }
                        }
                    });
                }
            }
            
            // Detect LAG uplink pattern: if a LAG is untagged on one VLAN and tagged on all others
            state.lags.forEach(lag => {
                const lagName = lag.name;
                const lagIdStr = String(lag.id);
                
                // Find VLANs where this LAG is untagged
                const untaggedVlans = state.vlans.filter(v => {
                    const vlanConfig = configText.match(new RegExp(`vlan\\s+${v.vid}([\\s\\S]*?)exit`, 'i'));
                    if (!vlanConfig) return false;
                    return vlanConfig[1].match(new RegExp(`untagged[^\\n]*${lagName}`, 'i'));
                });
                
                // Find VLANs where this LAG is tagged
                const taggedVlans = state.vlans.filter(v => {
                    const vlanConfig = configText.match(new RegExp(`vlan\\s+${v.vid}([\\s\\S]*?)exit`, 'i'));
                    if (!vlanConfig) return false;
                    return vlanConfig[1].match(new RegExp(`tagged[^\\n]*${lagName}`, 'i'));
                });
                
                // If untagged on exactly one VLAN and tagged on multiple others, it's likely an uplink
                if (untaggedVlans.length === 1 && taggedVlans.length >= 2) {
                    lag.uplink = true;
                    lag.nativeVlanId = untaggedVlans[0].id;
                }
            });
            
            // Determine port count
            const maxPort = findMaxPort(configText);
            if (maxPort > 0) setPortCountFromMax(maxPort);
        }

        function parseRuckusConfig(configText) {
            // Reset state
            state.vlans = [];
            state.ports = {};
            state.routedInterfaces = [];
            
            // Calculate Ruckus module port counts first (needed for port number conversion)
            calculateRuckusModulePorts(configText);
            
            // Global Settings
            const hostnameMatch = configText.match(/hostname\s+(\S+)/i);
            if (hostnameMatch) state.global.hostname = hostnameMatch[1];
            
            const gatewayMatch = configText.match(/ip\s+default-gateway\s+(\S+)/i);
            if (gatewayMatch) state.global.network.gateway = gatewayMatch[1];
            
            // DNS
            const dnsMatch = configText.match(/ip\s+dns\s+server-address\s+([\d\.\s]+)/i);
            if (dnsMatch) {
                const dnsServers = dnsMatch[1].trim().split(/\s+/);
                dnsServers.forEach(server => {
                    if (server && !state.global.network.dns.includes(server)) {
                        state.global.network.dns.push(server);
                    }
                });
            }
            
            // Default network
            const defaultNetMatch = configText.match(/ip\s+default-network\s+(\S+)/i);
            if (defaultNetMatch) state.global.network.defaultNetwork = defaultNetMatch[1];
            
            // Management IP Address (ip address without interface - global management IP)
            const mgmtIpMatch = configText.match(/^ip\s+address\s+(\S+)\s+(\S+)/im);
            if (mgmtIpMatch) {
                const cidr = parseIpWithMask(mgmtIpMatch[1], mgmtIpMatch[2]);
                state.global.network.managementIp = cidr;
            }
            
            // Static Route
            const routeMatch = configText.match(/ip\s+route\s+(\S+)\s+(\S+)/i);
            if (routeMatch) {
                const parts = routeMatch[1].split('/');
                state.global.network.staticRoutes.push({ 
                    network: parts[0], 
                    mask: parts[1] || '0.0.0.0', 
                    gateway: routeMatch[2] 
                });
            }
            
            // Flash timeout
            const flashTimeoutMatch = configText.match(/flash-timeout\s+(\d+)/i);
            if (flashTimeoutMatch) state.global.management.flashTimeout = parseInt(flashTimeoutMatch[1]);
            
            // IP TFTP Blocksize
            const tftpBlocksizeMatch = configText.match(/ip\s+tftp\s+blocksize\s+(\d+)/i);
            if (tftpBlocksizeMatch) state.global.management.tftpBlocksize = parseInt(tftpBlocksizeMatch[1]);
            
            // Timezone - match "clock timezone us Central" (case-insensitive, may have spaces)
            const tzMatch = configText.match(/clock\s+timezone\s+([^\n\r]+)/i);
            if (tzMatch) {
                const tz = tzMatch[1].trim().toLowerCase();
                if (tz.includes('central')) state.global.time.timezone = 'us central';
                else if (tz.includes('eastern')) state.global.time.timezone = 'us eastern';
                else if (tz.includes('pacific')) state.global.time.timezone = 'us pacific';
                else if (tz.includes('mountain')) state.global.time.timezone = 'us mountain';
                else state.global.time.timezone = tz;
            }
            
            // NTP - parse block format: ntp\n disable serve\n server X\n server Y
            // Match from "ntp" to the next "!" that's on its own line
            // Clear default NTP first
            state.global.time.ntp = [];
            // Find the ntp block - look for "ntp" at start of line, then capture until next standalone "!"
            // Use a simpler approach: find "ntp" then read lines until we hit "!"
            const ntpStartIndex = configText.search(/^ntp\s*$/m);
            if (ntpStartIndex !== -1) {
                // Find the end of the ntp block (next line that starts with "!")
                const afterNtp = configText.substring(ntpStartIndex);
                const ntpEndMatch = afterNtp.match(/^ntp\s*$\n([\s\S]*?)^\s*!/m);
                if (ntpEndMatch) {
                    const ntpBlock = ntpEndMatch[1];
                    const ntpDisableServeMatch = ntpBlock.match(/disable\s+serve/i);
                    const ntpServerMatches = ntpBlock.matchAll(/server\s+(\S+)/gi);
                    for (const match of ntpServerMatches) {
                        state.global.time.ntp.push({ 
                            server: match[1], 
                            priority: null,
                            disableServe: ntpDisableServeMatch ? true : false
                        });
                    }
                }
            }
            
            // SNMP - preserve index from Ruckus format: snmp-server community 2 $dG5vJ2dHc1BuIUBuVQ== ro
            const snmpCommMatch = configText.match(/snmp-server\s+community\s+(\d+)\s+(\S+)\s+(\S+)/i);
            if (snmpCommMatch) {
                state.global.snmp.communities.push({ 
                    index: parseInt(snmpCommMatch[1]), // Preserve original index
                    community: snmpCommMatch[2], 
                    access: snmpCommMatch[3] === 'rw' ? 'rw' : 'ro' 
                });
            }
            const snmpContactMatch = configText.match(/snmp-server\s+contact\s+(\S+)/i);
            if (snmpContactMatch) state.global.snmp.contact = snmpContactMatch[1];
            const snmpLocationMatch = configText.match(/snmp-server\s+location\s+(\S+)/i);
            if (snmpLocationMatch) state.global.snmp.location = snmpLocationMatch[1];
            const snmpVlanMatch = configText.match(/snmp-server\s+enable\s+vlan\s+(\d+)/i);
            if (snmpVlanMatch) state.global.snmp.enableVlan = parseInt(snmpVlanMatch[1]);
            
            // Web Management
            if (configText.match(/web-management\s+disable/i)) {
                state.global.management.web.http = false;
            }
            
            // SSH
            const sshTimeoutMatch = configText.match(/ip\s+ssh\s+timeout\s+(\d+)/i);
            if (sshTimeoutMatch) state.global.management.remote.sshTimeout = parseInt(sshTimeoutMatch[1]);
            
            // Telnet
            if (configText.match(/no\s+telnet\s+server/i)) {
                state.global.management.remote.telnet = false;
            }
            
            // SSH enabled (if timeout is set, SSH is enabled)
            if (configText.match(/ip\s+ssh\s+timeout/i)) {
                state.global.management.remote.ssh = true;
            }
            
            // RESTCONF
            if (configText.match(/restconf\s+enable/i)) {
                if (!state.global.services) state.global.services = {};
                state.global.services.restconf = true;
            }
            
            // CLI Timeout
            const cliTimeoutMatch = configText.match(/cli\s+timeout\s+(\d+)/i);
            if (cliTimeoutMatch) state.global.management.remote.cliTimeout = parseInt(cliTimeoutMatch[1]);
            
            // Manager Registrar
            const mgrRegMatch = configText.match(/manager\s+registrar-list\s+(\S+)\s+(\S+)/i);
            if (mgrRegMatch) {
                const mgrPortMatch = configText.match(/manager\s+port-list\s+(\d+)/i);
                state.global.management.managerRegistrar = {
                    device: mgrRegMatch[1],
                    ip: mgrRegMatch[2],
                    port: mgrPortMatch ? parseInt(mgrPortMatch[1]) : null
                };
            }
            
            // Global STP
            if (configText.match(/global-stp/i)) {
                state.global.layer2.spanningTree.enabled = true;
            }
            const stpMaxMatch = configText.match(/system-max\s+spanning-tree\s+(\d+)/i);
            if (stpMaxMatch) state.global.layer2.spanningTree.systemMax = parseInt(stpMaxMatch[1]);
            
            // VLANs - match both with and without names
            // Pattern 1: vlan X name Y by port
            const vlanMatchesWithName = configText.matchAll(/vlan\s+(\d+)\s+name\s+([^\n]+)\s+by\s+port([\s\S]*?)(?=vlan\s+\d+|!|$)/gi);
            for (const match of vlanMatchesWithName) {
                const vid = parseInt(match[1]);
                const name = match[2].trim().replace(/^"|"$/g, '');
                const vlanConfig = match[3];
                const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6,'0')}`;
                
                // Parse STP mode and priority (vendor-agnostic)
                // Ruckus: spanning-tree 802-1w (RSTP)
                // Priority can be on same line: "spanning-tree 802-1w priority 0"
                // or separate line: "spanning-tree 802-1w\n spanning-tree 802-1w priority 0"
                const stp8021wMatch = vlanConfig.match(/spanning-tree\s+802-1w/i);
                // Match priority - must include 802-1w before priority
                const stpPriorityMatch = vlanConfig.match(/spanning-tree\s+802-1w\s+priority\s+(\d+)/i);
                
                let stpMode = null;
                if (stp8021wMatch) {
                    stpMode = 'rstp'; // Ruckus uses 802.1w = RSTP
                }
                
                state.vlans.push({
                    id: `vlan-${vid}`,
                    name: name,
                    vid: vid,
                    color: color,
                    ip: '',
                    ipHelperAddresses: [],
                    noIpAddress: false,
                    routingInstance: null,
                    igmp: { enabled: false, querier: false, fastLeave: false, reportSuppression: false },
                    qos: { priority: '' },
                    voice: false,
                    stp: { 
                        mode: stpMode,
                        priority: stpPriorityMatch ? parseInt(stpPriorityMatch[1]) : null 
                    }
                });
            }
            
            // Pattern 2: vlan X by port (without name)
            const vlanMatchesWithoutName = configText.matchAll(/vlan\s+(\d+)\s+by\s+port([\s\S]*?)(?=vlan\s+\d+|!|$)/gi);
            for (const match of vlanMatchesWithoutName) {
                const vid = parseInt(match[1]);
                // Skip if already parsed (would have been in the "with name" pattern)
                if (state.vlans.find(v => v.vid === vid)) continue;
                
                const vlanConfig = match[2];
                const color = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6,'0')}`;
                
                // Parse STP mode and priority
                const stp8021wMatch = vlanConfig.match(/spanning-tree\s+802-1w/i);
                const stpPriorityMatch = vlanConfig.match(/spanning-tree\s+802-1w\s+priority\s+(\d+)/i);
                
                let stpMode = null;
                if (stp8021wMatch) {
                    stpMode = 'rstp';
                }
                
                state.vlans.push({
                    id: `vlan-${vid}`,
                    name: null, // No name
                    vid: vid,
                    color: color,
                    ip: '',
                    ipHelperAddresses: [],
                    noIpAddress: false,
                    routingInstance: null,
                    igmp: { enabled: false, querier: false, fastLeave: false, reportSuppression: false },
                    qos: { priority: '' },
                    voice: false,
                    stp: { 
                        mode: stpMode,
                        priority: stpPriorityMatch ? parseInt(stpPriorityMatch[1]) : null 
                    }
                });
            }
            
            // Routed Interfaces (VE)
            const veMatches = configText.matchAll(/interface\s+ve\s+(\d+)([\s\S]*?)(?=interface\s+ve\s+\d+|!|$)/gi);
            for (const match of veMatches) {
                const vid = parseInt(match[1]);
                const veConfig = match[2];
                const vlan = state.vlans.find(v => v.vid === vid);
                
                if (vlan) {
                    const portNameMatch = veConfig.match(/port-name\s+(\S+)/i);
                    const ipMatch = veConfig.match(/ip\s+address\s+(\S+)\s+(\S+)/i);
                    const helperMatches = veConfig.matchAll(/ip\s+helper-address\s+\d+\s+(\S+)/gi);
                    
                    const helpers = [];
                    for (const hMatch of helperMatches) {
                        helpers.push(hMatch[1]);
                    }
                    
                    // Store helpers on vlan object as well
                    if (helpers.length > 0) {
                        vlan.ipHelperAddresses = helpers;
                    }
                    
                    // Process if has IP or helpers
                    if (ipMatch || helpers.length > 0) {
                        let cidr = '';
                        if (ipMatch) {
                            cidr = parseIpWithMask(ipMatch[1], ipMatch[2]);
                            vlan.ip = cidr;
                        }
                        
                        state.routedInterfaces.push({
                            id: vlan.id,
                            ip: cidr,
                            description: '',
                            portName: portNameMatch ? portNameMatch[1] : '',
                            shutdown: false,
                            dhcp: false,
                            ipHelperAddresses: helpers
                        });
                    }
                }
            }
            
            // Port Configurations - Handle all modules (1/1/X, 1/2/X, 1/3/X, etc.)
            const portMatches = configText.matchAll(/interface\s+ethernet\s+1\/(\d+)\/(\d+)([\s\S]*?)(?=interface\s+ethernet|!|$)/gi);
            for (const match of portMatches) {
                const moduleNum = parseInt(match[1]);
                const portNumInModule = parseInt(match[2]);
                // Only count copper ports for portCount, but still map SFP ports for configuration
                const portNum = ruckusPortToNumber(moduleNum, portNumInModule);
                const portConfigText = match[3];
                
                if (!state.ports[portNum]) {
                    state.ports[portNum] = {
                        nativeVlanId: null,
                        taggedVlans: [],
                        excludedVlans: [],
                        customLabel: null,
                        portMode: null,
                        poe: { enabled: undefined, priority: null },
                        lagId: null,
                        loopProtect: { enabled: false, action: null },
                        bpduProtection: true,
                        stp: { edgePort: false, pt2ptMac: false, portfast: false },
                        voice: { vlanId: null, lldpMed: null },
                        routing: null,
                        trunkNativeVlan: null,
                        shutdown: false,
                        mtu: null,
                        speed: null,
                        duplex: null,
                        autoNegotiate: null,
                        lldp: { transmitTlv: [], transmitMgmt: false },
                        keepalive: null,
                        vlanParticipationAuto: null,
                        ptp: null,
                                                portGroup: moduleNum
                    };
                } else {
                    state.ports[portNum].portGroup = moduleNum;
                }
                const portData = state.ports[portNum];
                
                // Port name - capture full name including spaces
                const portNameMatch = portConfigText.match(/port-name\s+(.+?)(?:\s+spanning-tree|\s+voice-vlan|\s*$)/i);
                if (portNameMatch) portData.customLabel = portNameMatch[1].trim();
                
                // STP Edge Port
                if (portConfigText.match(/spanning-tree\s+802-1w\s+admin-edge-port/i)) {
                    portData.stp.edgePort = true;
                }
                
                // STP Pt2Pt MAC
                if (portConfigText.match(/spanning-tree\s+802-1w\s+admin-pt2pt-mac/i)) {
                    portData.stp.pt2ptMac = true;
                }
                
                // BPDU Guard
                if (portConfigText.match(/stp-bpdu-guard/i)) {
                    portData.bpduProtection = true;
                }
                
                // Voice VLAN
                const voiceMatch = portConfigText.match(/voice-vlan\s+(\d+)/i);
                if (voiceMatch) {
                    const vid = parseInt(voiceMatch[1]);
                    // Find the VLAN by VID and store its ID string
                    const vlan = state.vlans.find(v => v.vid === vid);
                    if (vlan) {
                        portData.voice.vlanId = vlan.id; // Store as VLAN ID string (e.g., "vlan-100")
                    } else {
                        // If VLAN not found yet, store as VID (will be converted later if VLAN is added)
                        portData.voice.vlanId = vid;
                    }
                }
            }
            
            // VLAN Port Assignments (from VLAN config blocks) - handle both with and without names
            // Pattern 1: VLANs with names
            const vlanPortMatches = configText.matchAll(/vlan\s+(\d+)\s+name\s+[^\n]+\s+by\s+port([\s\S]*?)(?=vlan\s+\d+|!|$)/gi);
            for (const match of vlanPortMatches) {
                const vid = parseInt(match[1]);
                const vlanConfig = match[2];
                const vlan = state.vlans.find(v => v.vid === vid);
                if (!vlan) continue;
                
                // Untagged ports
                const untaggedMatch = vlanConfig.match(/untagged\s+ethe\s+([^\n]+)/i);
                if (untaggedMatch) {
                    const portList = untaggedMatch[1];
                    // Parse Ruckus port format: "ethe 1/1/1 to 1/1/10 ethe 1/2/1 to 1/2/4 ethe 1/3/1 to 1/3/4"
                    // Match all module/port combinations: 1/X/Y or 1/X/Y to 1/X/Z
                    const portRanges = portList.match(/(?:ethe\s+)?1\/(\d+)\/(\d+)(?:\s+to\s+1\/(\d+)\/(\d+))?/gi);
                    if (portRanges) {
                        portRanges.forEach(range => {
                            const rangeMatch = range.match(/1\/(\d+)\/(\d+)(?:\s+to\s+1\/(\d+)\/(\d+))?/i);
                            if (rangeMatch) {
                                const startModule = parseInt(rangeMatch[1]);
                                const startPort = parseInt(rangeMatch[2]);
                                const endModule = rangeMatch[3] ? parseInt(rangeMatch[3]) : startModule;
                                const endPort = rangeMatch[4] ? parseInt(rangeMatch[4]) : startPort;
                                
                                // Handle ranges within same module or across modules
                                if (startModule === endModule) {
                                    // Same module range
                                    for (let p = startPort; p <= endPort; p++) {
                                        const portNum = ruckusPortToNumber(startModule, p);
                                        if (!state.ports[portNum]) {
                                            state.ports[portNum] = {
                                                nativeVlanId: vlan.id,
                                                taggedVlans: [],
                                                excludedVlans: [],
                                                customLabel: null,
                                                portMode: null,
                                                poe: { enabled: undefined, priority: null },
                                                lagId: null,
                                                loopProtect: { enabled: false, action: null },
                                                bpduProtection: true,
                                                stp: { edgePort: false, pt2ptMac: false, portfast: false },
                                                voice: { vlanId: null, lldpMed: null },
                                                routing: null,
                                                trunkNativeVlan: null,
                                                shutdown: false,
                                                mtu: null,
                                                speed: null,
                                                duplex: null,
                                                autoNegotiate: null,
                                                lldp: { transmitTlv: [], transmitMgmt: false },
                                                keepalive: null,
                                                vlanParticipationAuto: null,
                                                ptp: null,
                                                portGroup: startModule
                                            };
                                        } else {
                                            state.ports[portNum].nativeVlanId = vlan.id;
                                            if (!state.ports[portNum].portGroup) {
                                                state.ports[portNum].portGroup = startModule;
                                            }
                                        }
                                    }
                                } else {
                                    // Cross-module range (shouldn't happen in practice, but handle it)
                                    for (let m = startModule; m <= endModule; m++) {
                                        const portStart = (m === startModule) ? startPort : 1;
                                        const portEnd = (m === endModule) ? endPort : 48;
                                        for (let p = portStart; p <= portEnd; p++) {
                                            const portNum = ruckusPortToNumber(m, p, false);
                                            if (!state.ports[portNum]) {
                                                state.ports[portNum] = {
                                                    nativeVlanId: vlan.id,
                                                    taggedVlans: [],
                                                    excludedVlans: [],
                                                    customLabel: null,
                                                    portMode: null,
                                                    poe: { enabled: undefined, priority: null },
                                                    lagId: null,
                                                    loopProtect: { enabled: false, action: null },
                                                    bpduProtection: true,
                                                    stp: { edgePort: false, pt2ptMac: false, portfast: false },
                                                    voice: { vlanId: null, lldpMed: null },
                                                    routing: null,
                                                    trunkNativeVlan: null,
                                                    shutdown: false,
                                                    mtu: null,
                                                    speed: null,
                                                    duplex: null,
                                                    autoNegotiate: null,
                                                    lldp: { transmitTlv: [], transmitMgmt: false },
                                                    keepalive: null,
                                                    vlanParticipationAuto: null,
                                                    ptp: null,
                                                    portGroup: m
                                                };
                                            } else {
                                                state.ports[portNum].nativeVlanId = vlan.id;
                                            if (!state.ports[portNum].portGroup) {
                                                state.ports[portNum].portGroup = m;
                                            }
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                
                // Tagged ports - Handle all modules
                const taggedMatch = vlanConfig.match(/tagged\s+ethe\s+([^\n]+)/i);
                if (taggedMatch) {
                    const portList = taggedMatch[1];
                    // Parse Ruckus port format: "ethe 1/1/1 to 1/1/10 ethe 1/2/1 to 1/2/4 ethe 1/3/1 to 1/3/4"
                    const portRanges = portList.match(/(?:ethe\s+)?1\/(\d+)\/(\d+)(?:\s+to\s+1\/(\d+)\/(\d+))?/gi);
                    if (portRanges) {
                        portRanges.forEach(range => {
                            const rangeMatch = range.match(/1\/(\d+)\/(\d+)(?:\s+to\s+1\/(\d+)\/(\d+))?/i);
                            if (rangeMatch) {
                                const startModule = parseInt(rangeMatch[1]);
                                const startPort = parseInt(rangeMatch[2]);
                                const endModule = rangeMatch[3] ? parseInt(rangeMatch[3]) : startModule;
                                const endPort = rangeMatch[4] ? parseInt(rangeMatch[4]) : startPort;
                                
                                if (startModule === endModule) {
                                    // Same module range
                                    for (let p = startPort; p <= endPort; p++) {
                                        const portNum = ruckusPortToNumber(startModule, p);
                                        if (!state.ports[portNum]) {
                                            state.ports[portNum] = {
                                                nativeVlanId: null,
                                                taggedVlans: [vlan.id],
                                                excludedVlans: [],
                                                customLabel: null,
                                                portMode: null,
                                                poe: { enabled: undefined, priority: null },
                                                lagId: null,
                                                loopProtect: { enabled: false, action: null },
                                                bpduProtection: true,
                                                stp: { edgePort: false, pt2ptMac: false, portfast: false },
                                                voice: { vlanId: null, lldpMed: null },
                                                routing: null,
                                                trunkNativeVlan: null,
                                                shutdown: false,
                                                mtu: null,
                                                speed: null,
                                                duplex: null,
                                                autoNegotiate: null,
                                                lldp: { transmitTlv: [], transmitMgmt: false },
                                                keepalive: null,
                                                vlanParticipationAuto: null,
                                                ptp: null,
                                                portGroup: startModule
                                            };
                                        } else {
                                            if (state.ports[portNum].taggedVlans.indexOf(vlan.id) === -1) {
                                                state.ports[portNum].taggedVlans.push(vlan.id);
                                            }
                                            if (!state.ports[portNum].portGroup) {
                                                state.ports[portNum].portGroup = startModule;
                                            }
                                        }
                                    }
                                } else {
                                    // Cross-module range
                                    for (let m = startModule; m <= endModule; m++) {
                                        const portStart = (m === startModule) ? startPort : 1;
                                        const portEnd = (m === endModule) ? endPort : 48;
                                        for (let p = portStart; p <= portEnd; p++) {
                                            const portNum = ruckusPortToNumber(m, p);
                                            if (!state.ports[portNum]) {
                                                state.ports[portNum] = {
                                                    nativeVlanId: null,
                                                    taggedVlans: [vlan.id],
                                                    excludedVlans: [],
                                                    customLabel: null,
                                                    portMode: null,
                                                    poe: { enabled: undefined, priority: null },
                                                    lagId: null,
                                                    loopProtect: { enabled: false, action: null },
                                                    bpduProtection: true,
                                                    stp: { edgePort: false, pt2ptMac: false, portfast: false },
                                                    voice: { vlanId: null, lldpMed: null },
                                                    routing: null,
                                                    trunkNativeVlan: null,
                                                    shutdown: false,
                                                    mtu: null,
                                                    speed: null,
                                                    duplex: null,
                                                    autoNegotiate: null,
                                                    lldp: { transmitTlv: [], transmitMgmt: false },
                                                    keepalive: null,
                                                    vlanParticipationAuto: null,
                                                    ptp: null
                                                };
                                            } else {
                                                if (state.ports[portNum].taggedVlans.indexOf(vlan.id) === -1) {
                                                    state.ports[portNum].taggedVlans.push(vlan.id);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }
            
            // Pattern 2: VLANs without names - parse their port assignments
            const vlanPortMatchesNoName = configText.matchAll(/vlan\s+(\d+)\s+by\s+port([\s\S]*?)(?=vlan\s+\d+|!|$)/gi);
            for (const match of vlanPortMatchesNoName) {
                const vid = parseInt(match[1]);
                const vlanConfig = match[2];
                const vlan = state.vlans.find(v => v.vid === vid);
                if (!vlan) continue; // Skip if VLAN wasn't created (shouldn't happen, but safety check)
                
                // Untagged ports
                const untaggedMatch = vlanConfig.match(/untagged\s+ethe\s+([^\n]+)/i);
                if (untaggedMatch) {
                    const portList = untaggedMatch[1];
                    const portRanges = portList.match(/(?:ethe\s+)?1\/(\d+)\/(\d+)(?:\s+to\s+1\/(\d+)\/(\d+))?/gi);
                    if (portRanges) {
                        portRanges.forEach(range => {
                            const rangeMatch = range.match(/1\/(\d+)\/(\d+)(?:\s+to\s+1\/(\d+)\/(\d+))?/i);
                            if (rangeMatch) {
                                const startModule = parseInt(rangeMatch[1]);
                                const startPort = parseInt(rangeMatch[2]);
                                const endModule = rangeMatch[3] ? parseInt(rangeMatch[3]) : startModule;
                                const endPort = rangeMatch[4] ? parseInt(rangeMatch[4]) : startPort;
                                
                                if (startModule === endModule) {
                                    for (let p = startPort; p <= endPort; p++) {
                                        const portNum = ruckusPortToNumber(startModule, p);
                                        if (!state.ports[portNum]) {
                                            state.ports[portNum] = {
                                                nativeVlanId: vlan.id,
                                                taggedVlans: [],
                                                excludedVlans: [],
                                                customLabel: null,
                                                portMode: null,
                                                poe: { enabled: undefined, priority: null },
                                                lagId: null,
                                                loopProtect: { enabled: false, action: null },
                                                bpduProtection: true,
                                                stp: { edgePort: false, pt2ptMac: false, portfast: false },
                                                voice: { vlanId: null, lldpMed: null },
                                                routing: null,
                                                trunkNativeVlan: null,
                                                shutdown: false,
                                                mtu: null,
                                                speed: null,
                                                duplex: null,
                                                autoNegotiate: null,
                                                lldp: { transmitTlv: [], transmitMgmt: false },
                                                keepalive: null,
                                                vlanParticipationAuto: null,
                                                ptp: null,
                                                portGroup: startModule
                                            };
                                        } else {
                                            state.ports[portNum].nativeVlanId = vlan.id;
                                            if (!state.ports[portNum].portGroup) {
                                                state.ports[portNum].portGroup = startModule;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                
                // Tagged ports
                const taggedMatch = vlanConfig.match(/tagged\s+ethe\s+([^\n]+)/i);
                if (taggedMatch) {
                    const portList = taggedMatch[1];
                    const portRanges = portList.match(/(?:ethe\s+)?1\/(\d+)\/(\d+)(?:\s+to\s+1\/(\d+)\/(\d+))?/gi);
                    if (portRanges) {
                        portRanges.forEach(range => {
                            const rangeMatch = range.match(/1\/(\d+)\/(\d+)(?:\s+to\s+1\/(\d+)\/(\d+))?/i);
                            if (rangeMatch) {
                                const startModule = parseInt(rangeMatch[1]);
                                const startPort = parseInt(rangeMatch[2]);
                                const endModule = rangeMatch[3] ? parseInt(rangeMatch[3]) : startModule;
                                const endPort = rangeMatch[4] ? parseInt(rangeMatch[4]) : startPort;
                                
                                if (startModule === endModule) {
                                    for (let p = startPort; p <= endPort; p++) {
                                        const portNum = ruckusPortToNumber(startModule, p);
                                        if (!state.ports[portNum]) {
                                            state.ports[portNum] = {
                                                nativeVlanId: null,
                                                taggedVlans: [vlan.id],
                                                excludedVlans: [],
                                                customLabel: null,
                                                portMode: null,
                                                poe: { enabled: undefined, priority: null },
                                                lagId: null,
                                                loopProtect: { enabled: false, action: null },
                                                bpduProtection: true,
                                                stp: { edgePort: false, pt2ptMac: false, portfast: false },
                                                voice: { vlanId: null, lldpMed: null },
                                                routing: null,
                                                trunkNativeVlan: null,
                                                shutdown: false,
                                                mtu: null,
                                                speed: null,
                                                duplex: null,
                                                autoNegotiate: null,
                                                lldp: { transmitTlv: [], transmitMgmt: false },
                                                keepalive: null,
                                                vlanParticipationAuto: null,
                                                ptp: null,
                                                portGroup: startModule
                                            };
                                        } else {
                                            if (state.ports[portNum].taggedVlans.indexOf(vlan.id) === -1) {
                                                state.ports[portNum].taggedVlans.push(vlan.id);
                                            }
                                            if (!state.ports[portNum].portGroup) {
                                                state.ports[portNum].portGroup = startModule;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }
            
            // Determine port count - include module 1 and module 2 in main section
            // For Ruckus with modules: module 1 (24p) + module 2 (2p) = 26 ports in main section
            // Module 3 (4p) = 4 SFP ports (ports 27-30) rendered separately
            let mainSectionPortCount = 0;
            const sortedModules = Object.keys(modulePortCounts).map(m => parseInt(m)).sort((a, b) => a - b);
            
            // Calculate where SFP ports start
            // For Ruckus: Module 1 (24p) + Module 2 (2p) = main section (26 ports)
            // Module 3 (4p) = SFP section (4 ports)
            // Rule: If there are multiple modules and the last one is 4 ports, it's SFP
            // Otherwise, include all modules in main section
            if (sortedModules.length > 1) {
                const lastModule = sortedModules[sortedModules.length - 1];
                const lastModulePortCount = modulePortCounts[lastModule];
                
                // If last module has exactly 4 ports, it's likely SFP (common SFP module size)
                if (lastModulePortCount === 4) {
                    // Include all modules except the last one in main section
                    for (let i = 0; i < sortedModules.length - 1; i++) {
                        mainSectionPortCount += modulePortCounts[sortedModules[i]];
                    }
                } else {
                    // Include all modules in main section
                    sortedModules.forEach(module => {
                        mainSectionPortCount += modulePortCounts[module];
                    });
                }
            } else {
                // Single module, include it in main section
                sortedModules.forEach(module => {
                    mainSectionPortCount += modulePortCounts[module];
                });
            }
            
            if (mainSectionPortCount > 0) {
                state.portCount = mainSectionPortCount;
            } else {
                const maxPort = findMaxPort(configText);
                if (maxPort > 0) setPortCountFromMax(maxPort);
            }
            
            // Create all ports from all modules, even if they don't have configuration
            // This ensures all ports show up in the visualizer, even blank ones
            const allModules = Object.keys(modulePortCounts).map(m => parseInt(m)).sort((a, b) => a - b);
            for (const module of allModules) {
                const portCount = modulePortCounts[module];
                for (let portInModule = 1; portInModule <= portCount; portInModule++) {
                    const portNum = ruckusPortToNumber(module, portInModule);
                    if (!state.ports[portNum]) {
                        // Create blank port entry
                        state.ports[portNum] = {
                            nativeVlanId: null,
                            taggedVlans: [],
                            excludedVlans: [],
                            customLabel: null,
                            portMode: null,
                            poe: { enabled: undefined, priority: null },
                            lagId: null,
                            loopProtect: { enabled: false, action: null },
                            bpduProtection: true,
                            stp: { edgePort: false, pt2ptMac: false, portfast: false },
                            voice: { vlanId: null, lldpMed: null },
                            routing: null,
                            trunkNativeVlan: null,
                            shutdown: false,
                            mtu: null,
                            speed: null,
                            duplex: null,
                            autoNegotiate: null,
                            lldp: { transmitTlv: [], transmitMgmt: false },
                            keepalive: null,
                            vlanParticipationAuto: null,
                            ptp: null,
                            portGroup: module
                        };
                    } else {
                        // Ensure portGroup is set even if port was created from config
                        if (!state.ports[portNum].portGroup) {
                            state.ports[portNum].portGroup = module;
                        }
                    }
                }
            }
        }

        function parseAndLoadConfig() {
            const configText = document.getElementById('import-text').value.trim();
            const vendor = document.getElementById('import-vendor').value;
            
            if (!configText) {
                alert('Please paste a configuration');
                return;
            }
            
            if (!vendor) {
                alert('Please select a vendor');
                return;
            }
            
            try {
                switch(vendor) {
                    case 'dell':
                        parseDellConfig(configText);
                        break;
                    case 'netgear':
                        parseNetgearConfig(configText);
                        break;
                    case 'hp':
                        parseHPConfig(configText);
                        break;
                    case 'ruckus':
                        parseRuckusConfig(configText);
                        break;
                    default:
                        alert('Unknown vendor');
                        return;
                }
                
                // Refresh UI
                renderVlanList();
                renderLagList();
                renderAllPorts();
                updateSizeBtnLabel();
                loadSettingsToForm();
                closeImporterModal();
                alert('Configuration imported successfully!');
            } catch (error) {
                alert('Error parsing configuration: ' + error.message);
                console.error(error);
            }
        }

        function openExportModal() {
            const modal = document.getElementById('export-modal');
            const source = document.getElementById('export-area');
            const clone = source.cloneNode(true);
            clone.querySelector('#export-legend').classList.remove('hidden');
            const legend = clone.querySelector('#export-legend');
            state.vlans.forEach(v => legend.innerHTML += `<div class="flex items-center gap-2"><div class="w-4 h-4 rounded" style="background-color:${v.color}"></div><span class="text-sm">${v.name} (${v.vid})</span></div>`);
            document.getElementById('modal-content').innerHTML = '';
            document.getElementById('modal-content').appendChild(clone);
            modal.classList.remove('hidden');
        }
        function closeExportModal() { document.getElementById('export-modal').classList.add('hidden'); }

        function openCliModal() { 
            document.getElementById('cli-modal').classList.remove('hidden'); 
            generateCli(); 
        }
        
        function closeCliModal() { 
            document.getElementById('cli-modal').classList.add('hidden'); 
        }

        function generateCli() {
            const brand = document.getElementById('cli-brand').value;
            const cliOutput = document.getElementById('cli-output');
            
            let config = '';
            switch(brand) {
                case 'hp':
                    config = generateHpConfig();
                    break;
                case 'netgear':
                    config = generateNetgearConfig();
                    break;
                case 'ruckus':
                    config = generateRuckusConfig();
                    break;
                case 'dell':
                    config = generateDellConfig();
                    break;
                default:
                    config = 'Please select a vendor';
            }
            
            cliOutput.textContent = config;
        }
        
        function generateHpConfig() {
            let config = [];
            
            // Header comment
            config.push('; HP Aruba AOS-S Configuration');
            config.push('; Generated by Switch Designer');
            config.push('');
            
            // Hostname
            if (state.global.hostname) {
                config.push(`hostname "${state.global.hostname}"`);
            }
            
            // Timezone
            const timezoneMap = {
                'us central': -360,
                'us eastern': -300,
                'us pacific': -480,
                'us mountain': -420
            };
            if (state.global.time.timezone && timezoneMap[state.global.time.timezone]) {
                config.push(`time timezone ${timezoneMap[state.global.time.timezone]}`);
            }
            
            // SNTP
            if (state.global.time.sntp.unicastClient) {
                config.push('sntp unicast');
                if (state.global.time.sntp.servers && state.global.time.sntp.servers.length > 0) {
                    state.global.time.sntp.servers.forEach((server, idx) => {
                        const priority = server.priority !== null ? server.priority : (idx + 1);
                        config.push(`sntp server priority ${priority} ${server.server}`);
                    });
                }
                config.push('timesync sntp');
            }
            
            // Default Gateway
            if (state.global.network.gateway) {
                config.push(`ip default-gateway ${state.global.network.gateway}`);
            }
            
            // Console timeout
            if (state.global.management.remote.consoleTimeout) {
                config.push(`console idle-timeout ${state.global.management.remote.consoleTimeout}`);
            }
            
            // SSH
            if (state.global.management.remote.ssh === true) {
                config.push('crypto key generate ssh');
                config.push('ip ssh');
                if (state.global.management.remote.sshTimeout) {
                    config.push(`ip ssh timeout ${state.global.management.remote.sshTimeout}`);
                }
            }
            
            // Web Management SSL
            if (state.global.management.web.ssl === true) {
                config.push('web-management ssl');
            }
            
            // Telnet
            if (state.global.management.remote.telnet === false) {
                config.push('no telnet-server');
            }
            
            // Logging (Syslog)
            if (state.global.services.syslogServer) {
                config.push(`logging ${state.global.services.syslogServer}`);
            }
            
            // SNMP
            if (state.global.snmp.location || state.global.snmp.contact) {
                const contact = state.global.snmp.contact ? `"${state.global.snmp.contact}"` : '';
                const location = state.global.snmp.location ? `location "${state.global.snmp.location}"` : '';
                if (contact && location) {
                    config.push(`snmp-server contact ${contact} ${location}`);
                } else if (contact) {
                    config.push(`snmp-server contact ${contact}`);
                } else if (location) {
                    config.push(`snmp-server ${location}`);
                }
            }
            
            // SNMP Communities (deduplicate before output)
            if (state.global.snmp.communities && state.global.snmp.communities.length > 0) {
                const seenCommunities = new Set();
                state.global.snmp.communities.forEach(comm => {
                    // Skip duplicates
                    if (seenCommunities.has(comm.community)) return;
                    seenCommunities.add(comm.community);
                    const accessLevel = comm.access === 'rw' ? 'manager' : 
                                      comm.access === 'operator' ? 'operator' : 
                                      comm.access === 'unrestricted' ? 'operator unrestricted' : 
                                      'operator';
                    config.push(`snmp-server community "${comm.community}" ${accessLevel}`);
                });
            }
            
            // Interface names/descriptions
            const portNames = [];
            Object.keys(state.ports).forEach(portNum => {
                const port = state.ports[portNum];
                if (port.customLabel) {
                    portNames.push({ port: parseInt(portNum), name: port.customLabel });
                }
            });
            if (portNames.length > 0) {
                portNames.sort((a, b) => a.port - b.port);
                portNames.forEach(p => {
                    config.push(`interface ${p.port}`);
                    config.push(`   name "${p.name}"`);
                    config.push('   exit');
                });
            }
            
            // LAGs (trunk)
            if (state.lags && state.lags.length > 0) {
                state.lags.forEach(lag => {
                    // Find member ports
                    const memberPorts = [];
                    Object.keys(state.ports).forEach(portNum => {
                        if (state.ports[portNum].lagId === lag.id) {
                            memberPorts.push(parseInt(portNum));
                        }
                    });
                    if (memberPorts.length > 0) {
                        const portRange = condensePortRanges(memberPorts);
                        const lagType = lag.type === 'lacp' ? 'lacp' : 'static';
                        config.push(`trunk ${portRange} trk${lag.id} ${lagType}`);
                    }
                });
            }
            
            // VLANs (include VLAN 1 if it has IP or routing instance)
            const vlan1 = state.vlans.find(v => v.vid === 1);
            const vlansToProcess = [...state.vlans];
            // If VLAN 1 exists but isn't in the list (shouldn't happen, but just in case)
            if (vlan1 && (vlan1.ip || vlan1.routingInstance !== null) && !vlansToProcess.find(v => v.vid === 1)) {
                vlansToProcess.push(vlan1);
            }
            
            if (vlansToProcess && vlansToProcess.length > 0) {
                // Sort VLANs by VID
                const sortedVlans = [...vlansToProcess].sort((a, b) => (a.vid || 0) - (b.vid || 0));
                
                sortedVlans.forEach(vlan => {
                    config.push(`vlan ${vlan.vid}`);
                    if (vlan.name) {
                        config.push(`   name "${vlan.name}"`);
                    }
                    
                    // Collect ports for untagged and tagged
                    const untaggedPorts = [];
                    const taggedPorts = [];
                    const untaggedLags = [];
                    const taggedLags = [];
                    
                    Object.keys(state.ports).forEach(portNum => {
                        const port = state.ports[portNum];
                        const portNumInt = parseInt(portNum);
                        // Skip invalid port numbers, but include SFP ports (they may be configured)
                        if (isNaN(portNumInt) || portNumInt <= 0) return;
                        // Skip ports in LAGs (they're handled separately)
                        if (port.lagId) return;
                        
                        if (port.nativeVlanId === vlan.id) {
                            untaggedPorts.push(portNumInt);
                        }
                        if (port.taggedVlans && port.taggedVlans.includes(vlan.id)) {
                            taggedPorts.push(portNumInt);
                        }
                    });
                    
                    // Check LAGs (only include if LAG has member ports, i.e., trunk will be generated)
                    if (state.lags && state.lags.length > 0) {
                        state.lags.forEach(lag => {
                            // First check if this LAG has member ports (will generate a trunk command)
                            const memberPorts = [];
                            Object.keys(state.ports).forEach(portNum => {
                                if (state.ports[portNum].lagId === lag.id) {
                                    memberPorts.push(parseInt(portNum));
                                }
                            });
                            
                            // Only process this LAG if it has member ports
                            if (memberPorts.length > 0) {
                                if (lag.nativeVlanId === vlan.id) {
                                    untaggedLags.push(`Trk${lag.id}`);
                                } else {
                                    // Check if this VLAN is in the LAG's tagged VLAN list (stored during parsing)
                                    if (lag.taggedVlanIds && lag.taggedVlanIds.includes(vlan.id)) {
                                        taggedLags.push(`Trk${lag.id}`);
                                    }
                                    // For uplink LAGs: tag all VLANs except the native
                                    else if (lag.uplink && lag.nativeVlanId && vlan.id !== lag.nativeVlanId) {
                                        taggedLags.push(`Trk${lag.id}`);
                                    }
                                    // For LAGs with no native VLAN (all tagged), tag all VLANs
                                    else if (!lag.nativeVlanId && !lag.taggedVlanIds) {
                                        taggedLags.push(`Trk${lag.id}`);
                                    }
                                    // For non-uplink LAGs: check if any port in the LAG has this VLAN tagged
                                    else if (!lag.uplink && lag.nativeVlanId && !lag.taggedVlanIds) {
                                        // Check if any member port of this LAG has this VLAN tagged
                                        let lagHasVlanTagged = false;
                                        Object.keys(state.ports).forEach(portNum => {
                                            const portNumInt = parseInt(portNum);
                                            // Skip invalid ports, but include SFP ports
                                            if (isNaN(portNumInt) || portNumInt <= 0) return;
                                            const port = state.ports[portNum];
                                            if (port.lagId === lag.id && port.taggedVlans && port.taggedVlans.includes(vlan.id)) {
                                                lagHasVlanTagged = true;
                                            }
                                        });
                                        if (lagHasVlanTagged) {
                                            taggedLags.push(`Trk${lag.id}`);
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Build untagged line - filter out any NaN values
                    const validUntaggedPorts = untaggedPorts.filter(p => !isNaN(p) && p > 0);
                    const untaggedList = [];
                    if (validUntaggedPorts.length > 0) {
                        untaggedList.push(condensePortRanges(validUntaggedPorts));
                    }
                    untaggedLags.forEach(lag => untaggedList.push(lag));
                    if (untaggedList.length > 0) {
                        config.push(`   untagged ${untaggedList.join(',')}`);
                    } else {
                        // If no untagged ports, exclude all ports (HP uses "no untagged" to exclude)
                        // Need to determine the actual max port number (including SFP ports if present)
                        let maxPort = state.portCount;
                        Object.keys(state.ports).forEach(portNum => {
                            const portNumInt = parseInt(portNum);
                            if (!isNaN(portNumInt) && portNumInt > maxPort && !state.ports[portNum].lagId) {
                                maxPort = portNumInt;
                            }
                        });
                        config.push(`   no untagged 1-${maxPort}`);
                    }
                    
                    // Build tagged line - filter out any NaN values
                    const validTaggedPorts = taggedPorts.filter(p => !isNaN(p) && p > 0);
                    const taggedList = [];
                    if (validTaggedPorts.length > 0) {
                        taggedList.push(condensePortRanges(validTaggedPorts));
                    }
                    taggedLags.forEach(lag => taggedList.push(lag));
                    if (taggedList.length > 0) {
                        config.push(`   tagged ${taggedList.join(',')}`);
                    }
                    
                    // IP Address
                    if (vlan.ip && vlan.ip !== 'dhcp') {
                        // Parse CIDR to IP and mask
                        if (vlan.ip.includes('/')) {
                            const [ip, cidr] = vlan.ip.split('/');
                            const mask = cidrToMask(parseInt(cidr));
                            config.push(`   ip address ${ip} ${mask}`);
                        } else {
                            config.push(`   ip address ${vlan.ip}`);
                        }
                    } else if (vlan.noIpAddress) {
                        config.push('   no ip address');
                    }
                    
                    // QoS Priority
                    if (vlan.qos && vlan.qos.priority) {
                        const qosMap = { 'voice': 7, 'video': 6, 'critical': 5 };
                        const priority = qosMap[vlan.qos.priority] || vlan.qos.priority;
                        config.push(`   qos priority ${priority}`);
                    }
                    
                    // Voice VLAN
                    if (vlan.voice) {
                        config.push('   voice');
                    }
                    
                    config.push('   exit');
                });
            }
            
            // Global STP
            if (state.global.layer2.spanningTree.enabled) {
                config.push('spanning-tree');
                
                // STP Priority
                if (state.global.layer2.spanningTree.priority !== null) {
                    config.push(`spanning-tree priority ${state.global.layer2.spanningTree.priority}`);
                }
            }
            
            // BPDU Protection per port
            const bpduPorts = [];
            Object.keys(state.ports).forEach(portNum => {
                const port = state.ports[portNum];
                const portNumInt = parseInt(portNum);
                if (isNaN(portNumInt) || portNumInt > state.portCount) return; // Skip SFP and invalid ports
                if (port.bpduProtection === false) {
                    // HP uses "spanning-tree X bpdu-protection" to enable, so we skip ports where it's disabled
                } else {
                    // Default is enabled, so add to list
                    bpduPorts.push(portNumInt);
                }
            });
            if (bpduPorts.length > 0) {
                // Group consecutive ports for cleaner output
                const ranges = condensePortRanges(bpduPorts).split(',');
                ranges.forEach(range => {
                    config.push(`spanning-tree ${range} bpdu-protection`);
                });
            }
            
            // Admin Edge Port (PortFast equivalent)
            const edgePorts = [];
            Object.keys(state.ports).forEach(portNum => {
                const port = state.ports[portNum];
                const portNumInt = parseInt(portNum);
                if (isNaN(portNumInt) || portNumInt > state.portCount) return; // Skip SFP and invalid ports
                if (port.stp && port.stp.edgePort === true) {
                    edgePorts.push(portNumInt);
                }
            });
            if (edgePorts.length > 0) {
                const ranges = condensePortRanges(edgePorts).split(',');
                ranges.forEach(range => {
                    config.push(`spanning-tree ${range} admin-edge-port`);
                });
            }
            
            // LAG STP Priority
            state.lags.forEach(lag => {
                if (lag.stpPriority !== null) {
                    config.push(`spanning-tree Trk${lag.id} priority ${lag.stpPriority}`);
                }
            });
            
            // STP Trap
            if (state.global.layer2.spanningTree.trapErrantBpdu) {
                config.push('spanning-tree trap errant-bpdu');
            }
            
            // BPDU Protection Timeout
            if (state.global.layer2.spanningTree.bpduProtectionTimeout) {
                config.push(`spanning-tree bpdu-protection-timeout ${state.global.layer2.spanningTree.bpduProtectionTimeout} force-version rstp-operation`);
            }
            
            // Loop Protection
            const loopProtectPorts = [];
            Object.keys(state.ports).forEach(portNum => {
                const port = state.ports[portNum];
                const portNumInt = parseInt(portNum);
                if (isNaN(portNumInt) || portNumInt > state.portCount) return; // Skip SFP and invalid ports
                if (port.loopProtect && port.loopProtect.enabled) {
                    loopProtectPorts.push(portNumInt);
                }
            });
            if (loopProtectPorts.length > 0) {
                config.push(`loop-protect ${condensePortRanges(loopProtectPorts)}`);
            }
            
            // Loop Protect Trap
            if (state.global.layer2.loopProtect.trapLoopDetected) {
                config.push('loop-protect trap loop-detected');
            }
            
            // Loop Protect Disable Timer
            if (state.global.layer2.loopProtect.disableTimer) {
                config.push(`loop-protect disable-timer ${state.global.layer2.loopProtect.disableTimer}`);
            }
            
            // Global IGMP
            if (state.global.layer2.igmp.enabled) {
                config.push('ip igmp');
            }
            
            // Services
            if (state.global.services.arubaCentral === false) {
                config.push('aruba-central disable');
            }
            if (state.global.services.restInterface === false) {
                config.push('no rest-interface');
            }
            if (state.global.services.tftpServer === false) {
                config.push('no tftp server');
            }
            if (state.global.services.dhcpConfigFileUpdate === false) {
                config.push('no dhcp config-file-update');
            }
            if (state.global.services.dhcpImageFileUpdate === false) {
                config.push('no dhcp image-file-update');
            }
            if (state.global.services.dhcpTr69AcsUrl === false) {
                config.push('no dhcp tr69-acs-url');
            }
            if (state.global.services.provision === false) {
                config.push('activate provision disable');
            }
            
            // Console timeout serial-usb
            if (state.global.management.remote.serialTimeout) {
                config.push(`console idle-timeout serial-usb ${state.global.management.remote.serialTimeout}`);
            }
            
            // Daylight time rule
            if (state.global.time.daylightTime) {
                config.push(`time daylight-time-rule ${state.global.time.daylightTime}`);
            }
            
            // Password manager/operator
            if (state.global.authentication.passwords.manager === true) {
                config.push('password manager');
            }
            if (state.global.authentication.passwords.operator === true) {
                config.push('password operator');
            }
            
            // BPDU Filter (different from bpdu-protection)
            const bpduFilterPorts = [];
            Object.keys(state.ports).forEach(portNum => {
                const port = state.ports[portNum];
                const portNumInt = parseInt(portNum);
                if (isNaN(portNumInt) || portNumInt > state.portCount) return; // Skip SFP and invalid ports
                if (port.bpduFilter === true) {
                    bpduFilterPorts.push(portNumInt);
                }
            });
            if (bpduFilterPorts.length > 0) {
                const ranges = condensePortRanges(bpduFilterPorts).split(',');
                ranges.forEach(range => {
                    config.push(`spanning-tree ${range} bpdu-filter`);
                });
            }
            
            // Custom Config
            if (state.global.customConfig) {
                config.push('');
                config.push('; Custom Configuration');
                config.push(state.global.customConfig);
            }
            
            return config.join('\n');
        }
        
        function generateNetgearConfig() {
            let config = [];
            
            // Header comment
            config.push('! Netgear M-Series Configuration');
            config.push('! Generated by Switch Designer');
            config.push('');
            
            // Hostname
            if (state.global.hostname) {
                config.push(`hostname "${state.global.hostname}"`);
            }
            
            // Configure command (before clock commands in Netgear)
            config.push('configure');
            
            // Timezone
            const timezoneMap = {
                'us central': { offset: -6, zone: 'CST' },
                'us eastern': { offset: -5, zone: 'EST' },
                'us pacific': { offset: -8, zone: 'PST' },
                'us mountain': { offset: -7, zone: 'MST' }
            };
            if (state.global.time.timezone && timezoneMap[state.global.time.timezone]) {
                const tz = timezoneMap[state.global.time.timezone];
                config.push(`clock timezone ${tz.offset} minutes 0 zone "${tz.zone}"`);
            }
            
            // Clock summer-time (daylight saving time)
            if (state.global.time.daylightTime) {
                config.push(`clock summer-time recurring USA offset 60`);
            }
            
            // SNTP
            if (state.global.time.sntp.unicastClient) {
                config.push('sntp unicast-client enable');
                if (state.global.time.sntp.interval) {
                    config.push(`sntp interval ${state.global.time.sntp.interval}`);
                }
                if (state.global.time.sntp.servers && state.global.time.sntp.servers.length > 0) {
                    state.global.time.sntp.servers.forEach(server => {
                        config.push(`sntp server ${server.server}`);
                    });
                }
            }
            
            // HTTP/HTTPS Ports
            if (state.global.management.web.httpPort) {
                config.push(`ip http port ${state.global.management.web.httpPort}`);
            }
            if (state.global.management.web.httpsPort) {
                config.push(`ip http secure-port ${state.global.management.web.httpsPort}`);
            }
            
            // SSH
            if (state.global.management.remote.ssh === true) {
                config.push('ip ssh server enable');
                if (state.global.management.remote.sshTimeout) {
                    config.push(`sshcon timeout ${state.global.management.remote.sshTimeout}`);
                }
            }
            
            // Telnet
            if (state.global.management.remote.telnet === false) {
                config.push('no ip telnet server enable');
            }
            
            // Console timeout
            if (state.global.management.remote.consoleTimeout) {
                config.push('line console');
                config.push(`serial timeout ${state.global.management.remote.consoleTimeout}`);
                config.push('no transport input telnet');
                config.push('exit');
            }
            
            // Line telnet and ssh blocks (empty but may be needed)
            config.push('line telnet');
            config.push('exit');
            config.push('line ssh');
            config.push('exit');
            
            // SNMP
            if (state.global.snmp.sysname) {
                config.push(`snmp-server sysname "${state.global.snmp.sysname}"`);
            }
            if (state.global.snmp.location) {
                config.push(`snmp-server location "${state.global.snmp.location}"`);
            }
            if (state.global.snmp.contact) {
                config.push(`snmp-server contact "${state.global.snmp.contact}"`);
            }
            if (state.global.snmp.communities && state.global.snmp.communities.length > 0) {
                const seenCommunities = new Set();
                state.global.snmp.communities.forEach(comm => {
                    // Skip duplicates
                    if (seenCommunities.has(comm.community)) return;
                    seenCommunities.add(comm.community);
                    config.push(`snmp-server community "${comm.community}"`);
                });
            }
            
            // Stack
            if (state.global.stack.member) {
                config.push('stack');
                config.push(`member ${state.global.stack.member.unit} ${state.global.stack.member.member}`);
                config.push('exit');
            }
            
            // IP Routing
            if (state.global.network.ipRouting === false) {
                config.push('no ip routing');
            } else if (state.global.network.ipRouting === true) {
                config.push('ip routing');
            }
            
            // Default Gateway
            if (state.global.network.gateway) {
                config.push(`ip default-gateway ${state.global.network.gateway}`);
            }
            
            // DNS
            if (state.global.network.dns && state.global.network.dns.length > 0) {
                const dnsList = state.global.network.dns.join(' ');
                config.push(`ip dns server-address ${dnsList}`);
            }
            
            // Global IGMP Snooping
            if (state.global.layer2.igmp.snooping) {
                config.push('ip igmp snooping');
            }
            
            // Global IGMP Querier
            if (state.global.layer2.igmp.querier.enabled && state.global.layer2.igmp.querier.queryInterval) {
                config.push(`set igmp querier query-interval ${state.global.layer2.igmp.querier.queryInterval}`);
            }
            
            // Global Keepalive
            if (state.global.services.keepalive) {
                config.push('keepalive');
            }
            
            // QoS - Class of Service DSCP mappings
            if (state.global.qos.classOfService.ipDscpMapping && state.global.qos.classOfService.ipDscpMapping.length > 0) {
                state.global.qos.classOfService.ipDscpMapping.forEach(mapping => {
                    config.push(`classofservice ip-dscp-mapping ${mapping.dscp} ${mapping.queue}`);
                });
            }
            
            // QoS - COS Queue strict
            if (state.global.qos.cosQueue.strict && state.global.qos.cosQueue.strict.length > 0) {
                const queues = state.global.qos.cosQueue.strict.join(' ');
                config.push(`cos-queue strict ${queues}`);
            }
            
            // VLAN Database
            if (state.vlans && state.vlans.length > 0) {
                // Sort VLANs by VID
                const sortedVlans = [...state.vlans].sort((a, b) => (a.vid || 0) - (b.vid || 0));
                
                // Collect VLAN IDs for database
                const vlanIds = sortedVlans.map(v => v.vid).filter(vid => vid);
                if (vlanIds.length > 0) {
                    config.push('vlan database');
                    // Group consecutive VLANs for cleaner output
                    const vlanRanges = condensePortRanges(vlanIds);
                    config.push(`vlan ${vlanRanges}`);
                    
                    // VLAN names
                    sortedVlans.forEach(vlan => {
                        if (vlan.name) {
                            config.push(`vlan name ${vlan.vid} "${vlan.name}"`);
                        }
                    });
                    
                    // IGMP-plus (set igmp-plus)
                    sortedVlans.forEach(vlan => {
                        if (vlan.igmp && vlan.igmp.enabled) {
                            config.push(`set igmp-plus ${vlan.vid}`);
                        }
                    });
                    
                    // VLAN routing instances (including VLAN 1 if it exists)
                    // First check for VLAN 1 routing instance (might not be in sortedVlans if no IP)
                    const vlan1 = state.vlans.find(v => v.vid === 1);
                    if (vlan1 && vlan1.routingInstance !== null && vlan1.routingInstance !== undefined) {
                        config.push(`vlan routing 1 ${vlan1.routingInstance}`);
                    }
                    // Then add other VLAN routing instances
                    sortedVlans.forEach(vlan => {
                        if (vlan.vid !== 1 && vlan.routingInstance !== null && vlan.routingInstance !== undefined) {
                            config.push(`vlan routing ${vlan.vid} ${vlan.routingInstance}`);
                        }
                    });
                    
                    config.push('exit');
                    config.push('');
                }
            }
            
            // Interface VLAN (SVIs)
            if (state.vlans && state.vlans.length > 0) {
                const sortedVlans = [...state.vlans].sort((a, b) => (a.vid || 0) - (b.vid || 0));
                
                sortedVlans.forEach(vlan => {
                    // Check if this VLAN should get the management IP (if it's VLAN 15 and management IP exists)
                    let vlanIp = vlan.ip;
                    if (!vlanIp && vlan.vid === 15 && state.global.network.managementIp) {
                        vlanIp = state.global.network.managementIp;
                    }
                    
                    // Include VLAN interface if it has IP, IGMP settings, or routing instance
                    if (vlanIp || vlan.routingInstance !== null || (vlan.igmp && (vlan.igmp.enabled || vlan.igmp.querier || vlan.igmp.fastLeave || vlan.igmp.reportSuppression))) {
                        config.push(`interface vlan ${vlan.vid}`);
                        
                        // Routing command (required for Netgear when IP routing is enabled or routing instance is set)
                        if (state.global.network.ipRouting === true || vlan.routingInstance !== null) {
                            config.push('routing');
                        }
                        
                        // IP Address (use vlanIp which may include management IP for VLAN 15)
                        if (vlanIp && vlanIp !== 'dhcp') {
                            if (vlanIp.includes('/')) {
                                const [ip, cidr] = vlanIp.split('/');
                                const mask = cidrToMask(parseInt(cidr));
                                config.push(`ip address ${ip} ${mask}`);
                            } else {
                                config.push(`ip address ${vlanIp}`);
                            }
                        } else if (vlanIp === 'dhcp') {
                            config.push('ip address dhcp');
                        }
                        
                        // Shutdown
                        const routedInt = state.routedInterfaces.find(r => r.id === vlan.id);
                        if (routedInt && routedInt.shutdown) {
                            config.push('shutdown');
                        } else if (vlanIp || vlanIp === 'dhcp') {
                            // Only add no shutdown if there's an IP address
                            // Note: Original config doesn't show no shutdown, but we'll include it for clarity
                        }
                        
                        // IGMP Snooping settings
                        if (vlan.igmp) {
                            if (vlan.igmp.enabled) {
                                config.push('ip igmp snooping enable');
                            }
                            if (vlan.igmp.querier) {
                                config.push('ip igmp snooping querier');
                            }
                            if (vlan.igmp.fastLeave) {
                                config.push('ip igmp snooping fast-leave');
                            }
                            if (vlan.igmp.reportSuppression) {
                                config.push('ip igmp snooping report-suppression');
                            }
                        }
                        
                        config.push('exit');
                        config.push('');
                    }
                });
            }
            
            // Physical Interfaces (including SFP ports)
            // Netgear port mapping: For switches with 24 copper + 4 SFP, SFP ports are 25-28
            // If state has ports 27-30 (from Ruckus), map them to 25-28 for Netgear
            function mapPortToNetgear(ruckusPortNum) {
                // If portCount is 26 (24 copper + 2 extra), and we have ports 27-30, map to 25-28
                // Ruckus SFP ports 27-30 should map to Netgear SFP ports 25-28
                if (state.portCount === 26 && ruckusPortNum >= 27 && ruckusPortNum <= 30) {
                    // Map: 27->25, 28->26, 29->27, 30->28
                    return ruckusPortNum - 2;
                }
                // If portCount is 24 and we have ports 25-28, keep as is
                // Otherwise, keep original port number
                return ruckusPortNum;
            }
            
            const portConfigs = [];
            Object.keys(state.ports).forEach(portNum => {
                const port = state.ports[portNum];
                const portNumInt = parseInt(portNum);
                // Skip invalid ports and ports that are in LAGs
                // Skip ports 25-26 if they're the extra copper ports from Ruckus module 2 (when portCount is 26)
                if (isNaN(portNumInt) || port.lagId) return;
                if (state.portCount === 26 && portNumInt >= 25 && portNumInt <= 26) {
                    // Skip ports 25-26 as they're the extra copper ports that don't exist in standard Netgear layout
                    return;
                }
                
                const netgearPortNum = mapPortToNetgear(portNumInt);
                const portConfig = [];
                portConfig.push(`interface 1/0/${netgearPortNum}`);
                
                // Description
                if (port.customLabel) {
                    portConfig.push(`description '${port.customLabel}'`);
                }
                
                // Speed/Duplex (before VLAN config in original)
                if (port.speed && port.duplex) {
                    portConfig.push(`speed ${port.speed} ${port.duplex}`);
                }
                
                // Auto-negotiate (before VLAN config in original)
                if (port.autoNegotiate === false) {
                    portConfig.push('no auto-negotiate');
                }
                
                // PVID (Native VLAN)
                if (port.nativeVlanId) {
                    const nativeVlan = state.vlans.find(v => v.id === port.nativeVlanId);
                    if (nativeVlan) {
                        portConfig.push(`vlan pvid ${nativeVlan.vid}`);
                    }
                }
                
                // VLAN participation auto (before include in original)
                if (port.vlanParticipationAuto !== null && port.vlanParticipationAuto !== undefined) {
                    portConfig.push(`vlan participation auto ${port.vlanParticipationAuto}`);
                }
                
                // VLAN participation exclude (before include in original)
                if (port.excludedVlans && port.excludedVlans.length > 0) {
                    port.excludedVlans.forEach(vid => {
                        portConfig.push(`vlan participation exclude ${vid}`);
                    });
                }
                
                // VLAN participation include
                const includedVlans = [];
                if (port.nativeVlanId) {
                    const nativeVlan = state.vlans.find(v => v.id === port.nativeVlanId);
                    if (nativeVlan) includedVlans.push(nativeVlan.vid);
                }
                if (port.taggedVlans && port.taggedVlans.length > 0) {
                    port.taggedVlans.forEach(vlanId => {
                        const vlan = state.vlans.find(v => v.id === vlanId);
                        if (vlan) includedVlans.push(vlan.vid);
                    });
                }
                if (includedVlans.length > 0) {
                    const vlanRanges = condensePortRanges(includedVlans);
                    portConfig.push(`vlan participation include ${vlanRanges}`);
                }
                
                // VLAN tagging
                if (port.taggedVlans && port.taggedVlans.length > 0) {
                    const taggedVids = port.taggedVlans.map(vlanId => {
                        const vlan = state.vlans.find(v => v.id === vlanId);
                        return vlan ? vlan.vid : null;
                    }).filter(vid => vid !== null);
                    if (taggedVids.length > 0) {
                        const vlanRanges = condensePortRanges(taggedVids);
                        portConfig.push(`vlan tagging ${vlanRanges}`);
                    }
                }
                
                // Keepalive
                if (port.keepalive) {
                    portConfig.push(`keepalive action ${port.keepalive}`);
                }
                
                // MTU
                if (port.mtu) {
                    portConfig.push(`mtu ${port.mtu}`);
                }
                
                // Voice VLAN
                if (port.voice && port.voice.vlanId) {
                    // port.voice.vlanId can be either a VID (number) or VLAN ID (string like "vlan-100")
                    let voiceVlan = null;
                    if (typeof port.voice.vlanId === 'string') {
                        voiceVlan = state.vlans.find(v => v.id === port.voice.vlanId);
                    } else {
                        voiceVlan = state.vlans.find(v => v.vid === port.voice.vlanId);
                    }
                    if (voiceVlan) {
                        portConfig.push(`voice vlan ${voiceVlan.vid}`);
                    } else {
                        // If not found, assume vlanId is already a VID
                        portConfig.push(`voice vlan ${port.voice.vlanId}`);
                    }
                }
                
                // PTP
                if (port.ptp) {
                    portConfig.push(`ptp clock ${port.ptp}`);
                }
                
                portConfig.push('exit');
                portConfigs.push({ port: netgearPortNum, originalPort: portNumInt, config: portConfig });
            });
            
            // Sort ports by Netgear port number and add to config
            portConfigs.sort((a, b) => a.port - b.port);
            portConfigs.forEach(pc => {
                config.push(...pc.config);
                config.push('');
            });
                
                // LAGs
            if (state.lags && state.lags.length > 0) {
                state.lags.forEach(lag => {
                    // Find member ports
                    const memberPorts = [];
                    Object.keys(state.ports).forEach(portNum => {
                        const port = state.ports[portNum];
                        const portNumInt = parseInt(portNum);
                        if (isNaN(portNumInt) || portNumInt > state.portCount) return;
                        if (port.lagId === lag.id) {
                            memberPorts.push(portNumInt);
                        }
                    });
                    
                    if (memberPorts.length > 0) {
                        config.push(`interface lag ${lag.id}`);
                        
                        // Description
                        if (lag.name) {
                            config.push(`description '${lag.name}'`);
                        }
                        
                        // PVID (Native VLAN)
                        if (lag.nativeVlanId) {
                            const nativeVlan = state.vlans.find(v => v.id === lag.nativeVlanId);
                            if (nativeVlan) {
                                config.push(`vlan pvid ${nativeVlan.vid}`);
                            }
                        }
                        
                        // VLAN participation include
                        const includedVlans = [];
                        if (lag.nativeVlanId) {
                            const nativeVlan = state.vlans.find(v => v.id === lag.nativeVlanId);
                            if (nativeVlan) includedVlans.push(nativeVlan.vid);
                        }
                        // For uplink LAGs, tag all other VLANs
                        if (lag.uplink) {
                            state.vlans.forEach(vlan => {
                                if (vlan.id !== lag.nativeVlanId) {
                                    includedVlans.push(vlan.vid);
                                }
                            });
                        }
                        // For non-uplink LAGs, check member ports for tagged VLANs
                        else {
                            memberPorts.forEach(portNum => {
                                const port = state.ports[portNum];
                                if (port.taggedVlans && port.taggedVlans.length > 0) {
                                    port.taggedVlans.forEach(vlanId => {
                                        const vlan = state.vlans.find(v => v.id === vlanId);
                                        if (vlan && !includedVlans.includes(vlan.vid)) {
                                            includedVlans.push(vlan.vid);
                                        }
                                    });
                                }
                            });
                        }
                        if (includedVlans.length > 0) {
                            const vlanRanges = condensePortRanges(includedVlans);
                            config.push(`vlan participation include ${vlanRanges}`);
                        }
                        
                        // VLAN tagging (all included VLANs except native)
                        if (lag.nativeVlanId) {
                            const taggedVids = includedVlans.filter(vid => {
                                const nativeVlan = state.vlans.find(v => v.id === lag.nativeVlanId);
                                return nativeVlan && vid !== nativeVlan.vid;
                            });
                            if (taggedVids.length > 0) {
                                const vlanRanges = condensePortRanges(taggedVids);
                                config.push(`vlan tagging ${vlanRanges}`);
                            }
                        }
                        
                        config.push('exit');
                        config.push('');
                    }
                });
            }
            
            // Custom Config
            if (state.global.customConfig) {
                config.push('');
                config.push('! Custom Configuration');
                config.push(state.global.customConfig);
            }
            
            // Final exit command
            config.push('');
            config.push('exit');
            
            return config.join('\n');
        }
        
        function formatRuckusPortRanges(ports) {
            // Convert array of port numbers to Ruckus format: "ethe 1/1/1 to 1/1/4 ethe 1/3/1 to 1/3/4"
            // Ports are stored as simple numbers (1, 2, 3, etc.) but need to be converted to Ruckus format (1/1/1, 1/1/2, etc.)
            // Use portGroup from state.ports to determine the correct module
            if (!ports || ports.length === 0) return '';
            
            // Filter out invalid ports and sort - include SFP ports (beyond portCount)
            const validPorts = ports.filter(p => !isNaN(p) && p > 0).sort((a, b) => a - b);
            if (validPorts.length === 0) return '';
            
            // Convert port numbers to Ruckus format using portGroup to determine module
            // Need to access modulePortCounts - it's a global variable set during parsing
            const ruckusPorts = validPorts.map(portNum => {
                const port = state.ports[portNum];
                if (port && port.portGroup !== undefined && port.portGroup !== null) {
                    // Use the portGroup (module number) from the port state
                    const module = port.portGroup;
                    // Calculate port number within module by working backwards from sequential number
                    // We need to know modulePortCounts - try to get it from global scope or calculate
                    let portInModule = portNum;
                    if (typeof modulePortCounts !== 'undefined' && modulePortCounts) {
                        const sortedModules = Object.keys(modulePortCounts).map(m => parseInt(m)).sort((a, b) => a - b);
                        for (const mod of sortedModules) {
                            if (mod < module) {
                                portInModule -= modulePortCounts[mod];
                            } else {
                                break;
                            }
                        }
                    } else {
                        // Fallback: if we don't have modulePortCounts, estimate based on portCount
                        // For ICX-7150: module 1 = 24 ports, module 2 = 2 ports, module 3 = 4 ports
                        if (module === 1) {
                            portInModule = portNum;
                        } else if (module === 2) {
                            portInModule = portNum - 24;
                        } else if (module === 3) {
                            portInModule = portNum - 26; // 24 + 2
                        } else {
                            portInModule = portNum - state.portCount;
                        }
                    }
                    return `1/${module}/${portInModule}`;
                } else {
                    // Fallback: assume module 1 for ports <= portCount, module 2 for others
                    if (portNum <= state.portCount) {
                        return `1/1/${portNum}`;
                    } else {
                        const sfpNum = portNum - state.portCount;
                        return `1/2/${sfpNum}`;
                    }
                }
            });
            
            // Group into ranges - need to handle module/unit changes
            const ranges = [];
            let currentGroup = [];
            let currentModule = null;
            
            ruckusPorts.forEach(port => {
                const parts = port.split('/');
                const module = `${parts[0]}/${parts[1]}`;
                const portNum = parseInt(parts[2]);
                
                if (currentModule === null) {
                    currentModule = module;
                    currentGroup = [portNum];
                } else if (currentModule === module) {
                    // Same module, check if consecutive
                    const lastPort = currentGroup[currentGroup.length - 1];
                    if (portNum === lastPort + 1) {
                        currentGroup.push(portNum);
                    } else {
                        // Not consecutive, save current group and start new one
                        if (currentGroup.length > 0) {
                            if (currentGroup.length === 1) {
                                ranges.push({ module: currentModule, start: currentGroup[0], end: currentGroup[0] });
                            } else {
                                ranges.push({ module: currentModule, start: currentGroup[0], end: currentGroup[currentGroup.length - 1] });
                            }
                        }
                        currentGroup = [portNum];
                    }
                } else {
                    // Different module, save current group and start new one
                    if (currentGroup.length > 0) {
                        if (currentGroup.length === 1) {
                            ranges.push({ module: currentModule, start: currentGroup[0], end: currentGroup[0] });
                        } else {
                            ranges.push({ module: currentModule, start: currentGroup[0], end: currentGroup[currentGroup.length - 1] });
                        }
                    }
                    currentModule = module;
                    currentGroup = [portNum];
                }
            });
            
            // Save final group
            if (currentGroup.length > 0) {
                if (currentGroup.length === 1) {
                    ranges.push({ module: currentModule, start: currentGroup[0], end: currentGroup[0] });
                } else {
                    ranges.push({ module: currentModule, start: currentGroup[0], end: currentGroup[currentGroup.length - 1] });
                }
            }
            
            // Format ranges
            const formattedRanges = ranges.map(range => {
                if (range.start === range.end) {
                    return `ethe ${range.module}/${range.start}`;
                } else {
                    return `ethe ${range.module}/${range.start} to ${range.module}/${range.end}`;
                }
            });
            
            return formattedRanges.join(' ');
        }
        
        function generateRuckusConfig() {
            let config = [];
            
            // Header comment
            config.push('!');
            config.push('! Ruckus ICX Configuration');
            config.push('! Generated by Switch Designer');
            config.push('!');
            
            // Global STP (before VLANs)
            if (state.global.layer2.spanningTree.enabled) {
                config.push('global-stp');
                config.push('!');
            }
            
            // System-max spanning-tree
            if (state.global.layer2.spanningTree.systemMax) {
                config.push(`system-max spanning-tree ${state.global.layer2.spanningTree.systemMax}`);
                config.push('!');
            }
            
            // VLANs
            if (state.vlans && state.vlans.length > 0) {
                const sortedVlans = [...state.vlans].sort((a, b) => (a.vid || 0) - (b.vid || 0));
                
                sortedVlans.forEach(vlan => {
                    // VLAN definition - only quote if name contains spaces
                    if (vlan.name) {
                        if (vlan.name.includes(' ')) {
                            config.push(`vlan ${vlan.vid} name "${vlan.name}" by port`);
                        } else {
                            config.push(`vlan ${vlan.vid} name ${vlan.name} by port`);
                        }
                    } else {
                        config.push(`vlan ${vlan.vid} by port`);
                    }
                    
                    // Collect ports for untagged and tagged
                    const untaggedPorts = [];
                    const taggedPorts = [];
                    const untaggedLags = [];
                    const taggedLags = [];
                    
                    Object.keys(state.ports).forEach(portNum => {
                        const port = state.ports[portNum];
                        const portNumInt = parseInt(portNum);
                        // Skip invalid ports and ports in LAGs
                        if (isNaN(portNumInt) || port.lagId) return;
                        
                        // A port can't be both untagged and tagged for the same VLAN
                        if (port.nativeVlanId === vlan.id) {
                            untaggedPorts.push(portNumInt);
                        } else if (port.taggedVlans && port.taggedVlans.includes(vlan.id)) {
                            taggedPorts.push(portNumInt);
                        }
                    });
                    
                    // Check LAGs (only if they have member ports)
                    if (state.lags && state.lags.length > 0) {
                        state.lags.forEach(lag => {
                            const memberPorts = [];
                            Object.keys(state.ports).forEach(portNum => {
                                if (state.ports[portNum].lagId === lag.id) {
                                    memberPorts.push(parseInt(portNum));
                                }
                            });
                            
                            if (memberPorts.length > 0) {
                                if (lag.nativeVlanId === vlan.id) {
                                    untaggedLags.push(`lag ${lag.id}`);
                                } else if (lag.taggedVlanIds && lag.taggedVlanIds.includes(vlan.id)) {
                                    taggedLags.push(`lag ${lag.id}`);
                                } else if (lag.uplink && lag.nativeVlanId && vlan.id !== lag.nativeVlanId) {
                                    taggedLags.push(`lag ${lag.id}`);
                                } else if (!lag.nativeVlanId && !lag.taggedVlanIds) {
                                    taggedLags.push(`lag ${lag.id}`);
                                }
                            }
                        });
                    }
                    
                    // Untagged ports
                    if (untaggedPorts.length > 0 || untaggedLags.length > 0) {
                        const untaggedList = [];
                        if (untaggedPorts.length > 0) {
                            untaggedList.push(formatRuckusPortRanges(untaggedPorts));
                        }
                        untaggedLags.forEach(lag => untaggedList.push(lag));
                        config.push(` untagged ${untaggedList.join(' ')}`);
                    }
                    
                    // Tagged ports
                    if (taggedPorts.length > 0 || taggedLags.length > 0) {
                        const taggedList = [];
                        if (taggedPorts.length > 0) {
                            taggedList.push(formatRuckusPortRanges(taggedPorts));
                        }
                        taggedLags.forEach(lag => taggedList.push(lag));
                        config.push(` tagged ${taggedList.join(' ')}`);
                    }
                    
                    // Spanning-tree per VLAN
                    if (vlan.stp && vlan.stp.mode) {
                        config.push(` spanning-tree 802-1w`);
                        if (vlan.stp.priority !== null && vlan.stp.priority !== undefined) {
                            config.push(` spanning-tree 802-1w priority ${vlan.stp.priority}`);
                        }
                    }
                    
                    config.push('!');
                });
            }
            
            config.push('!');
            
            // Static Routes (after VLANs, before other network settings)
            if (state.global.network.staticRoutes && state.global.network.staticRoutes.length > 0) {
                state.global.network.staticRoutes.forEach(route => {
                    // Ruckus uses CIDR format: ip route 0.0.0.0/0 X.X.X.X
                    let network = route.network;
                    if (!network.includes('/')) {
                        // Convert mask to CIDR if needed
                        if (route.mask && route.mask !== '0.0.0.0') {
                            const cidr = maskToCidr(route.mask);
                            network = `${network}${cidr}`;
                        } else {
                            network = `${network}/0`;
                        }
                    }
                    config.push(`ip route ${network} ${route.gateway}`);
                });
                config.push('!');
            }
            
            config.push('!');
            
            // Flash timeout
            if (state.global.management.flashTimeout) {
                config.push(`flash-timeout ${state.global.management.flashTimeout}`);
            }
            
            // Hostname
            if (state.global.hostname) {
                config.push(`hostname ${state.global.hostname}`);
            }
            
            // Default network
            if (state.global.network.defaultNetwork) {
                config.push(`ip default-network ${state.global.network.defaultNetwork}`);
            }
            
            // Timezone
            const timezoneMap = {
                'us central': 'us Central',
                'us eastern': 'us Eastern',
                'us pacific': 'us Pacific',
                'us mountain': 'us Mountain'
            };
            if (state.global.time.timezone && timezoneMap[state.global.time.timezone]) {
                config.push(`clock timezone ${timezoneMap[state.global.time.timezone]}`);
            }
            
            // DNS
            if (state.global.network.dns && state.global.network.dns.length > 0) {
                const dnsList = state.global.network.dns.join(' ');
                config.push(`ip dns server-address ${dnsList}`);
            }
            
            // Management IP Address (ip address command without interface)
            if (state.global.network.managementIp) {
                const mgmtIp = state.global.network.managementIp;
                if (mgmtIp.includes('/')) {
                    const [ip, cidr] = mgmtIp.split('/');
                    const mask = cidrToMask(parseInt(cidr));
                    config.push(`ip address ${ip} ${mask}`);
                } else {
                    config.push(`ip address ${mgmtIp}`);
                }
            }
            
            // IP TFTP Blocksize
            if (state.global.management.tftpBlocksize) {
                config.push(`ip tftp blocksize ${state.global.management.tftpBlocksize}`);
            }
            
            // Default Gateway
            if (state.global.network.gateway) {
                config.push(`ip default-gateway ${state.global.network.gateway}`);
            }
            
            // NTP
            if (state.global.time.ntp && state.global.time.ntp.length > 0) {
                config.push('ntp');
                if (state.global.time.ntp.some(ntp => ntp.disableServe)) {
                    config.push(' disable serve');
                }
                state.global.time.ntp.forEach(ntp => {
                    if (ntp.server) {
                        config.push(` server ${ntp.server}`);
                    }
                });
                config.push('!');
            }
            
            config.push('!');
            
            // Interface management
            config.push('interface management 1');
            config.push('!');
            
            // Physical Interfaces
            const portConfigs = [];
            Object.keys(state.ports).forEach(portNum => {
                const port = state.ports[portNum];
                const portNumInt = parseInt(portNum);
                // Skip invalid ports and ports in LAGs
                if (isNaN(portNumInt) || port.lagId) return;
                
                // Only generate interface if it has configuration (voice-vlan, port-name, stp settings, etc.)
                const hasConfig = port.customLabel || 
                                 (port.voice && port.voice.vlanId) || 
                                 (port.stp && (port.stp.edgePort || port.stp.pt2ptMac));
                // Skip if no configuration (empty interfaces shouldn't be generated)
                if (!hasConfig) return;
                
                // Determine Ruckus port format using portGroup
                let ruckusPort;
                if (port && port.portGroup !== undefined && port.portGroup !== null) {
                    const module = port.portGroup;
                    // Calculate port number within module
                    let portInModule = portNumInt;
                    if (typeof modulePortCounts !== 'undefined' && modulePortCounts) {
                        const sortedModules = Object.keys(modulePortCounts).map(m => parseInt(m)).sort((a, b) => a - b);
                        for (const mod of sortedModules) {
                            if (mod < module) {
                                portInModule -= modulePortCounts[mod];
                            } else {
                                break;
                            }
                        }
                    } else {
                        // Fallback calculation
                        if (module === 1) {
                            portInModule = portNumInt;
                        } else if (module === 2) {
                            portInModule = portNumInt - 24;
                        } else if (module === 3) {
                            portInModule = portNumInt - 26;
                        } else {
                            portInModule = portNumInt - state.portCount;
                        }
                    }
                    ruckusPort = `1/${module}/${portInModule}`;
                } else {
                    // Fallback: assume module 1 for ports <= portCount, module 2 for others
                    if (portNumInt <= state.portCount) {
                        ruckusPort = `1/1/${portNumInt}`;
                    } else {
                        const sfpNum = portNumInt - state.portCount;
                        ruckusPort = `1/2/${sfpNum}`;
                    }
                }
                
                const portConfig = [];
                portConfig.push(`interface ethernet ${ruckusPort}`);
                
                // Port name
                if (port.customLabel) {
                    portConfig.push(` port-name ${port.customLabel}`);
                }
                
                // Voice VLAN
                if (port.voice && port.voice.vlanId) {
                    // port.voice.vlanId can be either a VID (number) or VLAN ID (string like "vlan-100")
                    // Try to find by VID first, then by ID
                    const voiceVlan = state.vlans.find(v => v.vid === port.voice.vlanId || v.id === port.voice.vlanId);
                    if (voiceVlan) {
                        portConfig.push(` voice-vlan ${voiceVlan.vid}`);
                    } else {
                        // If not found, assume vlanId is already a VID
                        portConfig.push(` voice-vlan ${port.voice.vlanId}`);
                    }
                }
                
                // Spanning-tree admin-edge-port
                if (port.stp && port.stp.edgePort) {
                    portConfig.push(` spanning-tree 802-1w admin-edge-port`);
                }
                
                // Spanning-tree admin-pt2pt-mac
                if (port.stp && port.stp.pt2ptMac) {
                    portConfig.push(` spanning-tree 802-1w admin-pt2pt-mac`);
                }
                
                portConfig.push('!');
                portConfigs.push({ port: portNumInt, config: portConfig });
            });
            
            // Sort ports and add to config
            portConfigs.sort((a, b) => a.port - b.port);
            portConfigs.forEach(pc => {
                config.push(...pc.config);
            });
            
            // LAGs (trunk) - Note: Ruckus LAGs are defined separately and referenced in VLANs as "lag X"
            if (state.lags && state.lags.length > 0) {
                state.lags.forEach(lag => {
                    const memberPorts = [];
                    Object.keys(state.ports).forEach(portNum => {
                        if (state.ports[portNum].lagId === lag.id) {
                            memberPorts.push(parseInt(portNum));
                        }
                    });
                    
                    if (memberPorts.length > 0) {
                        const lagType = lag.type === 'lacp' ? 'dynamic' : 'static';
                        config.push(`lag "${lag.name || `LAG ${lag.id}`}" ${lagType} id ${lag.id}`);
                        
                        // Format ports for LAG - need to convert to Ruckus format using portGroup
                        const ruckusPorts = memberPorts.map(portNum => {
                            const port = state.ports[portNum];
                            if (port && port.portGroup !== undefined && port.portGroup !== null) {
                                const module = port.portGroup;
                                let portInModule = portNum;
                                if (typeof modulePortCounts !== 'undefined' && modulePortCounts) {
                                    const sortedModules = Object.keys(modulePortCounts).map(m => parseInt(m)).sort((a, b) => a - b);
                                    for (const mod of sortedModules) {
                                        if (mod < module) {
                                            portInModule -= modulePortCounts[mod];
                                        } else {
                                            break;
                                        }
                                    }
                                } else {
                                    // Fallback
                                    if (module === 1) portInModule = portNum;
                                    else if (module === 2) portInModule = portNum - 24;
                                    else if (module === 3) portInModule = portNum - 26;
                                    else portInModule = portNum - state.portCount;
                                }
                                return `ethe 1/${module}/${portInModule}`;
                            } else {
                                // Fallback
                                if (portNum <= state.portCount) {
                                    return `ethe 1/1/${portNum}`;
                                } else {
                                    const sfpNum = portNum - state.portCount;
                                    return `ethe 1/2/${sfpNum}`;
                                }
                            }
                        });
                        config.push(` ports ${ruckusPorts.join(' ')}`);
                        
                        // Primary port
                        if (memberPorts.length > 0) {
                            const primaryPort = memberPorts[0];
                            const primaryPortObj = state.ports[primaryPort];
                            let primaryRuckus;
                            if (primaryPortObj && primaryPortObj.portGroup !== undefined && primaryPortObj.portGroup !== null) {
                                const module = primaryPortObj.portGroup;
                                let portInModule = primaryPort;
                                if (typeof modulePortCounts !== 'undefined' && modulePortCounts) {
                                    const sortedModules = Object.keys(modulePortCounts).map(m => parseInt(m)).sort((a, b) => a - b);
                                    for (const mod of sortedModules) {
                                        if (mod < module) {
                                            portInModule -= modulePortCounts[mod];
                                        } else {
                                            break;
                                        }
                                    }
                                } else {
                                    // Fallback
                                    if (module === 1) portInModule = primaryPort;
                                    else if (module === 2) portInModule = primaryPort - 24;
                                    else if (module === 3) portInModule = primaryPort - 26;
                                    else portInModule = primaryPort - state.portCount;
                                }
                                primaryRuckus = `1/${module}/${portInModule}`;
                            } else {
                                primaryRuckus = primaryPort <= state.portCount ? `1/1/${primaryPort}` : `1/2/${primaryPort - state.portCount}`;
                            }
                            config.push(` primary-port ethe ${primaryRuckus}`);
                        }
                        
                        config.push(' deploy');
                        config.push(' exit');
                        config.push('!');
                    }
                });
            }
            
            // Interface VE (routed interfaces) - include VLAN 1 if it has IP helper addresses
            if (state.vlans && state.vlans.length > 0) {
                const sortedVlans = [...state.vlans].sort((a, b) => (a.vid || 0) - (b.vid || 0));
                
                sortedVlans.forEach(vlan => {
                    // Include if has IP or IP helper addresses (check both vlan and routedInterfaces)
                    const routedInt = state.routedInterfaces.find(r => r.id === vlan.id);
                    const hasIp = vlan.ip && vlan.ip !== 'dhcp';
                    const hasHelpers = (vlan.ipHelperAddresses && vlan.ipHelperAddresses.length > 0) || 
                                      (routedInt && routedInt.ipHelperAddresses && routedInt.ipHelperAddresses.length > 0);
                    
                    if (hasIp || hasHelpers) {
                        config.push(`interface ve ${vlan.vid}`);
                        
                        // Port name
                        if (routedInt && routedInt.portName) {
                            config.push(` port-name ${routedInt.portName}`);
                        } else if (vlan.name) {
                            config.push(` port-name ${vlan.name}`);
                        }
                        
                        // IP Address
                        if (hasIp) {
                            if (vlan.ip.includes('/')) {
                                const [ip, cidr] = vlan.ip.split('/');
                                const mask = cidrToMask(parseInt(cidr));
                                config.push(` ip address ${ip} ${mask}`);
                            } else {
                                config.push(` ip address ${vlan.ip}`);
                            }
                        }
                        
                        // IP Helper Addresses - check both vlan and routedInterfaces
                        const helpers = vlan.ipHelperAddresses || (routedInt && routedInt.ipHelperAddresses) || [];
                        if (helpers.length > 0) {
                            helpers.forEach((helper, index) => {
                                config.push(` ip helper-address ${index + 1} ${helper}`);
                            });
                        }
                        
                        config.push('!');
                    }
                });
            }
            
            config.push('!');
            
            // IP DHCP Client
            if (state.global.network.dhcpClient) {
                config.push(`ip dhcp-client ve default`);
            }
            
            config.push('!');
            
            // RESTCONF
            if (state.global.services && state.global.services.restconf) {
                config.push('restconf enable');
                config.push('!');
            }
            
            config.push('!');
            
            // Web Management
            if (state.global.management.web.http === false) {
                config.push('web-management disable');
            }
            
            config.push('!');
            
            // SSH Timeout
            if (state.global.management.remote.ssh && state.global.management.remote.sshTimeout) {
                config.push(`ip ssh timeout ${state.global.management.remote.sshTimeout}`);
            }
            
            config.push('!');
            
            // Telnet
            if (state.global.management.remote.telnet === false) {
                config.push('no telnet server');
            }
            
            config.push('!');
            
            // SNMP (order: community, contact, enable vlan, location)
            if (state.global.snmp.communities && state.global.snmp.communities.length > 0) {
                // Ruckus uses 1-based indexing, but we need to preserve the original index if available
                const seenCommunities = new Set();
                let currentIndex = 0;
                state.global.snmp.communities.forEach((comm, index) => {
                    // Skip duplicates
                    if (seenCommunities.has(comm.community)) return;
                    seenCommunities.add(comm.community);
                    const accessLevel = comm.access === 'ro' ? 'ro' : 'rw';
                    // Use index+1 for Ruckus (1-based), but check if there's a stored index
                    const communityIndex = comm.index !== undefined ? comm.index : (currentIndex + 1);
                    currentIndex++;
                    config.push(`snmp-server community ${communityIndex} ${comm.community} ${accessLevel}`);
                });
            }
            if (state.global.snmp.contact) {
                config.push(`snmp-server contact ${state.global.snmp.contact}`);
            }
            if (state.global.snmp.enableVlan) {
                const enableVlan = state.vlans.find(v => v.id === state.global.snmp.enableVlan || v.vid === parseInt(state.global.snmp.enableVlan));
                if (enableVlan) {
                    config.push(`snmp-server enable vlan ${enableVlan.vid}`);
                }
            }
            if (state.global.snmp.location) {
                config.push(`snmp-server location ${state.global.snmp.location}`);
            }
            
            config.push('!');
            
            // Manager Registrar (Ruckus Cloud)
            if (state.global.management.managerRegistrar) {
                const mgr = state.global.management.managerRegistrar;
                config.push('manager registrar');
                if (mgr.device && mgr.ip) {
                    config.push(`manager registrar-list ${mgr.device} ${mgr.ip}`);
                }
                if (mgr.port) {
                    config.push(`manager port-list ${mgr.port}`);
                }
                config.push('!');
            }
            
            // CLI Timeout
            if (state.global.management.remote.cliTimeout) {
                config.push(`cli timeout ${state.global.management.remote.cliTimeout}`);
            }
            
            config.push('!');
            
            // Custom Config
            if (state.global.customConfig) {
                config.push('');
                config.push('! Custom Configuration');
                config.push(state.global.customConfig);
            }
            
            config.push('');
            config.push('end');
            
            return config.join('\n');
        }
        
        function generateDellConfig() {
            let config = [];
            
            // Header comment
            config.push('! Dell PowerConnect Configuration');
            config.push('! Generated by Switch Designer');
            config.push('');
            
            // Configure command
            config.push('configure');
            
            // VLAN Database
            if (state.vlans && state.vlans.length > 0) {
                config.push('vlan database');
                const sortedVlans = [...state.vlans].sort((a, b) => (a.vid || 0) - (b.vid || 0));
                const vlanIds = sortedVlans.map(v => v.vid).filter(vid => vid !== null && vid !== undefined);
                if (vlanIds.length > 0) {
                    const vlanRanges = condensePortRanges(vlanIds);
                    config.push(`vlan ${vlanRanges}`);
                }
                config.push('exit');
                config.push('');
            }
            
            // SNMP Contact
            if (state.global.snmp.contact) {
                config.push(`snmp-server contact "${state.global.snmp.contact}"`);
            }
            
            // Hostname
            if (state.global.hostname) {
                config.push(`hostname "${state.global.hostname}"`);
            }
            
            // SNTP
            if (state.global.time.sntp.unicastClient) {
                config.push('sntp unicast client enable');
                if (state.global.time.sntp.servers && state.global.time.sntp.servers.length > 0) {
                    state.global.time.sntp.servers.forEach(server => {
                        config.push(`sntp server ${server.server}`);
                    });
                }
            }
            
            // Clock summer-time (daylight saving time)
            if (state.global.time.daylightTime) {
                const tzMap = {
                    'us central': 'CDT',
                    'us eastern': 'EDT',
                    'us pacific': 'PDT',
                    'us mountain': 'MDT'
                };
                const zone = tzMap[state.global.time.timezone] || 'CDT';
                config.push(`clock summer-time recurring USA zone "${zone}"`);
            }
            
            // Timezone
            const timezoneMap = {
                'us central': { offset: -6, zone: 'CST' },
                'us eastern': { offset: -5, zone: 'EST' },
                'us pacific': { offset: -8, zone: 'PST' },
                'us mountain': { offset: -7, zone: 'MST' }
            };
            if (state.global.time.timezone && timezoneMap[state.global.time.timezone]) {
                const tz = timezoneMap[state.global.time.timezone];
                config.push(`clock timezone ${tz.offset} minutes 0 zone "${tz.zone}"`);
            }
            
            // Stack
            if (state.global.stack && state.global.stack.member) {
                config.push('stack');
                config.push(`member ${state.global.stack.member.unit} ${state.global.stack.member.member}`);
                config.push('exit');
            }
            
            // IP Address (global management IP)
            // Check routed interfaces first (Dell parser stores it there)
            let mgmtIp = null;
            const routedIntWithIp = state.routedInterfaces.find(r => r.ip);
            if (routedIntWithIp && routedIntWithIp.ip) {
                mgmtIp = routedIntWithIp.ip;
            } else if (state.global.network.managementIp) {
                mgmtIp = state.global.network.managementIp;
            }
            
            if (mgmtIp) {
                if (mgmtIp.includes('/')) {
                    const [ip, cidr] = mgmtIp.split('/');
                    const mask = cidrToMask(parseInt(cidr));
                    config.push(`ip address ${ip} ${mask}`);
                } else {
                    config.push(`ip address ${mgmtIp}`);
                }
            }
            
            // Default Gateway
            if (state.global.network.gateway) {
                config.push(`ip default-gateway ${state.global.network.gateway}`);
            }
            
            // IP address vlan (if management IP is on VLAN 15)
            const vlan15 = state.vlans.find(v => v.vid === 15);
            if (vlan15) {
                const routedInt = state.routedInterfaces.find(r => r.id === vlan15.id);
                if (routedInt && routedInt.ip) {
                    config.push('ip address vlan 15');
                } else if (mgmtIp) {
                    // If we have a management IP and VLAN 15 exists, add ip address vlan 15
                    config.push('ip address vlan 15');
                }
            }
            config.push('');
            
            // Interface VLAN blocks (with names)
            if (state.vlans && state.vlans.length > 0) {
                const sortedVlans = [...state.vlans].sort((a, b) => (a.vid || 0) - (b.vid || 0));
                sortedVlans.forEach(vlan => {
                    if (vlan.name && vlan.name !== `VLAN ${vlan.vid}`) {
                        config.push(`interface vlan ${vlan.vid}`);
                        config.push(`name "${vlan.name}"`);
                        config.push('exit');
                    }
                });
                config.push('');
            }
            
            // Global Voice VLAN
            if (state.global.layer2 && state.global.layer2.voiceVlan) {
                config.push('voice vlan');
                config.push('');
            }
            
            // Global STP
            if (state.global.layer2 && state.global.layer2.spanningTree && state.global.layer2.spanningTree.enabled === false) {
                config.push('no spanning-tree');
            }
            
            // QoS - Class of Service
            if (state.global.qos && state.global.qos.classOfService) {
                // Dot1p mapping
                if (state.global.qos.classOfService.dot1pMapping && state.global.qos.classOfService.dot1pMapping.length > 0) {
                    state.global.qos.classOfService.dot1pMapping.forEach(mapping => {
                        config.push(`classofservice dot1p-mapping ${mapping.dot1p} ${mapping.queue}`);
                    });
                }
                
                // IP DSCP mapping
                if (state.global.qos.classOfService.ipDscpMapping && state.global.qos.classOfService.ipDscpMapping.length > 0) {
                    state.global.qos.classOfService.ipDscpMapping.forEach(mapping => {
                        config.push(`classofservice ip-dscp-mapping ${mapping.dscp} ${mapping.queue}`);
                    });
                }
                
                // Trust
                if (state.global.qos.classOfService.trust) {
                    config.push(`classofservice trust ${state.global.qos.classOfService.trust}`);
                }
            }
            
            // COS Queue Strict
            if (state.global.qos && state.global.qos.cosQueue && state.global.qos.cosQueue.strict && state.global.qos.cosQueue.strict.length > 0) {
                const queues = state.global.qos.cosQueue.strict.join(' ');
                config.push(`cos-queue strict ${queues}`);
            }
            
            config.push('!');
            
            // Physical Interfaces
            const portConfigs = [];
            Object.keys(state.ports).forEach(portNum => {
                const port = state.ports[portNum];
                const portNumInt = parseInt(portNum);
                // Skip invalid ports and ports that are in LAGs
                if (isNaN(portNumInt) || port.lagId) return;
                
                const portConfig = [];
                portConfig.push(`interface ethernet 1/g${portNumInt}`);
                
                // Spanning-tree portfast
                if (port.stp && port.stp.portfast) {
                    portConfig.push('spanning-tree portfast');
                }
                
                // Port mode
                if (port.portMode === 'trunk') {
                    portConfig.push('switchport mode trunk');
                } else if (port.portMode === 'general' || port.nativeVlanId || port.taggedVlans.length > 0) {
                    portConfig.push('switchport mode general');
                }
                
                // PVID (Native VLAN) - only for general mode
                if (port.portMode === 'general' && port.nativeVlanId) {
                    const nativeVlan = state.vlans.find(v => v.id === port.nativeVlanId);
                    if (nativeVlan) {
                        portConfig.push(`switchport general pvid ${nativeVlan.vid}`);
                    }
                }
                
                // VLAN participation (untagged for general mode)
                if (port.portMode === 'general' && port.nativeVlanId) {
                    const nativeVlan = state.vlans.find(v => v.id === port.nativeVlanId);
                    if (nativeVlan) {
                        portConfig.push(`switchport general allowed vlan add ${nativeVlan.vid}`);
                    }
                }
                
                // Tagged VLANs (general mode)
                if (port.portMode === 'general' && port.taggedVlans.length > 0) {
                    const taggedVids = port.taggedVlans.map(vlanId => {
                        const vlan = state.vlans.find(v => v.id === vlanId);
                        return vlan ? vlan.vid : null;
                    }).filter(vid => vid !== null);
                    if (taggedVids.length > 0) {
                        const vlanRanges = condensePortRanges(taggedVids);
                        // Split into multiple lines if needed (Dell sometimes splits long lists)
                        const ranges = vlanRanges.split(',');
                        let currentLine = '';
                        ranges.forEach((range, index) => {
                            const trimmed = range.trim();
                            if (currentLine === '') {
                                currentLine = trimmed;
                            } else {
                                const testLine = currentLine + ',' + trimmed;
                                // If adding this would make line too long, push current and start new
                                // Check the full command length: "switchport general allowed vlan add " (38 chars) + VLAN list + " tagged" (7 chars)
                                // Original splits around 67 chars total, so VLAN list should be around 22-25 chars
                                const fullCommandLength = 38 + testLine.length + 7;
                                // Split if full command would exceed 67 chars OR if VLAN list exceeds 25 chars
                                if (fullCommandLength > 67 || testLine.length > 25) {
                                    portConfig.push(`switchport general allowed vlan add ${currentLine} tagged`);
                                    currentLine = trimmed;
                                } else {
                                    currentLine = testLine;
                                }
                            }
                        });
                        // Push remaining line
                        if (currentLine) {
                            portConfig.push(`switchport general allowed vlan add ${currentLine} tagged`);
                        }
                    }
                }
                
                // Tagged VLANs (trunk mode)
                if (port.portMode === 'trunk' && port.taggedVlans.length > 0) {
                    const taggedVids = port.taggedVlans.map(vlanId => {
                        const vlan = state.vlans.find(v => v.id === vlanId);
                        return vlan ? vlan.vid : null;
                    }).filter(vid => vid !== null);
                    if (taggedVids.length > 0) {
                        const vlanRanges = condensePortRanges(taggedVids);
                        // Split into multiple lines if needed (Dell sometimes splits long lists)
                        const ranges = vlanRanges.split(',');
                        let currentLine = '';
                        ranges.forEach((range, index) => {
                            const trimmed = range.trim();
                            if (currentLine === '') {
                                currentLine = trimmed;
                            } else {
                                const testLine = currentLine + ',' + trimmed;
                                // If adding this would make line too long, push current and start new
                                // Dell configs typically split around 50-55 characters
                                if (testLine.length > 50) {
                                    portConfig.push(`switchport trunk allowed vlan add ${currentLine}`);
                                    currentLine = trimmed;
                                } else {
                                    currentLine = testLine;
                                }
                            }
                        });
                        // Push remaining line
                        if (currentLine) {
                            portConfig.push(`switchport trunk allowed vlan add ${currentLine}`);
                        }
                    }
                }
                
                // Excluded VLANs (remove VLAN 1)
                if (port.excludedVlans && port.excludedVlans.length > 0) {
                    port.excludedVlans.forEach(vid => {
                        portConfig.push(`switchport general allowed vlan remove ${vid}`);
                    });
                } else if (port.portMode === 'general' && port.nativeVlanId) {
                    // Default: remove VLAN 1 if port has a native VLAN
                    const nativeVlan = state.vlans.find(v => v.id === port.nativeVlanId);
                    if (nativeVlan && nativeVlan.vid !== 1) {
                        portConfig.push('switchport general allowed vlan remove 1');
                    }
                }
                
                // Voice VLAN
                if (port.voice && port.voice.vlanId) {
                    let voiceVlan = null;
                    if (typeof port.voice.vlanId === 'string') {
                        voiceVlan = state.vlans.find(v => v.id === port.voice.vlanId);
                    } else {
                        voiceVlan = state.vlans.find(v => v.vid === port.voice.vlanId);
                    }
                    if (voiceVlan) {
                        portConfig.push(`voice vlan ${voiceVlan.vid}`);
                    } else {
                        portConfig.push(`voice vlan ${port.voice.vlanId}`);
                    }
                }
                
                // LLDP settings
                if (port.lldp) {
                    if (port.lldp.transmitTlv && port.lldp.transmitTlv.length > 0) {
                        // Combine multiple TLV values into one command (e.g., "port-desc sys-name")
                        const tlvString = port.lldp.transmitTlv.join(' ');
                        portConfig.push(`lldp transmit-tlv ${tlvString}`);
                    }
                    if (port.lldp.transmitMgmt) {
                        portConfig.push('lldp transmit-mgmt');
                    }
                }
                
                portConfig.push('exit');
                portConfigs.push({ port: portNumInt, config: portConfig });
            });
            
            // Sort ports and add to config
            portConfigs.sort((a, b) => a.port - b.port);
            portConfigs.forEach(pc => {
                config.push('!');
                config.push(...pc.config);
            });
            
            // SNMP Communities (deduplicate before output)
            if (state.global.snmp && state.global.snmp.communities && state.global.snmp.communities.length > 0) {
                const seenCommunities = new Set();
                state.global.snmp.communities.forEach(comm => {
                    // Skip duplicates
                    if (seenCommunities.has(comm.community)) return;
                    seenCommunities.add(comm.community);
                    const access = comm.access === 'rw' ? 'rw ro' : 'ro';
                    config.push(`snmp-server community ${comm.community} ${access}`);
                });
            }
            
            // SNMP Hosts
            if (state.global.snmp && state.global.snmp.hosts && state.global.snmp.hosts.length > 0) {
                state.global.snmp.hosts.forEach(host => {
                    config.push(`snmp-server host ${host.host} ${host.community} ${host.type} ${host.version}`);
                });
            }
            
            // Username entries
            if (state.global.authentication && state.global.authentication.users && state.global.authentication.users.length > 0) {
                state.global.authentication.users.forEach(user => {
                    config.push(`username "${user.username}" password ${user.password} level ${user.level} encrypted`);
                });
            }
            
            config.push('exit');
            
            return config.join('\n');
        }
        
        function maskToCidr(mask) {
            // Convert subnet mask to CIDR notation
            const parts = mask.split('.');
            let cidr = 0;
            for (let i = 0; i < 4; i++) {
                const octet = parseInt(parts[i]);
                if (octet === 255) {
                    cidr += 8;
                } else if (octet === 0) {
                    cidr += 0;
                } else {
                    // Count leading 1 bits
                    let bits = 0;
                    let val = octet;
                    while (val > 0 && (val & 128)) {
                        bits++;
                        val = (val << 1) & 255;
                    }
                    cidr += bits;
                    break; // Once we hit a non-255 octet, the rest should be 0
                }
            }
            return `/${cidr}`;
        }
        
        function cidrToMask(cidr) {
            // Convert CIDR notation to subnet mask
            const mask = [];
            for (let i = 0; i < 4; i++) {
                const bits = Math.min(8, Math.max(0, cidr - (i * 8)));
                mask.push(256 - Math.pow(2, 8 - bits));
            }
            return mask.join('.');
        }
        
        function copyCli() { 
            navigator.clipboard.writeText(document.getElementById('cli-output').textContent); 
            alert('Copied!'); 
        }

        init();
    </script>
</body>
</html>