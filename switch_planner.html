<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switch Designer v21 (Homelab Playground)</title>
    <link rel="icon" type="image/png" href="https://homelabplayground.com/favicon.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        obsidian: {
                            bg: '#1e1e1e',
                            pane: '#252526',
                            border: '#3c3c3c',
                            accent: '#7c3aed',
                            text: '#cccccc'
                        }
                    },
                    fontFamily: {
                        mono: ['"Fira Code"', 'Consolas', 'Monaco', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #3c3c3c; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        /* RJ45 Port Styling */
        .rj45-port {
            position: relative;
            background-color: #0d0d0d;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.9);
            transition: all 0.2s;
            cursor: pointer;
        }
        .rj45-port::after {
            content: '';
            position: absolute;
            bottom: 0; left: 50%; transform: translateX(-50%);
            width: 60%; height: 4px;
            background: repeating-linear-gradient(90deg, #b8860b, #b8860b 2px, #000 2px, #000 4px);
            opacity: 0.6; pointer-events: none; z-index: 5;
        }

        /* SFP Port Styling */
        .sfp-port {
            position: relative;
            background-color: #1a1a1a;
            box-shadow: inset 0 0 5px rgba(0,0,0,1);
            border: 1px solid #444;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .sfp-port::before {
            content: '';
            width: 40%; height: 4px;
            background: #333; border-radius: 2px;
        }

        /* Input Styling */
        .port-label-input:focus { outline: none; background: #3c3c3c; color: white; }

        /* Tag Pips */
        .tag-container {
            position: absolute; bottom: 2px; left: 2px; right: 2px;
            display: flex; gap: 2px; justify-content: center;
            z-index: 10; pointer-events: none;
        }
        .tag-pip {
            height: 4px; flex: 1; border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.8);
            border: 0.5px solid rgba(255,255,255,0.2);
        }

        /* Badges */
        .lag-badge {
            position: absolute; top: 2px; right: 2px;
            background: #2563eb; color: white;
            font-size: 8px; font-weight: bold;
            padding: 1px 3px; border-radius: 2px;
            z-index: 20; box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .shield-badge {
            position: absolute; top: 2px; left: 2px;
            color: #ec4899; 
            font-size: 9px;
            z-index: 20; 
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.8));
        }

        /* Print/Export */
        @media print {
            body * { visibility: hidden; }
            #export-area, #export-area * { visibility: visible; }
            #export-area { position: absolute; left: 0; top: 0; width: 100%; background: white !important; color: black !important; padding: 20px; }
            .rj45-port, .sfp-port { border: 1px solid #ccc; }
        }
    </style>
</head>
<body class="flex flex-col h-screen overflow-hidden bg-obsidian-bg text-obsidian-text font-sans">

    <header class="h-14 bg-obsidian-pane border-b border-obsidian-border flex items-center justify-between px-4 shrink-0 z-20">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-network-wired text-obsidian-accent text-xl"></i>
            <h1 class="font-bold text-lg tracking-wide text-gray-200 hidden md:block">Switch Designer <span class="text-obsidian-accent font-light">v21</span></h1>
        </div>
        <div class="flex items-center gap-2">
            <button onclick="cycleSwitchSize()" id="size-btn" class="text-xs bg-obsidian-border hover:bg-white/10 text-white px-3 py-1.5 rounded transition font-mono border border-transparent hover:border-gray-500">
                Size: 24 Ports
            </button>
            <button onclick="openSettingsModal()" class="text-xs bg-obsidian-pane hover:bg-white/10 text-gray-300 border border-obsidian-border px-3 py-1.5 rounded transition">
                <i class="fa-solid fa-gear"></i> Settings
            </button>
            <button onclick="openExportModal()" class="text-xs bg-obsidian-accent hover:bg-violet-600 text-white px-3 py-1.5 rounded transition shadow-lg shadow-violet-900/20">
                <i class="fa-solid fa-camera mr-1"></i> PNG
            </button>
        </div>
    </header>

    <div class="flex-1 flex flex-col md:flex-row overflow-hidden">
        
        <aside class="w-full md:w-80 bg-obsidian-pane border-b md:border-b-0 md:border-r border-obsidian-border flex flex-col shrink-0 overflow-y-auto z-10">
            
            <div class="p-4 border-b border-obsidian-border bg-black/10">
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <button onclick="downloadJson()" class="bg-obsidian-bg hover:bg-white/5 border border-obsidian-border text-gray-300 text-xs py-2 rounded flex items-center justify-center gap-2 transition">
                        <i class="fa-solid fa-download text-green-500"></i> Save JSON
                    </button>
                    <button onclick="triggerImport()" class="bg-obsidian-bg hover:bg-white/5 border border-obsidian-border text-gray-300 text-xs py-2 rounded flex items-center justify-center gap-2 transition">
                        <i class="fa-solid fa-upload text-blue-500"></i> Load JSON
                    </button>
                    <input type="file" id="json-input" class="hidden" accept=".json" onchange="importJson(this)">
                </div>
                
                <div class="grid grid-cols-1 gap-2">
                    <button onclick="openImporterModal()" class="bg-slate-700 hover:bg-slate-600 text-white border border-slate-600 text-xs py-2 rounded flex items-center justify-center gap-2 transition shadow-lg">
                        <i class="fa-solid fa-file-import text-yellow-400"></i> Import Running-Config
                    </button>
                    <button onclick="openCliModal()" class="bg-slate-800 hover:bg-slate-700 text-blue-400 border border-slate-700 text-xs py-2 rounded flex items-center justify-center gap-2 transition shadow-lg">
                        <i class="fa-solid fa-terminal"></i> Generate Full Config
                    </button>
                </div>
            </div>

            <div class="p-4 border-b border-obsidian-border">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-xs font-bold uppercase text-gray-500 tracking-wider">VLANs</h2>
                    <span class="text-[10px] text-gray-600 cursor-pointer hover:text-white" onclick="resetVlans()">Reset</span>
                </div>
                
                <div id="vlan-properties" class="bg-black/20 p-2 rounded border border-obsidian-border mb-3 hidden">
                    <div class="flex justify-between items-center mb-2 border-b border-white/5 pb-1">
                         <span id="prop-vlan-title" class="text-xs font-bold text-white">VLAN Details</span>
                         <button onclick="saveVlanProps()" class="text-[10px] bg-green-900/50 text-green-400 px-2 rounded border border-green-800">Save</button>
                    </div>
                    <div class="space-y-2">
                        <div class="flex gap-2">
                            <input id="prop-vlan-name" placeholder="Name" class="w-full bg-[#111] border border-[#333] text-[10px] text-white px-1 py-1 rounded">
                            <input id="prop-vlan-ip" placeholder="L3 IP (10.0.0.1/24)" class="w-full bg-[#111] border border-[#333] text-[10px] text-white px-1 py-1 rounded">
                        </div>
                        <div class="flex gap-2 items-center justify-between">
                            <label class="flex items-center gap-1 text-[10px] text-gray-400 cursor-pointer">
                                <input type="checkbox" id="prop-vlan-igmp" class="rounded bg-[#111] border-[#333]"> IGMP Snoop
                            </label>
                            <select id="prop-vlan-qos" class="bg-[#111] border border-[#333] text-[10px] text-gray-300 rounded px-1 py-0.5">
                                <option value="">No QoS</option>
                                <option value="voice">Voice</option>
                                <option value="video">Video</option>
                                <option value="critical">Critical</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="vlan-list" class="space-y-1 mb-2 max-h-32 overflow-y-auto"></div>
                
                <div class="flex gap-2 items-center bg-obsidian-bg p-2 rounded border border-obsidian-border">
                    <input type="color" id="new-vlan-color" value="#10b981" class="bg-transparent border-none h-5 w-6 cursor-pointer p-0">
                    <input type="text" id="new-vlan-name" placeholder="New VLAN..." class="bg-transparent border-none text-xs text-white w-full focus:outline-none font-mono">
                    <button onclick="addVlan()" class="text-obsidian-accent hover:text-white px-2"><i class="fa-solid fa-plus"></i></button>
                </div>
            </div>

            <div class="p-4 border-b border-obsidian-border">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-xs font-bold uppercase text-gray-500 tracking-wider">Link Aggregation</h2>
                    <span class="text-[10px] text-gray-600 cursor-pointer hover:text-white" onclick="resetLags()">Reset</span>
                </div>
                <div id="lag-list" class="space-y-1 mb-2 max-h-32 overflow-y-auto"></div>
                <div class="flex gap-2 items-center bg-obsidian-bg p-2 rounded border border-obsidian-border">
                    <select id="new-lag-type" class="bg-[#111] text-[10px] text-white border border-[#333] rounded px-1">
                        <option value="lacp">LACP</option>
                        <option value="static">Static</option>
                    </select>
                    <input type="text" id="new-lag-name" placeholder="Name..." class="bg-transparent border-none text-xs text-white w-full focus:outline-none font-mono">
                    <button onclick="addLag()" class="text-blue-400 hover:text-white px-2"><i class="fa-solid fa-plus"></i></button>
                </div>
            </div>

            <div class="p-4">
                <h2 class="text-xs font-bold uppercase text-gray-500 mb-3 tracking-wider">Tools</h2>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="setTool('paint')" id="tool-paint" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-paintbrush"></i> Native
                    </button>
                    <button onclick="setTool('tag')" id="tool-tag" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-tags"></i> Add Tag
                    </button>
                     <button onclick="setTool('lag')" id="tool-lag" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-link"></i> Assign LAG
                    </button>
                    <button onclick="setTool('poe')" id="tool-poe" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-bolt"></i> Toggle PoE
                    </button>
                    <button onclick="setTool('protect')" id="tool-protect" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-shield-halved"></i> Loop Prot.
                    </button>
                    <button onclick="setTool('label')" id="tool-label" class="tool-btn p-2 rounded flex items-center justify-center gap-2 text-xs">
                        <i class="fa-solid fa-tag"></i> Label
                    </button>
                    <button onclick="setTool('erase')" id="tool-erase" class="tool-btn col-span-2 p-2 rounded flex items-center justify-center gap-2 text-xs border border-red-900/30 text-red-400 hover:bg-red-900/20">
                        <i class="fa-solid fa-eraser"></i> Erase Port
                    </button>
                </div>
            </div>
        </aside>

        <main class="flex-1 overflow-auto bg-obsidian-bg relative flex flex-col items-center p-4 md:p-10">
            <div id="export-area" class="w-auto inline-block min-w-0">
                <div class="bg-[#2a2a2e] rounded-sm border border-[#444] shadow-2xl relative w-fit mx-auto pr-6">
                    <div class="absolute top-0 bottom-0 -left-4 w-4 bg-[#202021] border border-[#444] rounded-l flex flex-col justify-between py-2 items-center">
                        <div class="w-2 h-3 rounded-full bg-black/60 border border-gray-600"></div><div class="w-2 h-3 rounded-full bg-black/60 border border-gray-600"></div>
                    </div>
                    <div class="absolute top-0 bottom-0 -right-4 w-4 bg-[#202021] border border-[#444] rounded-r flex flex-col justify-between py-2 items-center">
                        <div class="w-2 h-3 rounded-full bg-black/60 border border-gray-600"></div><div class="w-2 h-3 rounded-full bg-black/60 border border-gray-600"></div>
                    </div>

                    <div class="p-3 md:p-5 flex flex-row items-center gap-8 whitespace-nowrap">
                        <div class="flex flex-col items-start gap-2 shrink-0 min-w-[80px]">
                            <div class="text-gray-400 font-bold font-mono tracking-widest text-sm uppercase">SW-<span id="model-label">24</span></div>
                            <div class="grid grid-cols-2 gap-x-2 gap-y-1">
                                <div class="flex items-center gap-1"><div class="w-1.5 h-1.5 rounded-full bg-green-500 shadow-[0_0_5px_#22c55e]"></div><span class="text-[9px] text-gray-500 font-mono">SYS</span></div>
                                <div class="flex items-center gap-1"><div class="w-1.5 h-1.5 rounded-full bg-green-500 shadow-[0_0_5px_#22c55e]"></div><span class="text-[9px] text-gray-500 font-mono">PWR</span></div>
                            </div>
                        </div>
                        <div id="rj45-container" class="grid gap-x-1 gap-y-5"></div>
                        <div class="flex flex-col items-center gap-1 border-l border-white/5 pl-8 ml-auto">
                            <span class="text-[9px] text-gray-500 font-mono uppercase mb-1">SFP+ Uplinks</span>
                            <div id="sfp-container" class="grid grid-cols-2 gap-2 p-1.5 bg-black/30 rounded border border-white/5"></div>
                        </div>
                    </div>
                </div>
                <div id="export-legend" class="mt-8 grid grid-cols-2 md:grid-cols-4 gap-4 hidden bg-white p-4 text-black border border-gray-300"></div>
            </div>
        </main>
    </div>

    <div id="settings-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl max-w-3xl w-full flex flex-col animate-fade-in max-h-[90vh]">
            <div class="flex justify-between items-center p-4 border-b border-obsidian-border bg-obsidian-bg">
                <h3 class="text-white font-bold"><i class="fa-solid fa-gear"></i> Switch Configuration</h3>
                <button onclick="closeSettingsModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6 space-y-6">
                <section>
                    <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Device Basics</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div><label class="text-xs text-gray-400 block mb-1">Hostname</label><input id="conf-hostname" class="w-full bg-[#111] text-white border border-[#333] rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">Default Gateway (Route 0.0.0.0)</label><input id="conf-gateway" class="w-full bg-[#111] text-white border border-[#333] rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">DNS Server</label><input id="conf-dns" class="w-full bg-[#111] text-white border border-[#333] rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">NTP Server</label><input id="conf-ntp" class="w-full bg-[#111] text-white border border-[#333] rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">SNMP Location</label><input id="conf-snmp-location" class="w-full bg-[#111] text-white border border-[#333] rounded px-2 py-1 text-sm font-mono"></div>
                        <div><label class="text-xs text-gray-400 block mb-1">SNMP Contact</label><input id="conf-snmp-contact" class="w-full bg-[#111] text-white border border-[#333] rounded px-2 py-1 text-sm font-mono"></div>
                    </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-xs font-bold uppercase text-obsidian-accent">Routed Interfaces (Layer 3)</h4>
                        <button onclick="addRoutedInterface()" class="text-xs bg-green-900/30 text-green-400 border border-green-900 px-2 py-1 rounded hover:bg-green-900/50"><i class="fa-solid fa-plus"></i> Add Interface</button>
                    </div>
                    <div id="l3-interfaces-list" class="space-y-2">
                        </div>
                </section>

                <hr class="border-obsidian-border">

                <section>
                     <h4 class="text-xs font-bold uppercase text-obsidian-accent mb-2">Custom Config Injection</h4>
                     <p class="text-[10px] text-gray-500 mb-2">Any text here will be appended/injected into the final generated configuration. Use generic syntax or specific commands.</p>
                     <textarea id="conf-custom" class="w-full h-32 bg-[#111] text-green-400 font-mono text-xs p-2 rounded border border-[#333]" placeholder="! Add custom commands here..."></textarea>
                </section>
            </div>
            <div class="p-4 bg-obsidian-pane border-t border-obsidian-border flex justify-end">
                <button onclick="saveSettings()" class="bg-obsidian-accent hover:bg-violet-600 text-white px-6 py-2 rounded text-sm transition">Save</button>
            </div>
        </div>
    </div>

    <div id="cli-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl max-w-5xl w-full h-[85vh] flex flex-col animate-fade-in">
            <div class="flex justify-between items-center p-4 border-b border-obsidian-border bg-obsidian-bg">
                <h3 class="text-white font-bold"><i class="fa-solid fa-terminal text-green-500"></i> Config Generator</h3>
                <button onclick="closeCliModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="p-4 bg-obsidian-bg border-b border-obsidian-border flex gap-4 items-center flex-wrap">
                <label class="text-xs text-gray-400">Target:</label>
                <select id="cli-brand" onchange="generateCli()" class="bg-obsidian-pane text-white text-xs p-2 rounded border border-obsidian-border">
                    <option value="netgear_m">Netgear M-Series (AV Line)</option>
                    <option value="ruckus">Ruckus (ICX)</option>
                    <option value="aruba">HP Aruba (ProCurve/OS)</option>
                </select>
                <button onclick="copyCli()" class="ml-auto bg-obsidian-accent text-white px-4 py-2 rounded text-xs"><i class="fa-regular fa-copy"></i> Copy</button>
            </div>
            <div class="flex-1 overflow-auto p-4 bg-[#1e1e1e]"><pre id="cli-output" class="font-mono text-xs text-green-400 whitespace-pre-wrap"></pre></div>
        </div>
    </div>

    <div id="export-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col items-center justify-center p-4 backdrop-blur-sm"><div class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl max-w-7xl w-full h-[90vh] flex flex-col"><div class="flex justify-between items-center p-4 border-b border-obsidian-border bg-obsidian-bg"><h3 class="text-white font-bold">Export Preview</h3><button onclick="closeExportModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button></div><div class="flex-1 overflow-auto p-8 bg-white flex items-center justify-center" id="modal-content"></div><div class="p-4 bg-obsidian-pane border-t border-obsidian-border flex justify-end"><button onclick="closeExportModal()" class="bg-obsidian-border text-white px-6 py-2 rounded text-sm">Close</button></div></div></div>
    <div id="importer-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col items-center justify-center p-4 backdrop-blur-sm"><div class="bg-obsidian-pane border border-obsidian-border rounded-lg shadow-2xl max-w-4xl w-full h-[80vh] flex flex-col"><div class="flex justify-between items-center p-4 border-b border-obsidian-border bg-obsidian-bg"><h3 class="text-white font-bold">Import Config</h3><button onclick="closeImporterModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button></div><div class="p-4 bg-obsidian-bg border-b border-obsidian-border"><textarea id="import-text" class="w-full h-48 bg-[#111] text-gray-300 font-mono text-xs p-4 rounded border border-[#333]" placeholder="Paste config here..."></textarea></div><div class="p-4 bg-obsidian-pane flex justify-end"><button onclick="parseAndLoadConfig()" class="bg-green-600 text-white px-4 py-2 rounded text-xs font-bold">Process Config</button></div></div></div>

    <footer class="bg-obsidian-pane border-t border-obsidian-border py-3 text-center shrink-0 z-10 flex flex-col md:flex-row justify-center items-center gap-3">
        <a href="https://homelabplayground.com" class="text-gray-500 hover:text-violet-400 text-xs transition-colors font-sans no-underline">
            HomeLab Playground
        </a>
        <span class="hidden md:block text-obsidian-border mx-1">|</span>
        <a href="https://www.buymeacoffee.com/bryjogar" target="_blank" class="inline-flex items-center px-3 py-1 bg-obsidian-accent hover:bg-violet-600 text-white text-xs font-sans rounded-full transition-colors no-underline">
            <i class="fa-solid fa-mug-hot mr-1.5"></i>
            <span>Support The Tools</span>
        </a>
    </footer>

    <script>
        // --- State ---
        const SFP_COUNT = 4;
        const PORT_OPTIONS = [8, 10, 16, 24, 48];
        let state = {
            portCount: 24,
            activeVlanId: 'vlan-1',
            activeLagId: null,
            currentTool: 'paint', 
            vlans: [{ id: 'vlan-1', name: 'Default', vid: 1, color: '#64748b' }],
            lags: [],
            ports: {},
            routedInterfaces: [
                { id: 'vlan-1', ip: '192.168.1.2/24' } // Default mgmt
            ],
            global: { 
                hostname: 'SWITCH-01', 
                gateway: '192.168.1.1', 
                dns: ['8.8.8.8'], // Array for multiple DNS servers
                ntp: [{ server: 'pool.ntp.org', priority: null }], // Array for multiple NTP servers with priorities
                timezone: { offset: null, zone: null }, // e.g., { offset: -360, zone: 'CST' }
                daylightTime: null, // e.g., 'continental-us-and-canada'
                customConfig: '', 
                snmpLocation: '', 
                snmpContact: '',
                snmpSysname: '',
                snmpCommunities: [], // [{ community: 'string', access: 'ro'|'rw'|'operator'|'unrestricted' }]
                snmpUsers: [], // [{ username: 'string', auth: 'string', priv: 'string' }]
                snmpHosts: [], // [{ host: 'ip', community: 'string', version: 'v2'|'v3' }]
                ipRouting: true,
                ipHttpPort: null,
                ipHttpSecurePort: null,
                ipSshEnabled: null,
                ipSshTimeout: null,
                ipTelnetEnabled: null,
                consoleTimeout: null,
                stackMember: null, // e.g., { unit: 1, member: 4 }
                managerRegistrar: null, // Ruckus: { device: 'string', ip: 'string', port: number }
                mirrorPort: null, // HP: { mirrorId: number, port: number }
                igmpQuerier: { enabled: false, queryInterval: null },
                classofservice: { // Netgear/Dell
                    dot1pMapping: [], // [{ dot1p: number, queue: number }]
                    ipDscpMapping: [], // [{ dscp: number, queue: number }]
                    trust: null // 'ip-dscp' | 'dot1p' | null
                },
                cosQueue: { strict: [] }, // Array of queue numbers
                routerProtocols: { rip: false, ospf: false, ipv6Ospf: false }
            }
        };

        // --- DOM Elements ---
        const rj45Container = document.getElementById('rj45-container');
        const sfpContainer = document.getElementById('sfp-container');
        const vlanList = document.getElementById('vlan-list');
        const lagList = document.getElementById('lag-list');
        const sizeBtn = document.getElementById('size-btn');
        const modelLabel = document.getElementById('model-label');
        const cliOutput = document.getElementById('cli-output');
        const propPane = document.getElementById('vlan-properties');

        function init() { 
            setTool('paint'); 
            renderVlanList(); 
            renderLagList(); 
            renderAllPorts(); 
            updateSizeBtnLabel(); 
            loadSettingsToForm();
            updatePropPane();
        }

        // --- Rendering ---
        function renderVlanList() {
            vlanList.innerHTML = '';
            state.vlans.forEach(vlan => {
                const isActive = state.activeVlanId === vlan.id;
                const div = document.createElement('div');
                div.className = `flex items-center justify-between p-2 rounded cursor-pointer transition border mb-1 ${isActive ? 'bg-white/5 border-obsidian-accent' : 'border-transparent hover:bg-white/5'}`;
                div.onclick = () => selectVlan(vlan.id);
                
                let icons = '';
                if(vlan.ip) icons += '<i class="fa-solid fa-network-wired text-[8px] text-green-400 ml-1" title="L3 Interface"></i>';
                if(vlan.igmp) icons += '<i class="fa-solid fa-eye text-[8px] text-blue-400 ml-1" title="IGMP"></i>';
                
                div.innerHTML = `<div class="flex items-center gap-2"><div class="w-3 h-3 rounded shadow-sm" style="background-color: ${vlan.color};"></div><span class="text-xs font-mono text-gray-300">${vlan.name} (${vlan.vid})</span>${icons}</div>`;
                vlanList.appendChild(div);
            });
            updatePropPane();
        }

        function updatePropPane() {
            const vlan = state.vlans.find(v => v.id === state.activeVlanId);
            if(!vlan) { propPane.classList.add('hidden'); return; }
            propPane.classList.remove('hidden');
            document.getElementById('prop-vlan-title').innerText = `${vlan.name} (ID: ${vlan.vid})`;
            document.getElementById('prop-vlan-name').value = vlan.name;
            document.getElementById('prop-vlan-ip').value = vlan.ip || '';
            document.getElementById('prop-vlan-igmp').checked = vlan.igmp || false;
            document.getElementById('prop-vlan-qos').value = vlan.qos || '';
        }
        
        function saveVlanProps() {
            const vlan = state.vlans.find(v => v.id === state.activeVlanId);
            if(vlan) {
                vlan.name = document.getElementById('prop-vlan-name').value;
                vlan.ip = document.getElementById('prop-vlan-ip').value;
                vlan.igmp = document.getElementById('prop-vlan-igmp').checked;
                vlan.qos = document.getElementById('prop-vlan-qos').value;
                renderVlanList();
            }
        }

        function renderLagList() {
            lagList.innerHTML = '';
            state.lags.forEach(lag => {
                const isActive = state.activeLagId === lag.id;
                const div = document.createElement('div');
                div.className = `flex items-center justify-between p-2 rounded cursor-pointer transition border mb-1 ${isActive ? 'bg-white/5 border-blue-500' : 'border-transparent hover:bg-white/5'}`;
                div.onclick = () => selectLag(lag.id);
                div.innerHTML = `<div class="flex items-center gap-2"><i class="fa-solid fa-link text-blue-500 text-xs"></i><span class="text-xs font-mono text-gray-300">L${lag.id}: ${lag.name}</span></div><span class="text-[9px] text-gray-500 uppercase">${lag.type}</span>`;
                lagList.appendChild(div);
            });
        }

        function renderAllPorts() { renderRJ45(); renderSFP(); modelLabel.innerText = state.portCount; }

        function renderRJ45() {
            const columns = state.portCount / 2;
            rj45Container.style.gridTemplateColumns = `repeat(${columns}, minmax(34px, 1fr))`; 
            rj45Container.innerHTML = '';
            for (let col = 0; col < columns; col++) {
                const colDiv = document.createElement('div');
                colDiv.className = "flex flex-col gap-1 items-center";
                colDiv.appendChild(createPortNode((col * 2) + 1, 'top', false));
                colDiv.appendChild(createPortNode((col * 2) + 2, 'bottom', false));
                rj45Container.appendChild(colDiv);
            }
        }

        function renderSFP() {
            sfpContainer.innerHTML = '';
            const startNum = state.portCount + 1;
            for (let i = 0; i < SFP_COUNT; i++) sfpContainer.appendChild(createPortNode(startNum + i, 'single', true));
        }

        function createPortNode(portNum, position, isSfp) {
            const portData = state.ports[portNum] || { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null, isProtect: false };
            const isPoeEnabled = !isSfp && (portData.isPoe !== false);
            let baseColor = isSfp ? '#1a1a1a' : '#0d0d0d';
            let vlanName = 'Unassigned';
            let vid = '';
            
            if (portData.nativeVlanId) {
                const vlan = state.vlans.find(v => v.id === portData.nativeVlanId);
                if (vlan) { baseColor = vlan.color; vlanName = vlan.name; vid = vlan.vid; }
            }

            let tooltip = `Port ${portNum}`;
            if(portData.customLabel) tooltip += `\nLabel: ${portData.customLabel}`;
            if(portData.lagId) {
                const lag = state.lags.find(l=>l.id===portData.lagId);
                tooltip += `\nLAG: L${portData.lagId} ${lag?lag.name:''}`;
            }
            if(portData.nativeVlanId) tooltip += `\nNative: ${vlanName} (${vid})`;
            if(portData.taggedVlans && portData.taggedVlans.length > 0) {
                const tagNames = portData.taggedVlans.map(tid => {
                    const v = state.vlans.find(v => v.id === tid);
                    return v ? `${v.name} (${v.vid})` : tid;
                }).join(', ');
                tooltip += `\nTagged: ${tagNames}`;
            }
            if(!isSfp) tooltip += `\nPoE: ${isPoeEnabled?'On':'Off'}`;
            if(portData.isProtect) tooltip += `\nLoop Protect: On`;

            let tagsHtml = '';
            if (portData.taggedVlans && portData.taggedVlans.length > 0) {
                tagsHtml = '<div class="tag-container">';
                portData.taggedVlans.forEach(tagId => {
                    const tagVlan = state.vlans.find(v => v.id === tagId);
                    if(tagVlan) tagsHtml += `<div class="tag-pip" style="background-color: ${tagVlan.color};"></div>`;
                });
                tagsHtml += '</div>';
            }

            const lagBadge = portData.lagId ? `<div class="lag-badge">L${portData.lagId}</div>` : '';
            const poeIcon = isPoeEnabled ? '<i class="fa-solid fa-bolt text-yellow-400 absolute top-0.5 right-0.5 text-[9px] z-20 drop-shadow-md"></i>' : '';
            const protectIcon = portData.isProtect ? '<i class="fa-solid fa-shield-halved shield-badge"></i>' : '';
            const wrapper = document.createElement('div');
            wrapper.className = "flex flex-col items-center gap-1 group relative";
            const inputHtml = `<input type="text" value="${portData.customLabel || portNum}" class="w-8 text-[9px] text-center bg-transparent border-none text-gray-500 font-mono focus:text-white focus:bg-obsidian-pane rounded port-label-input z-20" onchange="updateLabel(${portNum}, this.value)" readonly>`;
            
            const commonClasses = `w-8 h-8 rounded-sm relative overflow-hidden border ${portData.lagId ? 'border-blue-500' : 'border-[#444]'}`;
            const bgStyle = `background-color: ${portData.nativeVlanId ? baseColor : (isSfp?'#1a1a1a':'#0d0d0d')}`;
            const overlay = `<div class="absolute inset-0 opacity-40" style="${portData.nativeVlanId ? 'background-color:'+baseColor : ''}"></div>`;
            const led = !isSfp ? `<div class="absolute bottom-1 right-1 w-1 h-1 rounded-full ${portData.nativeVlanId ? 'bg-green-500 shadow-[0_0_4px_#22c55e]' : 'bg-gray-800'}"></div>` : `<div class="z-10 w-3 h-4 bg-black/50 rounded-sm border border-white/10"></div>`;
            
            const portHtml = `<div class="${commonClasses} ${isSfp?'sfp-port':'rj45-port'}" title="${tooltip}" onclick="handlePortClick(${portNum})">${overlay}${tagsHtml}${led}${poeIcon}${protectIcon}${lagBadge}</div>`;

            if (position === 'top') wrapper.innerHTML = inputHtml + portHtml;
            else if (position === 'bottom') wrapper.innerHTML = portHtml + inputHtml;
            else wrapper.innerHTML = portHtml + `<div class="mt-1">${inputHtml}</div>`;
            return wrapper;
        }

        // --- Logic ---
        function handlePortClick(portNum) {
            if (!state.ports[portNum]) state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null, isProtect: false };
            const p = state.ports[portNum];
            const isSfp = portNum > state.portCount; 

            if (state.currentTool === 'paint') p.nativeVlanId = state.activeVlanId;
            else if (state.currentTool === 'tag') {
                if (!p.taggedVlans) p.taggedVlans = [];
                const idx = p.taggedVlans.indexOf(state.activeVlanId);
                if (idx > -1) p.taggedVlans.splice(idx, 1);
                else if (p.nativeVlanId !== state.activeVlanId) p.taggedVlans.push(state.activeVlanId);
            }
            else if (state.currentTool === 'poe' && !isSfp) p.isPoe = (p.isPoe === false) ? true : false;
            else if (state.currentTool === 'protect') p.isProtect = !p.isProtect;
            else if (state.currentTool === 'lag') {
                if (state.activeLagId) p.lagId = (p.lagId === state.activeLagId) ? null : state.activeLagId;
            }
            else if (state.currentTool === 'erase') { p.nativeVlanId = null; p.taggedVlans = []; p.isPoe = undefined; p.customLabel = null; p.lagId = null; p.isProtect = false; }
            else if (state.currentTool === 'label') {
                const newLabel = prompt(`Label Port ${portNum}:`, p.customLabel || portNum);
                if (newLabel !== null) p.customLabel = (newLabel === '' || newLabel == portNum) ? null : newLabel;
            }
            renderAllPorts();
        }

        function updateLabel(portNum, text) { 
            if(!state.ports[portNum]) state.ports[portNum]={}; state.ports[portNum].customLabel = text; renderAllPorts(); 
        }

        function setTool(tool) {
            state.currentTool = tool;
            const base = ['tool-btn','p-2','rounded','flex','items-center','justify-center','gap-2','text-xs'];
            const active = ['bg-obsidian-accent','text-white'];
            const inactive = ['bg-obsidian-bg','text-gray-400','border','border-obsidian-border'];
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.className = ''; btn.classList.add(...base);
                if(btn.id===`tool-${tool}`) btn.classList.add(...active);
                else btn.classList.add(...(btn.id!=='tool-erase' ? inactive : ['border','border-red-900/30','text-red-400']));
            });
        }

        function selectVlan(id) { state.activeVlanId = id; renderVlanList(); }
        function selectLag(id) { state.activeLagId = id; setTool('lag'); renderLagList(); }

        function addVlan() {
            const nameInput = document.getElementById('new-vlan-name');
            const idInput = document.getElementById('new-vlan-id');
            const colorInput = document.getElementById('new-vlan-color');

            const name = nameInput.value.trim();
            const color = colorInput.value;
            let vid = parseInt(idInput.value.trim());

            if (!name) { alert("Please enter a VLAN Name"); return; }

            // If no ID provided, auto-increment
            if (!vid) {
                 vid = state.vlans.length > 0 ? Math.max(...state.vlans.map(v => v.vid || 0)) + 10 : 10;
            }

            // Validate ID
            if (state.vlans.find(v => v.vid === vid)) {
                alert(`VLAN ID ${vid} already exists.`);
                return;
            }
            if (vid < 1 || vid > 4094) {
                alert("VLAN ID must be between 1 and 4094");
                return;
            }

            const id = `vlan-${vid}`;
            state.vlans.push({ id, name, color, vid });
            
            // Reset inputs
            nameInput.value = '';
            idInput.value = '';
            
            selectVlan(id);
        }

        function addLag() {
            const name = document.getElementById('new-lag-name').value.trim();
            if(!name) return;
            const id = state.lags.length + 1; 
            const type = document.getElementById('new-lag-type').value;
            state.lags.push({ id, name, type });
            document.getElementById('new-lag-name').value = ''; selectLag(id);
        }

        function resetVlans() { if(confirm("Reset VLANs?")) { state.vlans=[{ id: 'vlan-1', name: 'Default', vid: 1, color: '#64748b' }]; state.activeVlanId='vlan-1'; renderVlanList(); renderAllPorts(); } }
        function resetLags() { if(confirm("Clear LAGs?")) { state.lags = []; Object.values(state.ports).forEach(p=>p.lagId=null); renderLagList(); renderAllPorts(); } }
        function cycleSwitchSize() {
            let idx = PORT_OPTIONS.indexOf(state.portCount);
            state.portCount = PORT_OPTIONS[(idx+1)%PORT_OPTIONS.length];
            updateSizeBtnLabel(); renderAllPorts();
        }
        function updateSizeBtnLabel() { sizeBtn.innerText = `Size: ${state.portCount} Ports`; }
        
        function openSettingsModal() { loadSettingsToForm(); document.getElementById('settings-modal').classList.remove('hidden'); }
        function closeSettingsModal() { document.getElementById('settings-modal').classList.add('hidden'); }
        function loadSettingsToForm() { 
            ['hostname','gateway','dns','ntp'].forEach(k => document.getElementById('conf-'+k).value = state.global[k] || ''); 
            document.getElementById('conf-snmp-location').value = state.global.snmpLocation || '';
            document.getElementById('conf-snmp-contact').value = state.global.snmpContact || '';
            document.getElementById('conf-custom').value = state.global.customConfig || '';
            renderL3List();
        }
        function saveSettings() { 
            ['hostname','gateway','dns','ntp'].forEach(k => state.global[k] = document.getElementById('conf-'+k).value);
            state.global.snmpLocation = document.getElementById('conf-snmp-location').value;
            state.global.snmpContact = document.getElementById('conf-snmp-contact').value;
            state.global.customConfig = document.getElementById('conf-custom').value;
            closeSettingsModal(); 
        }

        function downloadJson() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
            const dl = document.createElement('a'); dl.href = dataStr; dl.download = "switch_config.json"; dl.click();
        }
        function triggerImport() { document.getElementById('json-input').click(); }
        function importJson(input) {
            const file = input.files[0]; if(!file) return;
            const r = new FileReader();
            r.onload = e => { 
                try { 
                    const loaded = JSON.parse(e.target.result);
                    // Merge loaded state, ensuring arrays are initialized
                    state = loaded;
                    // Ensure arrays exist
                    if (!state.global.dns || !Array.isArray(state.global.dns)) state.global.dns = state.global.dns ? [state.global.dns] : ['8.8.8.8'];
                    if (!state.global.ntp || !Array.isArray(state.global.ntp)) state.global.ntp = state.global.ntp ? [{ server: state.global.ntp, priority: null }] : [{ server: 'pool.ntp.org', priority: null }];
                    if (!state.global.snmpCommunities || !Array.isArray(state.global.snmpCommunities)) state.global.snmpCommunities = [];
                    if (!state.global.snmpUsers || !Array.isArray(state.global.snmpUsers)) state.global.snmpUsers = [];
                    if (!state.global.snmpHosts || !Array.isArray(state.global.snmpHosts)) state.global.snmpHosts = [];
                    if (!state.global.classofservice) state.global.classofservice = { dot1pMapping: [], ipDscpMapping: [], trust: null };
                    if (!state.global.cosQueue) state.global.cosQueue = { strict: [] };
                    if (!state.routedInterfaces || !Array.isArray(state.routedInterfaces)) {
                        state.routedInterfaces = [{ id: 'vlan-1', ip: '' }];
                    }
                    init(); 
                    alert('Configuration loaded successfully!'); 
                } catch(e){
                    alert('Error loading JSON: ' + e.message); 
                } 
            };
            r.readAsText(file); input.value = '';
        }

        function openImporterModal() { document.getElementById('importer-modal').classList.remove('hidden'); }
        function closeImporterModal() { document.getElementById('importer-modal').classList.add('hidden'); }
        // Helper: Expand port ranges (e.g., "1-4, 6, 8-10" -> [1,2,3,4,6,8,9,10])
        function expandPortRanges(rangeStr) {
            const ports = [];
            const parts = rangeStr.split(',').map(s => s.trim());
            for (const part of parts) {
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(n => parseInt(n.trim()));
                    if (!isNaN(start) && !isNaN(end)) {
                        for (let i = start; i <= end; i++) ports.push(i);
                    }
                } else {
                    const num = parseInt(part);
                    if (!isNaN(num)) ports.push(num);
                }
            }
            return ports;
        }

        // Helper: Condense consecutive ports into ranges for Ruckus CLI (e.g., [1,2,3,4,6,8,9,10] -> "1/1/1 to 1/1/4, 1/1/6, 1/1/8 to 1/1/10")
        function condensePortRanges(portList, prefix = '1/1/') {
            if (portList.length === 0) return '';
            
            // Sort and get unique ports
            const sorted = [...new Set(portList.map(p => {
                // Handle both "1/1/5" format and just numbers
                if (typeof p === 'string' && p.includes('/')) {
                    const parts = p.split('/');
                    return parseInt(parts[parts.length - 1]);
                }
                return parseInt(p);
            }))].sort((a, b) => a - b);
            
            const ranges = [];
            let rangeStart = sorted[0];
            let rangeEnd = sorted[0];
            
            for (let i = 1; i < sorted.length; i++) {
                if (sorted[i] === rangeEnd + 1) {
                    rangeEnd = sorted[i];
                } else {
                    if (rangeStart === rangeEnd) {
                        ranges.push(`${prefix}${rangeStart}`);
                    } else {
                        ranges.push(`${prefix}${rangeStart} to ${prefix}${rangeEnd}`);
                    }
                    rangeStart = sorted[i];
                    rangeEnd = sorted[i];
                }
            }
            
            // Add final range
            if (rangeStart === rangeEnd) {
                ranges.push(`${prefix}${rangeStart}`);
            } else {
                ranges.push(`${prefix}${rangeStart} to ${prefix}${rangeEnd}`);
            }
            
            return ranges.join(', ');
        }

        function parseAndLoadConfig() {
            const text = document.getElementById('import-text').value.trim();
            if (!text) { alert('Please paste a configuration first.'); return; }
            
            const lines = text.split('\n').map(l => l.trim());
            let detectedBrand = null;
            
            // Detect brand - improved detection
            if (text.match(/PowerConnect|Dell/i) || text.match(/interface ethernet 1\/[gx]/i) || text.match(/switchport general pvid/i)) {
                detectedBrand = 'dell';
            } else if (text.match(/trunk\s+\d+.*trk\d+/i) || text.match(/spanning-tree force-version/i) || text.match(/loop-protect/i)) {
                detectedBrand = 'aruba';
            } else if (text.match(/lag\s+["'].*["']/i) || text.match(/router-interface ve/i) || text.match(/stack unit/i) || text.match(/ethe 1\/1\//i)) {
                detectedBrand = 'ruckus';
            } else if (text.match(/interface lag/i) || text.match(/vlan pvid/i) || text.match(/M4300/i) || text.match(/interface 1\/0\//i)) {
                detectedBrand = 'netgear';
            }
            
            if (!detectedBrand) {
                if (confirm('Could not auto-detect switch brand. Attempt HP/Aruba parsing? (Click Cancel to abort)')) {
                    detectedBrand = 'aruba';
                } else {
                    return;
                }
            }
            
            // Reset state but preserve structure
            const oldPortCount = state.portCount;
            state.vlans = [{ id: 'vlan-1', name: 'Default', vid: 1, color: '#64748b' }];
            state.lags = [];
            state.ports = {};
            state.routedInterfaces = [];
            state.activeVlanId = 'vlan-1';
            state.activeLagId = null;
            
            // Initialize global arrays
            state.global.dns = [];
            state.global.ntp = [];
            state.global.snmpCommunities = [];
            state.global.snmpUsers = [];
            state.global.snmpHosts = [];
            state.global.classofservice = { dot1pMapping: [], ipDscpMapping: [], trust: null };
            state.global.cosQueue = { strict: [] };
            
            // Parse global settings - common across vendors
            const hostnameMatch = text.match(/hostname\s+["']?([\w-]+)["']?/i);
            if (hostnameMatch) state.global.hostname = hostnameMatch[1];
            
            const gatewayMatch = text.match(/ip\s+(?:default-)?gateway\s+(\d+\.\d+\.\d+\.\d+)/i) || 
                                  text.match(/ip\s+route\s+0\.0\.0\.0\s+0\.0\.0\.0\s+(\d+\.\d+\.\d+\.\d+)/i) ||
                                  text.match(/ip\s+route\s+0\.0\.0\.0\/0\s+(\d+\.\d+\.\d+\.\d+)/i);
            if (gatewayMatch) state.global.gateway = gatewayMatch[1];
            
            // DNS - multiple servers possible
            const dnsMatches = text.matchAll(/ip\s+(?:dns\s+)?server-address\s+(\d+\.\d+\.\d+\.\d+)/gi);
            for (const match of dnsMatches) {
                state.global.dns.push(match[1]);
            }
            if (state.global.dns.length === 0) {
                const singleDns = text.match(/ip\s+name-server\s+(\d+\.\d+\.\d+\.\d+)/i);
                if (singleDns) state.global.dns.push(singleDns[1]);
            }
            
            // NTP - multiple servers with priorities
            const ntpMatches = text.matchAll(/sntp\s+server\s+(?:priority\s+\d+\s+)?(\d+\.\d+\.\d+\.\d+|\S+)/gi);
            for (const match of ntpMatches) {
                const priorityMatch = match[0].match(/priority\s+(\d+)/i);
                state.global.ntp.push({ server: match[1], priority: priorityMatch ? parseInt(priorityMatch[1]) : null });
            }
            if (state.global.ntp.length === 0) {
                const ntpMatch = text.match(/ntp\s+server\s+(\S+)/i);
                if (ntpMatch) state.global.ntp.push({ server: ntpMatch[1], priority: null });
            }
            
            // SNMP parsing - comprehensive
            const snmpLocMatch = text.match(/snmp-server\s+(?:sysname|location)\s+["']?([^"'\n]+)["']?/i);
            if (snmpLocMatch) state.global.snmpLocation = snmpLocMatch[1].trim();
            
            const snmpContactMatch = text.match(/snmp-server\s+contact\s+["']?([^"'\n]+)["']?/i);
            if (snmpContactMatch) state.global.snmpContact = snmpContactMatch[1].trim();
            
            const snmpSysnameMatch = text.match(/snmp-server\s+sysname\s+["']?([^"'\n]+)["']?/i);
            if (snmpSysnameMatch) state.global.snmpSysname = snmpSysnameMatch[1].trim();
            
            // SNMP Communities - multiple with access levels
            const snmpCommMatches = text.matchAll(/snmp-server\s+community\s+["']?([^"'\s]+)["']?\s+(\w+)/gi);
            for (const match of snmpCommMatches) {
                const access = match[2].toLowerCase();
                state.global.snmpCommunities.push({ 
                    community: match[1], 
                    access: access.includes('rw') ? 'rw' : access.includes('operator') ? 'operator' : access.includes('unrestricted') ? 'unrestricted' : 'ro' 
                });
            }
            
            // SNMP Users (v3)
            const snmpUserMatch = text.match(/snmp-server\s+user\s+["']?(\S+)["']?\s+(\S+)\s+auth-(\S+)-key\s+(\S+)\s+priv-(\S+)-key\s+(\S+)/i);
            if (snmpUserMatch) {
                state.global.snmpUsers.push({
                    username: snmpUserMatch[1],
                    auth: snmpUserMatch[4],
                    priv: snmpUserMatch[6]
                });
            }
            
            // SNMP Hosts (traps)
            const snmpHostMatch = text.match(/snmp-server\s+host\s+(\d+\.\d+\.\d+\.\d+)\s+(\S+)\s+traps\s+(\S+)/i);
            if (snmpHostMatch) {
                state.global.snmpHosts.push({
                    host: snmpHostMatch[1],
                    community: snmpHostMatch[2],
                    version: snmpHostMatch[3]
                });
            }
            
            // Timezone
            const tzMatch = text.match(/time\s+timezone\s+(-?\d+)/i) || text.match(/clock\s+timezone\s+(-?\d+)/i);
            if (tzMatch) {
                const tzZoneMatch = text.match(/zone\s+["']?([^"'\n]+)["']?/i);
                state.global.timezone = { offset: parseInt(tzMatch[1]), zone: tzZoneMatch ? tzZoneMatch[1] : null };
            }
            
            // Daylight time
            const dstMatch = text.match(/time\s+daylight-time-rule\s+(\S+)/i) || text.match(/clock\s+summer-time\s+recurring\s+(\S+)/i);
            if (dstMatch) state.global.daylightTime = dstMatch[1];
            
            // Stack member
            const stackMatch = text.match(/stack\s+member\s+(\d+)\s+(\d+)/i);
            if (stackMatch) {
                state.global.stackMember = { unit: parseInt(stackMatch[1]), member: parseInt(stackMatch[2]) };
            }
            
            // IP Routing
            if (text.match(/no\s+ip\s+routing/i)) state.global.ipRouting = false;
            
            // Console timeout
            const consoleTimeoutMatch = text.match(/console\s+idle-timeout\s+(\d+)/i);
            if (consoleTimeoutMatch) state.global.consoleTimeout = parseInt(consoleTimeoutMatch[1]);
            
            // Mirror port (HP)
            const mirrorMatch = text.match(/mirror\s+(\d+)\s+port\s+(\d+)/i);
            if (mirrorMatch) {
                state.global.mirrorPort = { mirrorId: parseInt(mirrorMatch[1]), port: parseInt(mirrorMatch[2]) };
            }
            
            if (detectedBrand === 'aruba') {
                // HP/Aruba parsing
                const vlanBlocks = [];
                let currentVlan = null;
                let vlanLines = [];
                
                // First pass: collect VLAN blocks (may span multiple lines)
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // Start of VLAN block
                    const vlanMatch = line.match(/^vlan\s+(\d+)/i);
                    if (vlanMatch) {
                        if (currentVlan) vlanBlocks.push({ ...currentVlan, lines: vlanLines });
                        currentVlan = { vid: parseInt(vlanMatch[1]), name: '', untagged: [], tagged: [], ip: null, exitLine: -1 };
                        vlanLines = [line];
                        continue;
                    }
                    
                    if (currentVlan) {
                        vlanLines.push(line);
                        
                        // VLAN name
                        const nameMatch = line.match(/^\s*name\s+["']?([^"'\n]+)["']?/i);
                        if (nameMatch) currentVlan.name = nameMatch[1].trim();
                        
                        // IP address (L3)
                        const ipMatch = line.match(/^\s*ip\s+address\s+(\d+\.\d+\.\d+\.\d+)\s+(\d+\.\d+\.\d+\.\d+)/i);
                        if (ipMatch) {
                            const cidr = ipMaskToCidr(ipMatch[2]);
                            currentVlan.ip = `${ipMatch[1]}/${cidr}`;
                        }
                        
                        // Exit/end of VLAN block
                        if (line.match(/^\s*(exit|end)/i)) {
                            currentVlan.exitLine = i;
                            vlanBlocks.push({ ...currentVlan, lines: vlanLines });
                            currentVlan = null;
                            vlanLines = [];
                        }
                    }
                }
                if (currentVlan) vlanBlocks.push({ ...currentVlan, lines: vlanLines });
                
                // Second pass: parse untagged/tagged with multi-line support
                vlanBlocks.forEach(block => {
                    const vlanId = `vlan-${block.vid}`;
                    const vlanName = block.name || `VLAN ${block.vid}`;
                    
                    // Check if VLAN already exists
                    let vlan = state.vlans.find(v => v.vid === block.vid);
                    if (!vlan) {
                        vlan = { id: vlanId, name: vlanName, vid: block.vid, color: `#${Math.floor(Math.random()*16777215).toString(16)}` };
                        state.vlans.push(vlan);
                    }
                    
                    // Parse untagged/tagged from the block lines
                    // Handle multi-line: "untagged 1-4," on one line, "6, 8-10" on next
                    let untaggedStr = '';
                    let taggedStr = '';
                    let inUntagged = false;
                    let inTagged = false;
                    
                    for (const line of block.lines) {
                        // Check for "no untagged" directive
                        if (line.match(/^\s*no\s+untagged/i)) {
                            // Remove all ports from this VLAN's untagged list
                            // We'll handle this by not adding any untagged ports
                            inUntagged = false;
                            untaggedStr = '';
                            continue;
                        }
                        
                        // Start of untagged line
                        if (line.match(/^\s*untagged\s+/i)) {
                            inUntagged = true;
                            inTagged = false;
                            untaggedStr = line.replace(/^\s*untagged\s+/i, '');
                        }
                        // Continuation of untagged (line ends with comma or is continuation)
                        else if (inUntagged && (line.match(/^[\d,\s-]+$/) || line.endsWith(','))) {
                            untaggedStr += ' ' + line;
                        }
                        // Start of tagged line
                        else if (line.match(/^\s*tagged\s+/i)) {
                            inTagged = true;
                            inUntagged = false;
                            taggedStr = line.replace(/^\s*tagged\s+/i, '');
                        }
                        // Continuation of tagged
                        else if (inTagged && (line.match(/^[\d,\s-]+$/) || line.endsWith(','))) {
                            taggedStr += ' ' + line;
                        }
                        // End of block
                        else if (line.match(/^\s*(exit|end)/i)) {
                            inUntagged = false;
                            inTagged = false;
                        }
                        else {
                            inUntagged = false;
                            inTagged = false;
                        }
                    }
                    
                    // Process untagged ports
                    if (untaggedStr) {
                        const ports = expandPortRanges(untaggedStr.replace(/,/g, ' '));
                        ports.forEach(portNum => {
                            if (portNum > 0 && portNum <= 48) {
                                if (!state.ports[portNum]) {
                                    state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                                }
                                state.ports[portNum].nativeVlanId = vlanId;
                                // Remove from tagged if present
                                if (state.ports[portNum].taggedVlans) {
                                    state.ports[portNum].taggedVlans = state.ports[portNum].taggedVlans.filter(t => t !== vlanId);
                                }
                            }
                        });
                    }
                    
                    // Process tagged ports
                    if (taggedStr) {
                        const ports = expandPortRanges(taggedStr.replace(/,/g, ' '));
                        ports.forEach(portNum => {
                            if (portNum > 0 && portNum <= 48) {
                                if (!state.ports[portNum]) {
                                    state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                                }
                                // Add to tagged if not native
                                if (!state.ports[portNum].taggedVlans) state.ports[portNum].taggedVlans = [];
                                if (state.ports[portNum].nativeVlanId !== vlanId && !state.ports[portNum].taggedVlans.includes(vlanId)) {
                                    state.ports[portNum].taggedVlans.push(vlanId);
                                }
                            }
                        });
                    }
                    
                    // L3 interface
                    if (block.ip) {
                        state.routedInterfaces.push({ id: vlanId, ip: block.ip });
                    }
                    
                    // Parse VLAN-specific settings from block lines
                    const qosMatch = block.lines.find(l => l.match(/qos\s+priority\s+(\d+)/i));
                    if (qosMatch) {
                        const qosVal = qosMatch.match(/qos\s+priority\s+(\d+)/i)[1];
                        if (!vlan.qos) vlan.qos = parseInt(qosVal);
                    }
                    
                    const igmpMatch = block.lines.find(l => l.match(/ip\s+igmp/i));
                    if (igmpMatch) {
                        if (!vlan.igmp) vlan.igmp = true;
                    }
                    
                    const voiceMatch = block.lines.find(l => l.match(/^\s*voice\s*$/i));
                    if (voiceMatch) {
                        if (!vlan.voice) vlan.voice = true;
                    }
                });
                
                // Parse interface names/descriptions (HP format: "interface 25\n   name "Intercoms"")
                const interfaceNameMatches = text.matchAll(/interface\s+(\d+)\s*\n[^\n]*name\s+["']?([^"'\n]+)["']?/gi);
                for (const match of interfaceNameMatches) {
                    const portNum = parseInt(match[1]);
                    if (portNum > 0 && portNum <= 52) {
                        if (!state.ports[portNum]) {
                            state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                        }
                        state.ports[portNum].customLabel = match[2].trim();
                    }
                }
                
                // Parse STP bpdu-protection per port
                const stpBpduMatches = text.matchAll(/spanning-tree\s+(\d+)\s+bpdu-protection/gi);
                for (const match of stpBpduMatches) {
                    const portNum = parseInt(match[1]);
                    if (portNum > 0 && portNum <= 52) {
                        if (!state.ports[portNum]) {
                            state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                        }
                        if (!state.ports[portNum].stp) state.ports[portNum].stp = {};
                        state.ports[portNum].stp.bpduProtection = true;
                    }
                }
                
                // Parse loop-protect ports
                const loopProtectMatch = text.match(/loop-protect\s+([\d,\s-]+)/i);
                if (loopProtectMatch) {
                    const ports = expandPortRanges(loopProtectMatch[1]);
                    ports.forEach(portNum => {
                        if (portNum > 0 && portNum <= 52) {
                            if (!state.ports[portNum]) {
                                state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                            }
                            if (!state.ports[portNum].loopProtect) state.ports[portNum].loopProtect = true;
                        }
                    });
                }
                
                // Parse trunk/LAG definitions
                const trunkMatch = text.match(/trunk\s+([\d,\s-]+)\s+trk(\d+)\s+(\w+)/gi);
                if (trunkMatch) {
                    trunkMatch.forEach(match => {
                        const parts = match.match(/trunk\s+([\d,\s-]+)\s+trk(\d+)\s+(\w+)/i);
                        if (parts) {
                            const lagId = parseInt(parts[2]);
                            const lagType = parts[3].toLowerCase() === 'lacp' ? 'lacp' : 'static';
                            const ports = expandPortRanges(parts[1]);
                            
                            // Find or create LAG
                            let lag = state.lags.find(l => l.id === lagId);
                            if (!lag) {
                                lag = { id: lagId, name: `Trunk ${lagId}`, type: lagType };
                                state.lags.push(lag);
                            }
                            
                            // Assign ports to LAG
                            ports.forEach(portNum => {
                                if (portNum > 0 && portNum <= 48) {
                                    if (!state.ports[portNum]) {
                                        state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                                    }
                                    state.ports[portNum].lagId = lagId;
                                }
                            });
                        }
                    });
                }
                
            } else if (detectedBrand === 'ruckus') {
                // Ruckus parsing - comprehensive
                // Parse LAGs first
                const lagMatches = text.matchAll(/lag\s+["']?([^"'\n]+)["']?\s+(dynamic|static)\s+id\s+(\d+)/gi);
                for (const match of lagMatches) {
                    const lagId = parseInt(match[3]);
                    const lagType = match[2].toLowerCase() === 'dynamic' ? 'lacp' : 'static';
                    if (!state.lags.find(l => l.id === lagId)) {
                        state.lags.push({ id: lagId, name: match[1].trim(), type: lagType });
                    }
                }
                
                // Parse LAG member ports
                const lagPortMatches = text.matchAll(/lag\s+["']?[^"'\n]+["']?\s+\w+\s+id\s+(\d+)[\s\S]*?ports\s+ethe\s+([\d/\s]+)/gi);
                for (const match of lagPortMatches) {
                    const lagId = parseInt(match[1]);
                    const portStrs = match[2].trim().split(/\s+/);
                    portStrs.forEach(portStr => {
                        const parts = portStr.split('/');
                        const portNum = parseInt(parts[parts.length - 1]);
                        if (portNum > 0 && portNum <= 48) {
                            if (!state.ports[portNum]) {
                                state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                            }
                            state.ports[portNum].lagId = lagId;
                        }
                    });
                }
                
                // Parse VLANs
                const vlanMatches = text.matchAll(/vlan\s+(\d+)\s+name\s+["']?([^"'\n]+)["']?/gi);
                for (const match of vlanMatches) {
                    const vid = parseInt(match[1]);
                    const vlanId = `vlan-${vid}`;
                    if (!state.vlans.find(v => v.vid === vid)) {
                        state.vlans.push({ id: vlanId, name: match[2].trim(), vid, color: `#${Math.floor(Math.random()*16777215).toString(16)}` });
                    }
                }
                
                // Parse untagged/tagged (Ruckus format: "untagged ethe 1/1/1 to 1/1/4, 1/1/6")
                const vlanSections = text.split(/vlan\s+\d+/i);
                vlanSections.forEach((section, idx) => {
                    if (idx === 0) return; // Skip before first VLAN
                    const vlanMatch = section.match(/^(\d+)/);
                    if (!vlanMatch) return;
                    const vid = parseInt(vlanMatch[1]);
                    const vlanId = `vlan-${vid}`;
                    
                    // Extract untagged ports (handle ranges like "1/1/1 to 1/1/4")
                    const untaggedMatch = section.match(/untagged\s+ethe\s+([\d/\s,to-]+)/i);
                    if (untaggedMatch) {
                        const portStr = untaggedMatch[1];
                        // Handle "1/1/1 to 1/1/4" format
                        const rangeMatches = portStr.matchAll(/(\d+)\/(\d+)\/(\d+)\s+to\s+(\d+)\/(\d+)\/(\d+)/gi);
                        for (const rangeMatch of rangeMatches) {
                            const start = parseInt(rangeMatch[3]);
                            const end = parseInt(rangeMatch[6]);
                            for (let p = start; p <= end; p++) {
                                if (p > 0 && p <= 48) {
                                    if (!state.ports[p]) {
                                        state.ports[p] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                                    }
                                    state.ports[p].nativeVlanId = vlanId;
                                }
                            }
                        }
                        // Handle individual ports
                        const individualPorts = portStr.replace(/\d+\/\d+\/\d+\s+to\s+\d+\/\d+\/\d+/gi, '').match(/\d+\/\d+\/(\d+)/g);
                        if (individualPorts) {
                            individualPorts.forEach(portStr => {
                                const parts = portStr.split('/');
                                const portNum = parseInt(parts[parts.length - 1]);
                                if (portNum > 0 && portNum <= 48) {
                                    if (!state.ports[portNum]) {
                                        state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                                    }
                                    state.ports[portNum].nativeVlanId = vlanId;
                                }
                            });
                        }
                    }
                    
                    // Extract tagged ports (same format handling)
                    const taggedMatch = section.match(/tagged\s+ethe\s+([\d/\s,to-]+)/i);
                    if (taggedMatch) {
                        const portStr = taggedMatch[1];
                        const rangeMatches = portStr.matchAll(/(\d+)\/(\d+)\/(\d+)\s+to\s+(\d+)\/(\d+)\/(\d+)/gi);
                        for (const rangeMatch of rangeMatches) {
                            const start = parseInt(rangeMatch[3]);
                            const end = parseInt(rangeMatch[6]);
                            for (let p = start; p <= end; p++) {
                                if (p > 0 && p <= 48) {
                                    if (!state.ports[p]) {
                                        state.ports[p] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                                    }
                                    if (!state.ports[p].taggedVlans) state.ports[p].taggedVlans = [];
                                    if (!state.ports[p].taggedVlans.includes(vlanId)) {
                                        state.ports[p].taggedVlans.push(vlanId);
                                    }
                                }
                            }
                        }
                        const individualPorts = portStr.replace(/\d+\/\d+\/\d+\s+to\s+\d+\/\d+\/\d+/gi, '').match(/\d+\/\d+\/(\d+)/g);
                        if (individualPorts) {
                            individualPorts.forEach(portStr => {
                                const parts = portStr.split('/');
                                const portNum = parseInt(parts[parts.length - 1]);
                                if (portNum > 0 && portNum <= 48) {
                                    if (!state.ports[portNum]) {
                                        state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                                    }
                                    if (!state.ports[portNum].taggedVlans) state.ports[portNum].taggedVlans = [];
                                    if (!state.ports[portNum].taggedVlans.includes(vlanId)) {
                                        state.ports[portNum].taggedVlans.push(vlanId);
                                    }
                                }
                            });
                        }
                    }
                    
                    // L3 interface (VE)
                    const veMatch = section.match(/interface\s+ve\s+(\d+)\s+ip\s+address\s+(\d+\.\d+\.\d+\.\d+)\s+(\d+\.\d+\.\d+\.\d+)/i);
                    if (veMatch && parseInt(veMatch[1]) === vid) {
                        const cidr = ipMaskToCidr(veMatch[3]);
                        state.routedInterfaces.push({ id: vlanId, ip: `${veMatch[2]}/${cidr}` });
                    }
                });
                
                // Parse voice-vlan on ports
                const voiceVlanMatch = text.match(/interface\s+ethernet\s+(\d+)\/(\d+)\/(\d+)\s+voice-vlan\s+(\d+)/i);
                if (voiceVlanMatch) {
                    const portNum = parseInt(voiceVlanMatch[3]);
                    if (portNum > 0 && portNum <= 48) {
                        if (!state.ports[portNum]) {
                            state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                        }
                        const voiceVid = parseInt(voiceVlanMatch[4]);
                        const voiceVlanId = `vlan-${voiceVid}`;
                        if (!state.ports[portNum].voiceVlan) state.ports[portNum].voiceVlan = voiceVlanId;
                    }
                }
                
                // Parse manager registrar (Ruckus cloud)
                const managerMatch = text.match(/manager\s+registrar-list\s+(\S+)\s+(\d+\.\d+\.\d+\.\d+)/i);
                if (managerMatch) {
                    const portMatch = text.match(/manager\s+port-list\s+(\d+)/i);
                    state.global.managerRegistrar = {
                        device: managerMatch[1],
                        ip: managerMatch[2],
                        port: portMatch ? parseInt(portMatch[1]) : null
                    };
                }
                
            } else if (detectedBrand === 'netgear') {
                // Netgear parsing - comprehensive
                // Parse VLAN database
                const vlanDbMatch = text.match(/vlan\s+database[\s\S]*?vlan\s+([\d,\s-]+)/i);
                if (vlanDbMatch) {
                    const vlanIds = expandPortRanges(vlanDbMatch[1].replace(/,/g, ' '));
                    vlanIds.forEach(vid => {
                        const vlanId = `vlan-${vid}`;
                        if (!state.vlans.find(v => v.vid === vid)) {
                            state.vlans.push({ id: vlanId, name: `VLAN ${vid}`, vid, color: `#${Math.floor(Math.random()*16777215).toString(16)}` });
                        }
                    });
                }
                
                // Parse VLAN names
                const vlanNameMatches = text.matchAll(/vlan\s+name\s+(\d+)\s+["']?([^"'\n]+)["']?/gi);
                for (const match of vlanNameMatches) {
                    const vid = parseInt(match[1]);
                    const vlan = state.vlans.find(v => v.vid === vid);
                    if (vlan) vlan.name = match[2].trim();
                }
                
                // Parse VLAN routing
                const vlanRoutingMatches = text.matchAll(/vlan\s+routing\s+(\d+)\s+(\d+)/gi);
                for (const match of vlanRoutingMatches) {
                    const vid = parseInt(match[1]);
                    const vlan = state.vlans.find(v => v.vid === vid);
                    if (vlan) {
                        if (!vlan.routing) vlan.routing = parseInt(match[2]);
                    }
                }
                
                // Parse interface configurations
                const interfaceMatches = text.matchAll(/interface\s+1\/0\/(\d+)[\s\S]*?(?=interface\s+1\/0\/|$)/gi);
                for (const interfaceMatch of interfaceMatches) {
                    const portNum = parseInt(interfaceMatch[1]);
                    if (portNum > 0 && portNum <= 52) {
                        if (!state.ports[portNum]) {
                            state.ports[portNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                        }
                        const intfBlock = interfaceMatch[0];
                        
                        // Description
                        const descMatch = intfBlock.match(/description\s+["']?([^"'\n]+)["']?/i);
                        if (descMatch) state.ports[portNum].customLabel = descMatch[1].trim();
                        
                        // PVID (native VLAN)
                        const pvidMatch = intfBlock.match(/vlan\s+pvid\s+(\d+)/i);
                        if (pvidMatch) {
                            const vid = parseInt(pvidMatch[1]);
                            const vlanId = `vlan-${vid}`;
                            state.ports[portNum].nativeVlanId = vlanId;
                        }
                        
                        // VLAN participation include (tagged)
                        const includeMatch = intfBlock.match(/vlan\s+participation\s+include\s+([\d,\s-]+)/i);
                        if (includeMatch) {
                            const vids = expandPortRanges(includeMatch[1].replace(/,/g, ' '));
                            vids.forEach(vid => {
                                const vlanId = `vlan-${vid}`;
                                if (!state.ports[portNum].taggedVlans) state.ports[portNum].taggedVlans = [];
                                if (state.ports[portNum].nativeVlanId !== vlanId && !state.ports[portNum].taggedVlans.includes(vlanId)) {
                                    state.ports[portNum].taggedVlans.push(vlanId);
                                }
                            });
                        }
                        
                        // VLAN tagging
                        const taggingMatch = intfBlock.match(/vlan\s+tagging\s+([\d,\s-]+)/i);
                        if (taggingMatch) {
                            const vids = expandPortRanges(taggingMatch[1].replace(/,/g, ' '));
                            vids.forEach(vid => {
                                const vlanId = `vlan-${vid}`;
                                if (!state.ports[portNum].taggedVlans) state.ports[portNum].taggedVlans = [];
                                if (!state.ports[portNum].taggedVlans.includes(vlanId)) {
                                    state.ports[portNum].taggedVlans.push(vlanId);
                                }
                            });
                        }
                        
                        // PTP clock
                        if (intfBlock.match(/ptp\s+clock\s+e2e-transparent/i)) {
                            if (!state.ports[portNum].ptp) state.ports[portNum].ptp = { e2eTransparent: true };
                        }
                        
                        // Speed/duplex
                        const speedMatch = intfBlock.match(/speed\s+(\d+)\s+(\S+)/i);
                        if (speedMatch) {
                            if (!state.ports[portNum].speed) state.ports[portNum].speed = {};
                            state.ports[portNum].speed.value = parseInt(speedMatch[1]);
                            state.ports[portNum].speed.duplex = speedMatch[2];
                        }
                        
                        // No auto-negotiate
                        if (intfBlock.match(/no\s+auto-negotiate/i)) {
                            if (!state.ports[portNum].autoNegotiate) state.ports[portNum].autoNegotiate = false;
                        }
                    }
                }
                
                // Parse LAGs
                const lagMatches = text.matchAll(/interface\s+lag\s+(\d+)[\s\S]*?(?=interface\s+lag|$)/gi);
                for (const lagMatch of lagMatches) {
                    const lagId = parseInt(lagMatch[1]);
                    if (!state.lags.find(l => l.id === lagId)) {
                        state.lags.push({ id: lagId, name: `LAG ${lagId}`, type: 'lacp' });
                    }
                }
                
                // Parse interface VLAN (L3)
                const vlanIntfMatches = text.matchAll(/interface\s+vlan\s+(\d+)[\s\S]*?ip\s+address\s+(\d+\.\d+\.\d+\.\d+)\s+(\d+\.\d+\.\d+\.\d+)/gi);
                for (const match of vlanIntfMatches) {
                    const vid = parseInt(match[1]);
                    const vlanId = `vlan-${vid}`;
                    const cidr = ipMaskToCidr(match[3]);
                    state.routedInterfaces.push({ id: vlanId, ip: `${match[2]}/${cidr}` });
                }
                
            } else if (detectedBrand === 'dell') {
                // Dell parsing - comprehensive
                // Parse VLAN database
                const vlanDbMatch = text.match(/vlan\s+database[\s\S]*?vlan\s+([\d,\s-]+)/i);
                if (vlanDbMatch) {
                    const vlanIds = expandPortRanges(vlanDbMatch[1].replace(/,/g, ' '));
                    vlanIds.forEach(vid => {
                        const vlanId = `vlan-${vid}`;
                        if (!state.vlans.find(v => v.vid === vid)) {
                            state.vlans.push({ id: vlanId, name: `VLAN ${vid}`, vid, color: `#${Math.floor(Math.random()*16777215).toString(16)}` });
                        }
                    });
                }
                
                // Parse interface VLAN names
                const vlanNameMatches = text.matchAll(/interface\s+vlan\s+(\d+)\s+name\s+["']?([^"'\n]+)["']?/gi);
                for (const match of vlanNameMatches) {
                    const vid = parseInt(match[1]);
                    const vlan = state.vlans.find(v => v.vid === vid);
                    if (vlan) vlan.name = match[2].trim();
                }
                
                // Parse interface ethernet configurations
                const ethernetMatches = text.matchAll(/interface\s+ethernet\s+1\/([gx])(\d+)[\s\S]*?(?=interface\s+ethernet|$)/gi);
                for (const ethernetMatch of ethernetMatches) {
                    const portType = ethernetMatch[1];
                    const portNum = parseInt(ethernetMatch[2]);
                    // Convert Dell port format: 1/g1 = port 1, 1/xg1 = port 25 (assuming 24 port + SFP)
                    const actualPortNum = portType === 'x' ? portNum + 24 : portNum;
                    
                    if (actualPortNum > 0 && actualPortNum <= 52) {
                        if (!state.ports[actualPortNum]) {
                            state.ports[actualPortNum] = { nativeVlanId: null, taggedVlans: [], customLabel: null, isPoe: undefined, lagId: null };
                        }
                        const intfBlock = ethernetMatch[0];
                        
                        // Switchport mode
                        const modeMatch = intfBlock.match(/switchport\s+mode\s+(\w+)/i);
                        if (modeMatch) {
                            if (!state.ports[actualPortNum].switchportMode) state.ports[actualPortNum].switchportMode = modeMatch[1].toLowerCase();
                        }
                        
                        // Access VLAN
                        const accessMatch = intfBlock.match(/switchport\s+access\s+vlan\s+(\d+)/i);
                        if (accessMatch) {
                            const vid = parseInt(accessMatch[1]);
                            const vlanId = `vlan-${vid}`;
                            state.ports[actualPortNum].nativeVlanId = vlanId;
                        }
                        
                        // General mode PVID
                        const pvidMatch = intfBlock.match(/switchport\s+general\s+pvid\s+(\d+)/i);
                        if (pvidMatch) {
                            const vid = parseInt(pvidMatch[1]);
                            const vlanId = `vlan-${vid}`;
                            state.ports[actualPortNum].nativeVlanId = vlanId;
                        }
                        
                        // General allowed VLAN add (tagged)
                        const allowedMatches = intfBlock.matchAll(/switchport\s+general\s+allowed\s+vlan\s+add\s+([\d,\s-]+)(?:\s+tagged)?/gi);
                        for (const allowedMatch of allowedMatches) {
                            const vids = expandPortRanges(allowedMatch[1].replace(/,/g, ' '));
                            vids.forEach(vid => {
                                const vlanId = `vlan-${vid}`;
                                if (!state.ports[actualPortNum].taggedVlans) state.ports[actualPortNum].taggedVlans = [];
                                if (state.ports[actualPortNum].nativeVlanId !== vlanId && !state.ports[actualPortNum].taggedVlans.includes(vlanId)) {
                                    state.ports[actualPortNum].taggedVlans.push(vlanId);
                                }
                            });
                        }
                        
                        // Trunk allowed VLAN
                        const trunkMatches = intfBlock.matchAll(/switchport\s+trunk\s+allowed\s+vlan\s+add\s+([\d,\s-]+)/gi);
                        for (const trunkMatch of trunkMatches) {
                            const vids = expandPortRanges(trunkMatch[1].replace(/,/g, ' '));
                            vids.forEach(vid => {
                                const vlanId = `vlan-${vid}`;
                                if (!state.ports[actualPortNum].taggedVlans) state.ports[actualPortNum].taggedVlans = [];
                                if (!state.ports[actualPortNum].taggedVlans.includes(vlanId)) {
                                    state.ports[actualPortNum].taggedVlans.push(vlanId);
                                }
                            });
                        }
                        
                        // Voice VLAN
                        const voiceMatch = intfBlock.match(/voice\s+vlan\s+(\d+)/i);
                        if (voiceMatch) {
                            const vid = parseInt(voiceMatch[1]);
                            const vlanId = `vlan-${vid}`;
                            if (!state.ports[actualPortNum].voiceVlan) state.ports[actualPortNum].voiceVlan = vlanId;
                        }
                        
                        // STP portfast
                        if (intfBlock.match(/spanning-tree\s+portfast/i)) {
                            if (!state.ports[actualPortNum].stp) state.ports[actualPortNum].stp = {};
                            state.ports[actualPortNum].stp.portfast = true;
                        }
                        
                        // LLDP
                        const lldpMatch = intfBlock.match(/lldp\s+transmit-tlv\s+([\w-]+)/i);
                        if (lldpMatch) {
                            if (!state.ports[actualPortNum].lldp) state.ports[actualPortNum].lldp = [];
                            state.ports[actualPortNum].lldp.push(lldpMatch[1]);
                        }
                    }
                }
                
                // Parse port-channel (LAG)
                const portChannelMatches = text.matchAll(/interface\s+port-channel\s+(\d+)[\s\S]*?(?=interface\s+port-channel|$)/gi);
                for (const pcMatch of portChannelMatches) {
                    const lagId = parseInt(pcMatch[1]);
                    if (!state.lags.find(l => l.id === lagId)) {
                        state.lags.push({ id: lagId, name: `Port-Channel ${lagId}`, type: 'lacp' });
                    }
                }
            }
            
            // Ensure default routed interface if none exists
            if (state.routedInterfaces.length === 0) {
                state.routedInterfaces.push({ id: 'vlan-1', ip: '' });
            }
            
            // Reinitialize UI
            init();
            closeImporterModal();
            alert(`Configuration imported successfully (${detectedBrand.toUpperCase()})!`);
        }
        
        // Helper: Convert subnet mask to CIDR
        function ipMaskToCidr(mask) {
            const parts = mask.split('.');
            let cidr = 0;
            for (const part of parts) {
                const num = parseInt(part);
                cidr += (num >>> 0).toString(2).split('1').length - 1;
            }
            return cidr;
        }

        function openExportModal() {
            const modal = document.getElementById('export-modal');
            const source = document.getElementById('export-area');
            const clone = source.cloneNode(true);
            clone.querySelector('#export-legend').classList.remove('hidden');
            const legend = clone.querySelector('#export-legend');
            state.vlans.forEach(v => legend.innerHTML += `<div class="flex items-center gap-2"><div class="w-4 h-4 rounded" style="background-color:${v.color}"></div><span class="text-sm">${v.name} (${v.vid})</span></div>`);
            document.getElementById('modal-content').innerHTML = '';
            document.getElementById('modal-content').appendChild(clone);
            modal.classList.remove('hidden');
        }
        function closeExportModal() { document.getElementById('export-modal').classList.add('hidden'); }

        function openCliModal() { document.getElementById('cli-modal').classList.remove('hidden'); generateCli(); }
        function closeCliModal() { document.getElementById('cli-modal').classList.add('hidden'); }
        function getVid(vlanId) { const v = state.vlans.find(x => x.id === vlanId); return v ? (v.vid || v.id.replace('vlan-', '')) : 1; }
        
        // Helper to group ports [1,2,3,5] -> "1-3,5"
        function groupPorts(portList) {
            if(!portList.length) return "";
            let ranges = [], start = portList[0], end = portList[0];
            for (let i = 1; i < portList.length; i++) {
                if (portList[i] === end + 1) end = portList[i];
                else {
                    ranges.push(start === end ? `${start}` : `${start}-${end}`);
                    start = portList[i]; end = portList[i];
                }
            }
            ranges.push(start === end ? `${start}` : `${start}-${end}`);
            return ranges.join(',');
        }

        // Helper for Ruckus ranges: "1/1/1 to 1/1/3"
        function ruckusRange(portList) {
             if(!portList.length) return [];
             let ranges = [], start = portList[0], end = portList[0];
             for(let i=1; i<portList.length; i++) {
                 if(portList[i] === end+1) end = portList[i];
                 else {
                     ranges.push(start===end ? `1/1/${start}` : `1/1/${start} to 1/1/${end}`);
                     start=portList[i]; end=portList[i];
                 }
             }
             ranges.push(start===end ? `1/1/${start}` : `1/1/${start} to 1/1/${end}`);
             return ranges;
        }

        function generateCli() {
            const brand = document.getElementById('cli-brand').value;
            const g = state.global;
            let out = `! Generated for ${brand.toUpperCase()}\n! Hostname: ${g.hostname}\n`;
            const ports = Object.keys(state.ports).map(Number).sort((a,b)=>a-b);
            
            // --- Helper to inject custom config ---
            const injectCustom = () => {
                if(g.customConfig) out += `\n! --- Custom Config Injection ---\n${g.customConfig}\n! -----------------------------\n`;
            };

            // Common SNMP block
            const snmpBlock = `${g.snmpContact ? 'snmp-server contact "'+g.snmpContact+'"\n' : ''}${g.snmpLocation ? 'snmp-server location "'+g.snmpLocation+'"\n' : ''}`;

            if (brand === 'netgear_m') {
                out += `hostname "${g.hostname}"\n${snmpBlock}sntp server "${g.ntp}"\nip name-server ${g.dns}\n!\n`;
                state.vlans.forEach(v => { 
                    if(v.vid) {
                        out += `vlan ${v.vid}\n name "${v.name}"\n exit\n`;
                    }
                });
                // LAGs
                state.lags.forEach(l => {
                    out += `interface lag ${l.id}\n description "${l.name}"\n`;
                    if(l.type==='lacp') out += ` no port-channel static\n`;
                    out += ` exit\n`;
                });

                // Ports
                ports.forEach(p => {
                    const port = state.ports[p];
                    const desc = port.customLabel || `Port ${p}`;
                    out += `interface 1/0/${p}\n description "${desc}"\n`;
                    if(port.lagId) out += ` addport 1/0/${p} lag ${port.lagId}\n`; 
                    else if(port.nativeVlanId) {
                         const n = getVid(port.nativeVlanId);
                         out += ` switchport mode access\n switchport access vlan ${n}\n`;
                    }
                    if(port.taggedVlans && port.taggedVlans.length > 0) {
                         const t = port.taggedVlans.map(getVid).join(',');
                         out += ` switchport mode trunk\n switchport trunk allowed vlan ${t}\n`;
                         if(port.nativeVlanId) out += ` switchport trunk native vlan ${getVid(port.nativeVlanId)}\n`;
                    }

                    if(port.isPoe===false) out += ` poe admin-mode disable\n`;
                    if(p <= state.portCount) out += ` spanning-tree bpdu-guard\n`;
                    out += ` exit\n`;
                });

                // L3
                state.routedInterfaces.forEach(ri => {
                    if(ri.id && ri.ip) {
                        const vid = getVid(ri.id);
                        out += `interface vlan ${vid}\n ip address ${ri.ip.split('/')[0]} ${ipMask(ri.ip.split('/')[1])}\n no shutdown\n exit\n`;
                    }
                });
                out += `ip route 0.0.0.0 0.0.0.0 ${g.gateway}\n`;
            
            } else if (brand === 'ruckus') {
                out += `hostname ${g.hostname}\n! LAGs\n`;
                state.lags.forEach(l => {
                    out += `lag "${l.name}" ${l.type==='lacp'?'dynamic':'static'} id ${l.id}\n`;
                    const memberPorts = ports.filter(p => state.ports[p].lagId === l.id);
                    if(memberPorts.length) {
                        const condensed = condensePortRanges(memberPorts);
                        out += ` ports ethe ${condensed}\n`;
                    }
                    out += `!\n`;
                });
                out += `! VLANs\n`;
                state.vlans.forEach(v => {
                    if(!v.vid) return;
                    out += `vlan ${v.vid} name "${v.name}" by port\n`;
                    let u = [], t = [];
                    ports.filter(p=>!state.ports[p].lagId).forEach(p => {
                        const port = state.ports[p];
                        if(getVid(port.nativeVlanId)===v.vid) u.push(p);
                        if(port.taggedVlans.map(getVid).includes(v.vid)) t.push(p);
                    });
                    // Add LAGs to VLANs
                    state.lags.forEach(l => {
                        const memberId = ports.find(p => state.ports[p].lagId === l.id);
                        if(memberId) {
                            const port = state.ports[memberId];
                            if(getVid(port.nativeVlanId)===v.vid) u.push(`lag ${l.id}`);
                            if(port.taggedVlans.map(getVid).includes(v.vid)) t.push(`lag ${l.id}`);
                        }
                    });

                    // Condense port ranges for cleaner output
                    const untaggedPorts = u.filter(p => typeof p === 'number');
                    const untaggedLags = u.filter(p => typeof p === 'string');
                    const taggedPorts = t.filter(p => typeof p === 'number');
                    const taggedLags = t.filter(p => typeof p === 'string');
                    
                    if(untaggedPorts.length > 0 || untaggedLags.length > 0) {
                        const parts = [];
                        if(untaggedPorts.length > 0) {
                            parts.push(`ethe ${condensePortRanges(untaggedPorts)}`);
                        }
                        if(untaggedLags.length > 0) {
                            parts.push(untaggedLags.join(' '));
                        }
                        out += ` untagged ${parts.join(' ')}\n`;
                    }
                    
                    if(taggedPorts.length > 0 || taggedLags.length > 0) {
                        const parts = [];
                        if(taggedPorts.length > 0) {
                            parts.push(`ethe ${condensePortRanges(taggedPorts)}`);
                        }
                        if(taggedLags.length > 0) {
                            parts.push(taggedLags.join(' '));
                        }
                        out += ` tagged ${parts.join(' ')}\n`;
                    }
                    
                    // L3 for this VLAN?
                    const l3 = state.routedInterfaces.find(ri => getVid(ri.id) === v.vid);
                    if(l3 && l3.ip) out += ` router-interface ve ${v.vid}\n`;

                    out += ` spanning-tree 802-1w\n spanning-tree 802-1w priority 0\n!\n`;
                });

                // L3 Interfaces
                state.routedInterfaces.forEach(ri => {
                    if(ri.id && ri.ip) {
                        const vid = getVid(ri.id);
                        out += `interface ve ${vid}\n ip address ${ri.ip}\n!\n`;
                    }
                });
                out += `ip route 0.0.0.0/0 ${g.gateway}\n`;
            
            } else if (brand === 'aruba') {
                out += `hostname "${g.hostname}"\n! Enable RSTP\nspanning-tree force-version rstp-operation\n`;
                state.lags.forEach(l => {
                    const members = ports.filter(p => state.ports[p].lagId === l.id);
                    if(members.length) out += `trunk ${members.join(',')} trk${l.id} ${l.type}\n`;
                });
                
                state.vlans.forEach(v => {
                    if(!v.vid) return;
                    out += `vlan ${v.vid}\n name "${v.name}"\n`;
                    let u = [], t = [];
                    ports.filter(p=>!state.ports[p].lagId).forEach(p => {
                        if(getVid(state.ports[p].nativeVlanId)===v.vid) u.push(p);
                        if(state.ports[p].taggedVlans.map(getVid).includes(v.vid)) t.push(p);
                    });
                     state.lags.forEach(l => {
                        const mem = ports.find(p => state.ports[p].lagId === l.id);
                        if(mem) {
                            if(getVid(state.ports[mem].nativeVlanId)===v.vid) u.push(`trk${l.id}`);
                            if(state.ports[mem].taggedVlans.map(getVid).includes(v.vid)) t.push(`trk${l.id}`);
                        }
                    });

                    if(u.length) out += ` untagged ${u.join(',')}\n`;
                    if(t.length) out += ` tagged ${t.join(',')}\n`;
                    
                    // L3
                    const l3 = state.routedInterfaces.find(ri => getVid(ri.id) === v.vid);
                    if(l3 && l3.ip) out += ` ip address ${l3.ip.split('/')[0]} ${ipMask(l3.ip.split('/')[1])}\n`;
                    
                    out += ` exit\n`;
                });
                out += `ip default-gateway ${g.gateway}\n`;
            }

            injectCustom();
            cliOutput.textContent = out;
        }

        function ipMask(cidr) { 
            if(!cidr) return "255.255.255.0"; 
            if(cidr.includes('.')) return cidr; 
            let m=[],n; cidr=parseInt(cidr); 
            for(let i=0;i<4;i++){ n=Math.min(cidr,8); m.push(256-Math.pow(2,8-n)); cidr-=n; } 
            return m.join('.'); 
        }
        function copyCli() { navigator.clipboard.writeText(document.getElementById('cli-output').textContent); alert('Copied!'); }

        init();
    </script>
</body>
</html>