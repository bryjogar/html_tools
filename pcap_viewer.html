<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCAP Viewer - Homelab Playground</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        obsidian: {
                            bg: '#1e1e1e',
                            pane: '#252526',
                            border: '#3c3c3c',
                            accent: '#7c3aed',
                            text: '#cccccc'
                        }
                    },
                    fontFamily: {
                        mono: ['"Fira Code"', 'Consolas', 'Monaco', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Fira+Code:wght@400;500&display=swap');

        body {
            background-color: #1e1e1e;
            color: #cccccc;
        }

        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }
        ::-webkit-scrollbar-thumb {
            background: #3c3c3c;
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        .upload-area {
            transition: all 0.3s ease;
        }

        .upload-area.dragover {
            border-color: #7c3aed;
            background-color: rgba(124, 58, 237, 0.1);
        }

        .chat-bubble {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .packet-flow {
            border-left: 2px solid #7c3aed;
            padding-left: 1rem;
            margin-left: 1rem;
        }
    </style>
</head>
<body class="flex flex-col h-screen overflow-hidden font-sans">

    <header class="h-14 bg-obsidian-pane border-b border-obsidian-border flex items-center px-6 shrink-0 justify-between">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-network-wired text-obsidian-accent"></i>
            <h1 class="font-semibold text-lg tracking-wide">PCAP Viewer</h1>
        </div>
        <div class="text-xs text-gray-500 flex items-center gap-2">
            <i class="fa-solid fa-lock"></i>
            <span>Client-side only processing</span>
        </div>
    </header>

    <main class="flex-1 overflow-hidden flex flex-col">
        
        <!-- Upload Section -->
        <div class="bg-obsidian-pane border-b border-obsidian-border p-4 shrink-0">
            <div 
                id="uploadArea" 
                class="upload-area border-2 border-dashed border-obsidian-border rounded-lg p-6 text-center cursor-pointer hover:border-obsidian-accent transition-colors"
                ondrop="handleDrop(event)"
                ondragover="handleDragOver(event)"
                ondragleave="handleDragLeave(event)"
                onclick="document.getElementById('fileInput').click()"
            >
                <input 
                    type="file" 
                    id="fileInput" 
                    accept=".pcap,.cap" 
                    class="hidden" 
                    onchange="handleFileSelect(event)"
                >
                <i class="fa-solid fa-file-arrow-up text-3xl text-gray-500 mb-2"></i>
                <p class="text-gray-400 mb-1">Click to upload or drag and drop PCAP file</p>
                <p class="text-xs text-gray-500">Supports .pcap and .cap files</p>
            </div>
        </div>

            <!-- Stats Bar -->
            <div id="statsBar" class="hidden bg-obsidian-pane border-b border-obsidian-border px-6 py-3 shrink-0">
                <div class="flex items-center justify-between">
                    <div class="flex gap-6 text-xs">
                        <div>
                            <span class="text-gray-500">Packets:</span>
                            <span id="packetCount" class="text-white font-mono ml-2">0</span>
                        </div>
                        <div>
                            <span class="text-gray-500">Conversations:</span>
                            <span id="conversationCount" class="text-white font-mono ml-2">0</span>
                        </div>
                        <div>
                            <span class="text-gray-500">Protocols:</span>
                            <span id="protocols" class="text-white font-mono ml-2">-</span>
                        </div>
                        <div>
                            <span class="text-gray-500">Multicast:</span>
                            <span id="multicastCount" class="text-white font-mono ml-2">0</span>
                        </div>
                        <div>
                            <span class="text-gray-500">Total Bytes:</span>
                            <span id="totalBytes" class="text-white font-mono ml-2">0</span>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="showSummary()" class="text-xs text-obsidian-accent hover:text-white px-3 py-1 border border-obsidian-border rounded hover:border-obsidian-accent transition-colors">
                            <i class="fa-solid fa-chart-bar mr-1"></i> Summary
                        </button>
                        <button onclick="clearPCAP()" class="text-xs text-red-400 hover:text-red-300 px-3 py-1 border border-obsidian-border rounded hover:border-red-500 transition-colors">
                            <i class="fa-solid fa-trash mr-1"></i> Clear
                        </button>
                    </div>
                </div>
            </div>

        <!-- Main Content -->
        <div class="flex-1 overflow-hidden flex">
            
            <!-- Sidebar - Conversations List -->
            <div id="sidebar" class="hidden w-64 bg-obsidian-pane border-r border-obsidian-border overflow-y-auto shrink-0">
                <div class="p-4">
                    <h3 class="text-sm font-semibold text-white mb-3">Conversations</h3>
                    <div id="conversationList" class="space-y-2"></div>
                </div>
            </div>

            <!-- Main Viewer -->
            <div class="flex-1 overflow-y-auto bg-obsidian-bg">
                <div id="emptyState" class="flex items-center justify-center h-full">
                    <div class="text-center text-gray-500">
                        <i class="fa-solid fa-file-arrow-up text-5xl mb-4"></i>
                        <p class="text-lg">Upload a PCAP file to begin</p>
                        <p class="text-sm mt-2">Drag and drop or click to select</p>
                    </div>
                </div>

                <div id="summaryView" class="hidden p-6">
                    <div id="summaryContent" class="space-y-6"></div>
                </div>

                <div id="conversationView" class="hidden p-6">
                    <div id="conversationHeader" class="mb-6">
                        <h2 id="conversationTitle" class="text-xl font-semibold text-white mb-2"></h2>
                        <div id="conversationInfo" class="text-sm text-gray-400"></div>
                    </div>
                    <div id="chatContainer" class="space-y-4"></div>
                </div>
            </div>

        </div>

    </main>

    <footer class="bg-obsidian-pane border-t border-obsidian-border py-3 text-center shrink-0 flex flex-col md:flex-row justify-center items-center gap-3">
        <a href="https://homelabplayground.com" class="text-gray-500 hover:text-violet-400 text-xs transition-colors font-sans no-underline">
            HomeLab Playground
        </a>
        <span class="hidden md:block text-obsidian-border mx-1">|</span>
        <a href="https://www.buymeacoffee.com/bryjogar" target="_blank" class="inline-flex items-center px-3 py-1 bg-obsidian-accent hover:bg-violet-600 text-white text-xs font-sans rounded-full transition-colors no-underline">
            <i class="fa-solid fa-mug-hot mr-1.5"></i>
            <span>Support The Tools</span>
        </a>
    </footer>

    <script>
        let pcapData = null;
        let conversations = [];
        let currentConversation = null;

        // Binary reading utilities
        class BinaryReader {
            constructor(buffer) {
                this.buffer = buffer;
                this.offset = 0;
                this.view = new DataView(buffer);
            }

            readUInt8() {
                const value = this.view.getUint8(this.offset);
                this.offset += 1;
                return value;
            }

            readUInt16(littleEndian = false) {
                const value = this.view.getUint16(this.offset, littleEndian);
                this.offset += 2;
                return value;
            }

            readUInt32(littleEndian = false) {
                const value = this.view.getUint32(this.offset, littleEndian);
                this.offset += 4;
                return value;
            }

            readBytes(length) {
                const bytes = new Uint8Array(this.buffer, this.offset, length);
                this.offset += length;
                return bytes;
            }

            skip(length) {
                this.offset += length;
            }

            remaining() {
                return this.buffer.byteLength - this.offset;
            }
        }

        // PCAP Parser
        class PCAPParser {
            constructor(buffer) {
                this.reader = new BinaryReader(buffer);
                this.packets = [];
                this.magicNumber = null;
                this.isLittleEndian = false;
            }

            parse() {
                if (this.reader.remaining() < 24) {
                    throw new Error('File too small to be a valid PCAP file');
                }

                // Read magic number to determine endianness
                this.magicNumber = this.reader.readUInt32(false);
                console.log('Magic number:', '0x' + this.magicNumber.toString(16));
                
                // Check for different PCAP formats
                if (this.magicNumber === 0xa1b2c3d4) {
                    this.isLittleEndian = false;
                    console.log('Detected: libpcap (big-endian)');
                } else if (this.magicNumber === 0xd4c3b2a1) {
                    this.isLittleEndian = true;
                    console.log('Detected: libpcap (little-endian)');
                } else if (this.magicNumber === 0xa1b23c4d || this.magicNumber === 0x4d3cb2a1) {
                    // pcapng format (not fully supported)
                    throw new Error('PCAP-NG format detected. This tool currently supports libpcap format only. Try converting with: tcpdump -r input.pcapng -w output.pcap');
                } else {
                    throw new Error(`Invalid PCAP file format. Magic number: 0x${this.magicNumber.toString(16)}. Expected libpcap format.`);
                }

                // Read global header
                const versionMajor = this.reader.readUInt16(this.isLittleEndian);
                const versionMinor = this.reader.readUInt16(this.isLittleEndian);
                const thiszone = this.reader.readUInt32(this.isLittleEndian);
                const sigfigs = this.reader.readUInt32(this.isLittleEndian);
                const snaplen = this.reader.readUInt32(this.isLittleEndian);
                const network = this.reader.readUInt32(this.isLittleEndian);

                // Parse packets
                let packetCount = 0;
                let errorCount = 0;
                const maxErrors = 10;
                
                while (this.reader.remaining() >= 16) {
                    try {
                        const packet = this.parsePacket();
                        if (packet) {
                            this.packets.push(packet);
                            packetCount++;
                        } else {
                            // Packet header read but packet data invalid
                            break;
                        }
                    } catch (e) {
                        errorCount++;
                        console.warn(`Error parsing packet ${packetCount + 1}:`, e);
                        if (errorCount >= maxErrors) {
                            console.warn(`Stopping after ${maxErrors} consecutive errors`);
                            break;
                        }
                        // Try to skip to next packet by reading packet header length
                        if (this.reader.remaining() >= 16) {
                            // Skip timestamp (8 bytes) and read inclLen
                            this.reader.skip(8);
                            const inclLen = this.reader.readUInt32(this.isLittleEndian);
                            if (inclLen > 0 && inclLen < 65536 && inclLen <= this.reader.remaining()) {
                                this.reader.skip(4); // Skip origLen
                                this.reader.skip(inclLen); // Skip packet data
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }

                console.log(`Parsed ${packetCount} packets successfully`);
                if (errorCount > 0) {
                    console.warn(`Encountered ${errorCount} errors during parsing`);
                }

                return this.packets;
            }

            parsePacket() {
                if (this.reader.remaining() < 16) {
                    return null;
                }

                // Packet header
                const tsSec = this.reader.readUInt32(this.isLittleEndian);
                const tsUsec = this.reader.readUInt32(this.isLittleEndian);
                const inclLen = this.reader.readUInt32(this.isLittleEndian);
                const origLen = this.reader.readUInt32(this.isLittleEndian);

                // Validate packet header
                if (inclLen === 0) {
                    return null; // Empty packet
                }
                
                if (inclLen > this.reader.remaining()) {
                    console.warn(`Packet length (${inclLen}) exceeds remaining data (${this.reader.remaining()})`);
                    return null;
                }
                
                if (inclLen > 65536) {
                    console.warn(`Packet length (${inclLen}) seems too large, skipping`);
                    return null;
                }

                const packetData = this.reader.readBytes(inclLen);
                const timestamp = tsSec + (tsUsec / 1000000);

                // Parse Ethernet frame
                const ethernet = this.parseEthernet(packetData);
                
                return {
                    timestamp,
                    length: inclLen,
                    originalLength: origLen,
                    ethernet,
                    raw: packetData
                };
            }

            parseEthernet(data) {
                if (data.length < 14) return null;

                // Create a new ArrayBuffer view to ensure proper offset handling
                const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.length);
                const reader = new BinaryReader(buffer);
                const dstMac = Array.from(reader.readBytes(6)).map(b => b.toString(16).padStart(2, '0')).join(':');
                const srcMac = Array.from(reader.readBytes(6)).map(b => b.toString(16).padStart(2, '0')).join(':');
                const etherType = reader.readUInt16(false);

                let ip = null;
                if (etherType === 0x0800) { // IPv4
                    ip = this.parseIPv4(reader);
                } else if (etherType === 0x86DD) { // IPv6
                    // IPv6 not fully implemented
                    return { dstMac, srcMac, etherType: 'IPv6' };
                }

                return {
                    dstMac,
                    srcMac,
                    etherType: etherType === 0x0800 ? 'IPv4' : `0x${etherType.toString(16)}`,
                    ip
                };
            }

            parseIPv4(reader) {
                if (reader.remaining() < 20) return null;

                const versionAndIHL = reader.readUInt8();
                const version = (versionAndIHL >> 4) & 0x0F;
                const ihl = (versionAndIHL & 0x0F) * 4;

                const tos = reader.readUInt8();
                const totalLength = reader.readUInt16(false);
                const identification = reader.readUInt16(false);
                const flagsAndOffset = reader.readUInt16(false);
                const ttl = reader.readUInt8();
                const protocol = reader.readUInt8();
                const checksum = reader.readUInt16(false);
                const srcIP = this.readIP(reader);
                const dstIP = this.readIP(reader);
                
                // Check for multicast/broadcast
                const isMulticast = this.isMulticastIP(dstIP);
                const isBroadcast = dstIP === '255.255.255.255';

                // Skip options if IHL > 20
                if (ihl > 20) {
                    reader.skip(ihl - 20);
                }

                let transport = null;
                if (protocol === 6) { // TCP
                    transport = this.parseTCP(reader);
                } else if (protocol === 17) { // UDP
                    transport = this.parseUDP(reader);
                } else if (protocol === 1) { // ICMP
                    transport = this.parseICMP(reader);
                } else if (protocol === 2) { // IGMP
                    transport = this.parseIGMP(reader);
                }

                return {
                    version,
                    srcIP,
                    dstIP,
                    ttl,
                    isMulticast,
                    isBroadcast,
                    protocol: protocol === 6 ? 'TCP' : protocol === 17 ? 'UDP' : protocol === 1 ? 'ICMP' : protocol === 2 ? 'IGMP' : `IP Protocol ${protocol}`,
                    transport
                };
            }

            isMulticastIP(ip) {
                const parts = ip.split('.');
                if (parts.length === 4) {
                    const firstOctet = parseInt(parts[0]);
                    return firstOctet >= 224 && firstOctet <= 239;
                }
                return false;
            }

            parseIGMP(reader) {
                if (reader.remaining() < 8) return null;

                const type = reader.readUInt8();
                const maxRespTime = reader.readUInt8();
                const checksum = reader.readUInt16(false);
                const groupAddress = this.readIP(reader);

                const igmpTypes = {
                    0x11: 'Membership Query',
                    0x12: 'Version 1 Membership Report',
                    0x16: 'Version 2 Membership Report',
                    0x17: 'Leave Group',
                    0x22: 'Version 3 Membership Report'
                };

                return {
                    type: 'IGMP',
                    igmpType: type,
                    messageType: igmpTypes[type] || `IGMP Type 0x${type.toString(16)}`,
                    groupAddress: groupAddress,
                    isQuery: type === 0x11,
                    isReport: type === 0x12 || type === 0x16 || type === 0x22
                };
            }

            readIP(reader) {
                const bytes = reader.readBytes(4);
                return `${bytes[0]}.${bytes[1]}.${bytes[2]}.${bytes[3]}`;
            }

            parseTCP(reader) {
                if (reader.remaining() < 20) return null;

                const srcPort = reader.readUInt16(false);
                const dstPort = reader.readUInt16(false);
                const seqNum = reader.readUInt32(false);
                const ackNum = reader.readUInt32(false);
                const dataOffsetAndFlags = reader.readUInt16(false);
                const dataOffset = ((dataOffsetAndFlags >> 12) & 0x0F) * 4;
                const flags = dataOffsetAndFlags & 0x1FF;
                const window = reader.readUInt16(false);
                const checksum = reader.readUInt16(false);
                const urgent = reader.readUInt16(false);

                // Skip options
                if (dataOffset > 20) {
                    reader.skip(dataOffset - 20);
                }

                const payload = reader.remaining() > 0 ? reader.readBytes(reader.remaining()) : null;

                // Parse application layer
                let application = null;
                if (payload && payload.length > 0) {
                    application = this.parseApplicationLayer(srcPort, dstPort, payload);
                }

                const flagNames = [];
                if (flags & 0x001) flagNames.push('FIN');
                if (flags & 0x002) flagNames.push('SYN');
                if (flags & 0x004) flagNames.push('RST');
                if (flags & 0x008) flagNames.push('PSH');
                if (flags & 0x010) flagNames.push('ACK');
                if (flags & 0x020) flagNames.push('URG');

                return {
                    srcPort,
                    dstPort,
                    seqNum,
                    ackNum,
                    flags: flagNames.join(', '),
                    hasRST: (flags & 0x004) !== 0,
                    window,
                    payload,
                    application
                };
            }

            parseUDP(reader) {
                if (reader.remaining() < 8) return null;

                const srcPort = reader.readUInt16(false);
                const dstPort = reader.readUInt16(false);
                const length = reader.readUInt16(false);
                const checksum = reader.readUInt16(false);

                const payload = reader.remaining() > 0 ? reader.readBytes(reader.remaining()) : null;

                let application = null;
                if (payload && payload.length > 0) {
                    application = this.parseApplicationLayer(srcPort, dstPort, payload);
                }

                return {
                    srcPort,
                    dstPort,
                    length,
                    payload,
                    application
                };
            }

            parseICMP(reader) {
                if (reader.remaining() < 8) return null;

                const type = reader.readUInt8();
                const code = reader.readUInt8();
                const checksum = reader.readUInt16(false);

                const icmpTypes = {
                    0: 'Echo Reply',
                    3: 'Destination Unreachable',
                    4: 'Source Quench',
                    5: 'Redirect',
                    8: 'Echo Request',
                    11: 'Time Exceeded',
                    12: 'Parameter Problem',
                    13: 'Timestamp Request',
                    14: 'Timestamp Reply',
                    15: 'Information Request',
                    16: 'Information Reply',
                    17: 'Address Mask Request',
                    18: 'Address Mask Reply'
                };

                let messageType = icmpTypes[type] || `ICMP Type ${type}`;
                let details = {};

                // Parse ICMP-specific fields based on type
                if (type === 0 || type === 8) {
                    // Echo Request/Reply
                    if (reader.remaining() >= 4) {
                        details.identifier = reader.readUInt16(false);
                        details.sequence = reader.readUInt16(false);
                    }
                } else if (type === 3) {
                    // Destination Unreachable
                    if (reader.remaining() >= 4) {
                        reader.skip(4); // Unused
                    }
                } else if (type === 11) {
                    // Time Exceeded
                    if (reader.remaining() >= 4) {
                        reader.skip(4); // Unused
                    }
                }

                return {
                    type: 'ICMP',
                    icmpType: type,
                    code,
                    messageType,
                    details
                };
            }

            parseApplicationLayer(srcPort, dstPort, payload) {
                // DHCP (UDP 67/68)
                if ((srcPort === 67 || srcPort === 68) && (dstPort === 67 || dstPort === 68)) {
                    return this.parseDHCP(payload);
                }

                // DNS
                if (srcPort === 53 || dstPort === 53) {
                    return this.parseDNS(payload);
                }

                // mDNS (UDP 5353)
                if (srcPort === 5353 || dstPort === 5353) {
                    return { type: 'mDNS', port: srcPort === 5353 ? 'source' : 'destination' };
                }

                // HTTP
                if (srcPort === 80 || dstPort === 80 || srcPort === 8080 || dstPort === 8080) {
                    return this.parseHTTP(payload);
                }

                // HTTPS/TLS
                if (srcPort === 443 || dstPort === 443) {
                    return this.parseTLS(payload);
                }

                return null;
            }

            parseDHCP(payload) {
                if (payload.length < 240) return null; // DHCP minimum size

                try {
                    const reader = new BinaryReader(payload.buffer.slice(payload.byteOffset, payload.byteOffset + payload.length));
                    const op = reader.readUInt8(); // Message type
                    const htype = reader.readUInt8();
                    const hlen = reader.readUInt8();
                    const hops = reader.readUInt8();
                    const xid = reader.readUInt32(false);
                    const secs = reader.readUInt16(false);
                    const flags = reader.readUInt16(false);
                    reader.skip(4); // ciaddr
                    reader.skip(4); // yiaddr
                    reader.skip(4); // siaddr
                    reader.skip(4); // giaddr
                    reader.skip(16); // chaddr
                    reader.skip(192); // sname, file
                    const magicCookie = reader.readUInt32(false);
                    
                    if (magicCookie !== 0x63825363) {
                        return null; // Not DHCP
                    }

                    const dhcpTypes = {
                        1: 'Discover',
                        2: 'Offer',
                        3: 'Request',
                        5: 'ACK',
                        6: 'NAK',
                        7: 'Release',
                        8: 'Inform'
                    };

                    let messageType = null;
                    let option55 = null;
                    let option82 = null;
                    let serverId = null;

                    // Parse options
                    while (reader.remaining() > 0) {
                        const optionCode = reader.readUInt8();
                        if (optionCode === 0) continue; // Padding
                        if (optionCode === 255) break; // End
                        
                        if (optionCode === 53) { // Message Type
                            const len = reader.readUInt8();
                            if (len > 0) {
                                messageType = reader.readUInt8();
                            }
                        } else if (optionCode === 55) { // Parameter Request List
                            const len = reader.readUInt8();
                            option55 = Array.from(reader.readBytes(len));
                        } else if (optionCode === 82) { // Relay Agent Info
                            const len = reader.readUInt8();
                            option82 = reader.readBytes(len);
                        } else if (optionCode === 54) { // Server Identifier
                            const len = reader.readUInt8();
                            const bytes = reader.readBytes(len);
                            serverId = `${bytes[0]}.${bytes[1]}.${bytes[2]}.${bytes[3]}`;
                        } else {
                            const len = reader.readUInt8();
                            if (len > 0 && len <= reader.remaining()) {
                                reader.skip(len);
                            }
                        }
                    }

                    return {
                        type: 'DHCP',
                        messageType: dhcpTypes[messageType] || `Type ${messageType}`,
                        op: op === 1 ? 'Request' : 'Reply',
                        xid: xid,
                        option55: option55,
                        option82: option82 ? 'Present' : null,
                        serverId: serverId,
                        isNAK: messageType === 6
                    };
                } catch (e) {
                    return { type: 'DHCP', messageType: 'Parse Error' };
                }
            }

            parseDNS(payload) {
                if (payload.length < 12) return null;

                try {
                    const reader = new BinaryReader(payload.buffer.slice(payload.byteOffset, payload.byteOffset + payload.length));
                    const transactionId = reader.readUInt16(false);
                    const flags = reader.readUInt16(false);
                    const questions = reader.readUInt16(false);
                    const answerRRs = reader.readUInt16(false);
                    const authorityRRs = reader.readUInt16(false);
                    const additionalRRs = reader.readUInt16(false);

                    const qr = (flags >> 15) & 1; // Query (0) or Response (1)
                    const opcode = (flags >> 11) & 0x0F;
                    const rcode = flags & 0x0F;

                    const rcodeNames = {
                        0: 'NOERROR',
                        1: 'FORMERR',
                        2: 'SERVFAIL',
                        3: 'NXDOMAIN',
                        4: 'NOTIMP',
                        5: 'REFUSED'
                    };

                    // Try to read question name
                    let questionName = '';
                    try {
                        let nameLen = reader.readUInt8();
                        while (nameLen > 0 && nameLen < 64 && reader.remaining() > nameLen) {
                            const label = reader.readBytes(nameLen);
                            questionName += new TextDecoder('utf-8', { fatal: false }).decode(label) + '.';
                            nameLen = reader.readUInt8();
                        }
                        if (nameLen === 0) questionName = questionName.slice(0, -1);
                        reader.skip(4); // QTYPE and QCLASS
                    } catch (e) {
                        // Skip if can't parse
                    }

                    return {
                        type: 'DNS',
                        isQuery: qr === 0,
                        isResponse: qr === 1,
                        transactionId: transactionId,
                        questions: questions,
                        answers: answerRRs,
                        rcode: rcodeNames[rcode] || `RCODE${rcode}`,
                        questionName: questionName || 'Unknown',
                        isSERVFAIL: rcode === 2,
                        isNXDOMAIN: rcode === 3
                    };
                } catch (e) {
                    return { type: 'DNS', isQuery: true };
                }
            }

            parseHTTP(payload) {
                try {
                    const text = new TextDecoder('utf-8', { fatal: false }).decode(payload);
                    if (text.startsWith('HTTP/')) {
                        return { type: 'HTTP Response', content: text.substring(0, 200) };
                    } else if (text.match(/^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)\s/)) {
                        return { type: 'HTTP Request', content: text.substring(0, 200) };
                    }
                } catch (e) {
                    // Not valid UTF-8
                }
                return { type: 'HTTP', raw: payload };
            }

            parseTLS(payload) {
                if (payload.length < 5) return null;

                try {
                    // Create a new ArrayBuffer view to ensure proper offset handling
                    const buffer = payload.buffer.slice(payload.byteOffset, payload.byteOffset + payload.length);
                    const reader = new BinaryReader(buffer);
                    const contentType = reader.readUInt8();
                    const version = reader.readUInt16(false);
                    const length = reader.readUInt16(false);

                    let messageType = 'Unknown';
                    let details = '';
                    
                    if (contentType === 22) { // Handshake
                        if (reader.remaining() >= 4) {
                            const handshakeType = reader.readUInt8();
                            // Read 3-byte length
                            const byte1 = reader.readUInt8();
                            const byte2 = reader.readUInt8();
                            const byte3 = reader.readUInt8();
                            const handshakeLength = (byte1 << 16) | (byte2 << 8) | byte3;
                            
                            const handshakeTypes = {
                                1: 'Client Hello',
                                2: 'Server Hello',
                                11: 'Certificate',
                                12: 'Server Key Exchange',
                                13: 'Certificate Request',
                                14: 'Server Hello Done',
                                15: 'Certificate Verify',
                                16: 'Client Key Exchange',
                                20: 'Finished'
                            };
                            messageType = handshakeTypes[handshakeType] || `Handshake ${handshakeType}`;
                            
                            // Try to extract more info from Client/Server Hello
                            if (handshakeType === 1 || handshakeType === 2) {
                                if (reader.remaining() >= 2) {
                                    const tlsVersion = reader.readUInt16(false);
                                    details = `TLS ${(tlsVersion >> 8)}.${tlsVersion & 0xFF}`;
                                }
                            }
                        }
                    } else if (contentType === 20) {
                        messageType = 'Change Cipher Spec';
                    } else if (contentType === 21) {
                        messageType = 'Alert';
                        if (reader.remaining() >= 2) {
                            const level = reader.readUInt8();
                            const description = reader.readUInt8();
                            details = `Level: ${level}, Description: ${description}`;
                        }
                    } else if (contentType === 23) {
                        messageType = 'Application Data';
                    }

                    return {
                        type: 'TLS',
                        messageType,
                        version: `TLS ${(version >> 8)}.${version & 0xFF}`,
                        details
                    };
                } catch (e) {
                    return {
                        type: 'TLS',
                        messageType: 'TLS Packet',
                        version: 'Unknown'
                    };
                }
            }
            
        }

        // Conversation grouping
        function groupConversations(packets) {
            const convMap = new Map();
            const protocols = new Set();
            let skippedPackets = 0;

            packets.forEach((packet, index) => {
                if (!packet.ethernet) {
                    skippedPackets++;
                    return;
                }
                
                if (!packet.ethernet.ip) {
                    skippedPackets++;
                    return;
                }
                
                const ip = packet.ethernet.ip;
                const transport = ip.transport;

                // Handle ICMP (no ports, but can still create conversations)
                if (ip.protocol === 'ICMP' && transport) {
                    // Create conversation key based on IP addresses
                    const key1 = `${ip.srcIP} -> ${ip.dstIP} (ICMP)`;
                    const key2 = `${ip.dstIP} -> ${ip.srcIP} (ICMP)`;
                    
                    let convKey = convMap.has(key1) ? key1 : (convMap.has(key2) ? key2 : key1);
                    
                    if (!convMap.has(convKey)) {
                        convMap.set(convKey, {
                            id: convKey,
                            srcIP: ip.srcIP,
                            dstIP: ip.dstIP,
                            srcPort: null,
                            dstPort: null,
                            protocol: 'ICMP',
                            packets: [],
                            startTime: packet.timestamp,
                            endTime: packet.timestamp
                        });
                    }

                    const conv = convMap.get(convKey);
                    conv.packets.push({
                        ...packet,
                        index,
                        direction: (ip.srcIP === conv.srcIP) ? 'outbound' : 'inbound'
                    });

                    conv.endTime = Math.max(conv.endTime, packet.timestamp);
                    protocols.add('ICMP');
                    return;
                }

                // Handle TCP/UDP (require transport layer with ports)
                if (!transport) {
                    skippedPackets++;
                    return;
                }

                if (!transport.srcPort || !transport.dstPort) {
                    skippedPackets++;
                    return;
                }

                // Create conversation key (sorted by IP and port)
                const key1 = `${ip.srcIP}:${transport.srcPort} -> ${ip.dstIP}:${transport.dstPort}`;
                const key2 = `${ip.dstIP}:${transport.dstPort} -> ${ip.srcIP}:${transport.srcPort}`;

                let convKey = convMap.has(key1) ? key1 : (convMap.has(key2) ? key2 : key1);
                
                if (!convMap.has(convKey)) {
                    convMap.set(convKey, {
                        id: convKey,
                        srcIP: ip.srcIP,
                        dstIP: ip.dstIP,
                        srcPort: transport.srcPort,
                        dstPort: transport.dstPort,
                        protocol: ip.protocol,
                        packets: [],
                        startTime: packet.timestamp,
                        endTime: packet.timestamp
                    });
                }

                const conv = convMap.get(convKey);
                conv.packets.push({
                    ...packet,
                    index,
                    direction: (ip.srcIP === conv.srcIP && transport.srcPort === conv.srcPort) ? 'outbound' : 'inbound'
                });

                conv.endTime = Math.max(conv.endTime, packet.timestamp);
                protocols.add(ip.protocol);
            });

            if (skippedPackets > 0) {
                console.log(`Skipped ${skippedPackets} packets (no IP/transport layer)`);
            }

            return {
                conversations: Array.from(convMap.values()),
                protocols: Array.from(protocols),
                skippedPackets
            };
        }

        // File handling
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                const file = files[0];
                // Validate file is accessible
                if (!file || file.size === undefined) {
                    alert('File could not be accessed. Please try using the file picker instead.');
                    return;
                }
                // Small delay to ensure file is fully available
                setTimeout(() => {
                    processFile(file);
                }, 10);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            // Validate file
            if (!file) {
                alert('No file selected');
                return;
            }

            // Check if file is still accessible
            try {
                if (file.size === undefined || file.size === null) {
                    alert('File size could not be determined. The file may no longer be accessible. Please try selecting it again.');
                    return;
                }
            } catch (err) {
                alert('File is not accessible: ' + err.message + '\n\nPlease try using the file picker button instead of drag-and-drop.');
                return;
            }

            if (!file.name || !file.name.match(/\.(pcap|cap)$/i)) {
                alert('Please select a .pcap or .cap file');
                return;
            }

            // Check file size (warn if very large)
            const maxSize = 100 * 1024 * 1024; // 100MB
            if (file.size > maxSize) {
                if (!confirm(`File is large (${(file.size / 1024 / 1024).toFixed(2)} MB). Processing may take a while. Continue?`)) {
                    return;
                }
            }

            if (file.size === 0) {
                alert('File is empty');
                return;
            }

            // Show loading state
            document.getElementById('emptyState').innerHTML = `
                <div class="text-center text-gray-500">
                    <i class="fa-solid fa-spinner fa-spin text-5xl mb-4"></i>
                    <p class="text-lg">Parsing PCAP file...</p>
                    <p class="text-sm mt-2">File: ${file.name}</p>
                    <p class="text-sm">Size: ${(file.size / 1024).toFixed(2)} KB</p>
                </div>
            `;

            const reader = new FileReader();
            
            reader.onloadstart = function() {
                console.log('File reading started');
            };
            
            reader.onprogress = function(e) {
                if (e.lengthComputable) {
                    const percent = (e.loaded / e.total) * 100;
                    console.log(`File reading progress: ${percent.toFixed(1)}%`);
                }
            };
            
            reader.onload = function(e) {
                try {
                    const buffer = e.target.result;
                    console.log('File loaded:', file.name, 'Size:', buffer.byteLength, 'bytes');
                    
                    const parser = new PCAPParser(buffer);
                    const packets = parser.parse();
                    
                    console.log('Parsed packets:', packets.length);
                    
                    if (packets.length === 0) {
                        alert('No packets found in PCAP file. The file might be empty, corrupted, or in an unsupported format.');
                        document.getElementById('emptyState').innerHTML = `
                            <div class="text-center text-gray-500">
                                <i class="fa-solid fa-exclamation-triangle text-5xl mb-4 text-yellow-500"></i>
                                <p class="text-lg">No packets found</p>
                                <p class="text-sm mt-2">The file might be empty or in an unsupported format</p>
                            </div>
                        `;
                        return;
                    }
                    
                    pcapData = { packets, file: file.name };
                    const grouped = groupConversations(packets);
                    conversations = grouped.conversations;
                    
                    console.log('Conversations:', conversations.length);
                    console.log('Grouped data:', grouped);
                    
                    if (conversations.length === 0) {
                        // Show debug info
                        const packetTypes = {};
                        packets.forEach(p => {
                            if (p.ethernet) {
                                const type = p.ethernet.etherType || 'Unknown';
                                packetTypes[type] = (packetTypes[type] || 0) + 1;
                            } else {
                                packetTypes['No Ethernet'] = (packetTypes['No Ethernet'] || 0) + 1;
                            }
                        });
                        
                        const debugInfo = Object.entries(packetTypes).map(([type, count]) => 
                            `${type}: ${count}`
                        ).join(', ');
                        
                        console.log('Packet types found:', packetTypes);
                        console.log('Sample packets:', packets.slice(0, 5));
                        
                        alert(`No conversations found. Packets parsed: ${packets.length}\n\nPacket types: ${debugInfo}\n\nThe file may not contain IP/TCP/UDP traffic, or packets may be in an unsupported format.\n\nCheck browser console for details.`);
                        document.getElementById('emptyState').innerHTML = `
                            <div class="text-center text-gray-500 max-w-2xl mx-auto">
                                <i class="fa-solid fa-info-circle text-5xl mb-4 text-blue-500"></i>
                                <p class="text-lg">No conversations found</p>
                                <p class="text-sm mt-2">Packets parsed: ${packets.length}</p>
                                <p class="text-sm mt-2">Packet types: ${debugInfo}</p>
                                <p class="text-sm mt-4">The file may not contain IP/TCP/UDP traffic</p>
                                <p class="text-xs mt-4 text-gray-600">Check browser console (F12) for detailed packet information</p>
                            </div>
                        `;
                        return;
                    }
                    
                    displayResults(packets, grouped);
                } catch (error) {
                    console.error('PCAP parsing error:', error);
                    console.error('Stack trace:', error.stack);
                    alert('Error parsing PCAP file: ' + error.message + '\n\nCheck the browser console (F12) for detailed error information.');
                    document.getElementById('emptyState').innerHTML = `
                        <div class="text-center text-gray-500">
                            <i class="fa-solid fa-exclamation-triangle text-5xl mb-4 text-red-500"></i>
                            <p class="text-lg">Error parsing file</p>
                            <p class="text-sm mt-2">${error.message}</p>
                            <p class="text-xs mt-4 text-gray-600">Open browser console (F12) for details</p>
                        </div>
                    `;
                }
            };
            reader.onerror = function(e) {
                const error = reader.error;
                console.error('FileReader error:', error);
                console.error('Error event:', e);
                
                let errorMessage = 'Error reading file';
                if (error) {
                    if (error.name === 'NotFoundError') {
                        errorMessage = 'File not found or could not be accessed. Try selecting the file again.';
                    } else if (error.name === 'SecurityError') {
                        errorMessage = 'Security error: Browser blocked file access. Try a different browser or file.';
                    } else if (error.name === 'NotReadableError') {
                        errorMessage = 'File could not be read. The file may be locked or corrupted.';
                    } else {
                        errorMessage = `Error: ${error.name} - ${error.message || 'Unknown error'}`;
                    }
                }
                
                alert(errorMessage);
                document.getElementById('emptyState').innerHTML = `
                    <div class="text-center text-gray-500">
                        <i class="fa-solid fa-exclamation-triangle text-5xl mb-4 text-red-500"></i>
                        <p class="text-lg">File Read Error</p>
                        <p class="text-sm mt-2">${errorMessage}</p>
                        <p class="text-xs mt-4 text-gray-600">Try selecting the file again or use a different file</p>
                    </div>
                `;
            };
            
            reader.onabort = function() {
                console.warn('File reading aborted');
                alert('File reading was cancelled');
            };
            
            try {
                reader.readAsArrayBuffer(file);
            } catch (err) {
                console.error('Error starting file read:', err);
                alert('Error starting file read: ' + err.message);
            }
        }

        function displayResults(packets, grouped) {
            // Calculate statistics
            let totalBytes = 0;
            let multicastPackets = 0;
            packets.forEach(p => {
                totalBytes += p.length;
                if (p.ethernet && p.ethernet.ip) {
                    const ip = p.ethernet.ip.dstIP;
                    // Check if multicast (224.0.0.0/4)
                    if (ip) {
                        const parts = ip.split('.');
                        if (parts.length === 4) {
                            const firstOctet = parseInt(parts[0]);
                            if (firstOctet >= 224 && firstOctet <= 239) {
                                multicastPackets++;
                            }
                        }
                    }
                }
            });
            
            // Update stats
            document.getElementById('packetCount').textContent = packets.length.toLocaleString();
            document.getElementById('conversationCount').textContent = grouped.conversations.length;
            document.getElementById('protocols').textContent = grouped.protocols.join(', ');
            document.getElementById('multicastCount').textContent = multicastPackets.toLocaleString();
            document.getElementById('totalBytes').textContent = formatBytes(totalBytes);
            
            // Show UI
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('statsBar').classList.remove('hidden');
            document.getElementById('sidebar').classList.remove('hidden');
            
            // Display conversations
            displayConversationList(grouped.conversations);
            
            // Show summary by default
            showSummary(packets, grouped);
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
        }

        function displayConversationList(convs) {
            const list = document.getElementById('conversationList');
            list.innerHTML = '';
            
            convs.forEach(conv => {
                const analysis = analyzeConversation(conv);
                const issueCount = analysis.issues.length;
                
                const item = document.createElement('div');
                const hasIssues = issueCount > 0;
                item.className = `p-3 bg-[#111827] border ${hasIssues ? 'border-red-500/50' : 'border-obsidian-border'} rounded cursor-pointer hover:border-obsidian-accent transition-colors`;
                item.onclick = () => showConversation(conv);
                
                let protocolIcon = 'fa-network-wired';
                if (conv.protocol === 'UDP') {
                    protocolIcon = 'fa-broadcast-tower';
                } else if (conv.protocol === 'ICMP') {
                    protocolIcon = 'fa-exchange-alt';
                }
                
                const packetCount = conv.packets.length;
                const portInfo = conv.srcPort ? `${conv.srcIP}:${conv.srcPort}` : conv.srcIP;
                const dstPortInfo = conv.dstPort ? `${conv.dstIP}:${conv.dstPort}` : conv.dstIP;
                
                item.innerHTML = `
                    <div class="flex items-center justify-between mb-1">
                        <div class="flex items-center gap-2">
                            <i class="fa-solid ${protocolIcon} text-obsidian-accent text-xs"></i>
                            ${hasIssues ? `<span class="text-xs bg-red-500 text-white px-1.5 py-0.5 rounded">${issueCount} issue${issueCount !== 1 ? 's' : ''}</span>` : ''}
                        </div>
                        <span class="text-xs text-gray-500">${packetCount} pkts</span>
                    </div>
                    <div class="text-xs text-white font-mono truncate">${portInfo}</div>
                    <div class="text-xs text-gray-400 font-mono truncate"> ${dstPortInfo}</div>
                `;
                
                list.appendChild(item);
            });
        }

        function showConversation(conv) {
            currentConversation = conv;
            
            document.getElementById('summaryView').classList.add('hidden');
            document.getElementById('conversationView').classList.remove('hidden');
            
            const title = conv.srcPort 
                ? `${conv.srcIP}:${conv.srcPort}  ${conv.dstIP}:${conv.dstPort}`
                : `${conv.srcIP}  ${conv.dstIP} (${conv.protocol})`;
            
            document.getElementById('conversationTitle').textContent = title;
            
            // Calculate statistics
            let totalBytes = 0;
            let outboundBytes = 0;
            let inboundBytes = 0;
            conv.packets.forEach(p => {
                totalBytes += p.length;
                if (p.direction === 'outbound') {
                    outboundBytes += p.length;
                } else {
                    inboundBytes += p.length;
                }
            });
            
            // Analyze for quick stats
            const analysis = analyzeConversation(conv);
            const issueCount = analysis.issues.length;
            
            // Calculate TCP-specific metrics
            let tcpMetrics = '';
            if (conv.protocol === 'TCP') {
                const rtt = calculateRTT(conv);
                const throughput = totalBytes / (conv.endTime - conv.startTime) || 0;
                const packetRate = conv.packets.length / (conv.endTime - conv.startTime) || 0;
                
                tcpMetrics = `
                    <div>
                        <span class="text-gray-500">RTT:</span>
                        <strong class="ml-1">${rtt > 0 ? rtt.toFixed(1) + 'ms' : 'N/A'}</strong>
                    </div>
                    <div>
                        <span class="text-gray-500">Throughput:</span>
                        <strong class="ml-1">${formatBytes(throughput)}/s</strong>
                    </div>
                    <div>
                        <span class="text-gray-500">Packet Rate:</span>
                        <strong class="ml-1">${packetRate.toFixed(1)} pps</strong>
                    </div>
                `;
            }
            
            document.getElementById('conversationInfo').innerHTML = `
                <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-10 gap-3 text-sm">
                    <div>
                        <span class="text-gray-500">Protocol:</span>
                        <strong class="ml-1">${conv.protocol}</strong>
                    </div>
                    <div>
                        <span class="text-gray-500">Packets:</span>
                        <strong class="ml-1">${conv.packets.length}</strong>
                    </div>
                    <div>
                        <span class="text-gray-500">Duration:</span>
                        <strong class="ml-1">${(conv.endTime - conv.startTime).toFixed(3)}s</strong>
                    </div>
                    <div>
                        <span class="text-gray-500">Total Bytes:</span>
                        <strong class="ml-1">${formatBytes(totalBytes)}</strong>
                    </div>
                    <div>
                        <span class="text-gray-500">Outbound:</span>
                        <strong class="ml-1">${formatBytes(outboundBytes)}</strong>
                    </div>
                    <div>
                        <span class="text-gray-500">Inbound:</span>
                        <strong class="ml-1">${formatBytes(inboundBytes)}</strong>
                    </div>
                    <div>
                        <span class="text-gray-500">Issues:</span>
                        <strong class="ml-1 ${issueCount > 0 ? 'text-red-400' : 'text-green-400'}">${issueCount}</strong>
                    </div>
                    ${tcpMetrics}
                </div>
            `;
            
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('conversationView').classList.remove('hidden');
            
            displayChatBubbles(conv);
        }

        function analyzeConversation(conv) {
            const analysis = {
                retransmissions: [],
                timeouts: [],
                duplicateAcks: [],
                outOfOrder: [],
                zeroWindow: [],
                fastRetransmit: [],
                issues: []
            };

            if (conv.protocol !== 'TCP') {
                return analysis;
            }

            const seenSeqs = new Map(); // seq -> [packet indices]
            const seenAcks = new Map(); // ack -> [packet indices]
            const lastPacketTime = {};
            const expectedSeq = {};

            conv.packets.forEach((packet, idx) => {
                const transport = packet.ethernet?.ip?.transport;
                if (!transport || !transport.seqNum) return;

                const isOutbound = packet.direction === 'outbound';
                const key = isOutbound ? 'outbound' : 'inbound';
                const seq = transport.seqNum;
                const ack = transport.ackNum;

                // Track retransmissions (same sequence number seen before)
                if (seenSeqs.has(seq)) {
                    const prevIndices = seenSeqs.get(seq);
                    const prevPacket = conv.packets[prevIndices[0]];
                    const timeSince = (packet.timestamp - prevPacket.timestamp) * 1000;
                    
                    analysis.retransmissions.push({
                        packetIndex: idx,
                        prevIndex: prevIndices[0],
                        seq: seq,
                        timeSince: timeSince,
                        isFastRetransmit: timeSince < 100 // Fast retransmit if < 100ms
                    });
                    
                    if (timeSince < 100) {
                        analysis.fastRetransmit.push(idx);
                    }
                } else {
                    seenSeqs.set(seq, [idx]);
                }
                seenSeqs.get(seq).push(idx);

                // Track duplicate ACKs
                if (ack && seenAcks.has(ack)) {
                    const prevIndices = seenAcks.get(ack);
                    if (prevIndices.length >= 2) {
                        analysis.duplicateAcks.push({
                            packetIndex: idx,
                            ack: ack,
                            count: prevIndices.length + 1
                        });
                    }
                    seenAcks.get(ack).push(idx);
                } else if (ack) {
                    seenAcks.set(ack, [idx]);
                }

                // Detect timeouts (large gaps between packets)
                if (idx > 0) {
                    const timeSinceLast = (packet.timestamp - conv.packets[idx - 1].timestamp) * 1000;
                    if (timeSinceLast > 1000) { // More than 1 second
                        analysis.timeouts.push({
                            packetIndex: idx,
                            timeSince: timeSinceLast,
                            gap: timeSinceLast
                        });
                    }
                }

                // Detect zero window
                if (transport.window === 0) {
                    analysis.zeroWindow.push({
                        packetIndex: idx,
                        direction: isOutbound ? 'outbound' : 'inbound'
                    });
                }

                // Track expected sequence numbers for out-of-order detection
                if (isOutbound && expectedSeq.outbound !== undefined) {
                    if (seq < expectedSeq.outbound && !transport.flags.includes('SYN')) {
                        analysis.outOfOrder.push({
                            packetIndex: idx,
                            expected: expectedSeq.outbound,
                            actual: seq
                        });
                    }
                }

                // Update expected sequence
                if (transport.payload && transport.payload.length > 0) {
                    expectedSeq[key] = seq + transport.payload.length;
                } else if (!transport.flags.includes('SYN') && !transport.flags.includes('FIN')) {
                    expectedSeq[key] = seq + 1;
                }
            });

            // Calculate additional TCP metrics
            if (conv.packets.length > 0) {
                // Calculate jitter (inter-packet timing variance)
                const intervals = [];
                for (let i = 1; i < conv.packets.length; i++) {
                    intervals.push((conv.packets[i].timestamp - conv.packets[i-1].timestamp) * 1000);
                }
                if (intervals.length > 1) {
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const variance = intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) / intervals.length;
                    analysis.jitter = Math.sqrt(variance);
                }
                
                // Calculate packet loss rate
                const totalExpected = conv.packets.length + analysis.retransmissions.length;
                analysis.packetLossRate = totalExpected > 0 ? (analysis.retransmissions.length / totalExpected * 100) : 0;
            }
            
            // Generate summary issues
            if (analysis.retransmissions.length > 0) {
                analysis.issues.push(` ${analysis.retransmissions.length} retransmission(s) detected`);
            }
            if (analysis.timeouts.length > 0) {
                analysis.issues.push(` ${analysis.timeouts.length} timeout(s) detected (>1s gaps)`);
            }
            if (analysis.duplicateAcks.length > 0) {
                analysis.issues.push(` ${analysis.duplicateAcks.length} duplicate ACK(s)`);
            }
            if (analysis.zeroWindow.length > 0) {
                analysis.issues.push(` ${analysis.zeroWindow.length} zero window condition(s)`);
            }
            if (analysis.outOfOrder.length > 0) {
                analysis.issues.push(` ${analysis.outOfOrder.length} out-of-order packet(s)`);
            }

            return analysis;
        }

        function displayChatBubbles(conv) {
            const container = document.getElementById('chatContainer');
            container.innerHTML = '';

            // Analyze conversation for issues
            const analysis = analyzeConversation(conv);
            
            // Show issues banner if any
            if (analysis.issues.length > 0) {
                const issuesBanner = document.createElement('div');
                issuesBanner.className = 'bg-yellow-900/30 border border-yellow-600 rounded-lg p-4 mb-4';
                
                const retransCount = analysis.retransmissions.length;
                const timeoutCount = analysis.timeouts.length;
                const dupAckCount = analysis.duplicateAcks.length;
                const zeroWinCount = analysis.zeroWindow.length;
                const oooCount = analysis.outOfOrder.length;
                
                issuesBanner.innerHTML = `
                    <div class="flex items-start gap-3">
                        <i class="fa-solid fa-exclamation-triangle text-yellow-400 text-xl mt-0.5"></i>
                        <div class="flex-1">
                            <div class="font-semibold text-yellow-400 mb-3">Network Issues Detected:</div>
                            <div class="grid grid-cols-2 md:grid-cols-5 gap-3 text-sm">
                                ${retransCount > 0 ? `
                                    <div class="bg-red-900/30 border border-red-600 rounded p-2">
                                        <div class="text-red-400 font-bold">${retransCount}</div>
                                        <div class="text-red-300 text-xs">Retransmission${retransCount !== 1 ? 's' : ''}</div>
                                    </div>
                                ` : ''}
                                ${timeoutCount > 0 ? `
                                    <div class="bg-yellow-900/30 border border-yellow-600 rounded p-2">
                                        <div class="text-yellow-400 font-bold">${timeoutCount}</div>
                                        <div class="text-yellow-300 text-xs">Timeout${timeoutCount !== 1 ? 's' : ''}</div>
                                    </div>
                                ` : ''}
                                ${dupAckCount > 0 ? `
                                    <div class="bg-purple-900/30 border border-purple-600 rounded p-2">
                                        <div class="text-purple-400 font-bold">${dupAckCount}</div>
                                        <div class="text-purple-300 text-xs">Duplicate ACK${dupAckCount !== 1 ? 's' : ''}</div>
                                    </div>
                                ` : ''}
                                ${zeroWinCount > 0 ? `
                                    <div class="bg-red-900/30 border border-red-600 rounded p-2">
                                        <div class="text-red-400 font-bold">${zeroWinCount}</div>
                                        <div class="text-red-300 text-xs">Zero Window</div>
                                    </div>
                                ` : ''}
                                ${oooCount > 0 ? `
                                    <div class="bg-blue-900/30 border border-blue-600 rounded p-2">
                                        <div class="text-blue-400 font-bold">${oooCount}</div>
                                        <div class="text-blue-300 text-xs">Out-of-Order</div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
                container.appendChild(issuesBanner);
            }
            
            conv.packets.forEach((packet, idx) => {
                const isOutbound = packet.direction === 'outbound';
                const transport = packet.ethernet?.ip?.transport;
                const app = transport?.application;
                const ip = packet.ethernet?.ip;
                
                let message = '';
                let icon = 'fa-circle';
                let color = 'obsidian-accent';
                let payloadSize = 0;
                
                if (app) {
                    if (app.type === 'TLS') {
                        message = app.messageType || 'TLS Message';
                        icon = 'fa-lock';
                        color = app.messageType?.includes('Hello') ? 'green-400' : 
                               app.messageType?.includes('Finished') ? 'blue-400' : 'obsidian-accent';
                        if (app.details) {
                            message += ` (${app.details})`;
                        }
                    } else if (app.type === 'HTTP Request') {
                        const firstLine = app.content.split('\n')[0];
                        message = firstLine || 'HTTP Request';
                        icon = 'fa-arrow-right';
                        color = 'blue-400';
                    } else if (app.type === 'HTTP Response') {
                        const firstLine = app.content.split('\n')[0];
                        message = firstLine || 'HTTP Response';
                        icon = 'fa-arrow-left';
                        color = 'green-400';
                    }
                } else if (transport) {
                    if (transport.type === 'ICMP') {
                        message = transport.messageType || 'ICMP Packet';
                        icon = transport.icmpType === 8 ? 'fa-arrow-right' : transport.icmpType === 0 ? 'fa-arrow-left' : 'fa-exchange-alt';
                        color = transport.icmpType === 8 ? 'blue-400' : transport.icmpType === 0 ? 'green-400' : 'obsidian-accent';
                        if (transport.details && transport.details.sequence !== undefined) {
                            message += ` (Seq: ${transport.details.sequence})`;
                        }
                    } else if (transport.flags) {
                        // Check if packet has payload for size display
                        if (transport.payload && transport.payload.length > 0) {
                            payloadSize = transport.payload.length;
                        }
                        
                        message = `TCP ${transport.flags}`;
                        if (payloadSize > 0) {
                            message += ` [${payloadSize} bytes]`;
                        }
                        icon = 'fa-exchange-alt';
                    } else {
                        message = `${conv.protocol} Packet`;
                    }
                } else {
                    message = 'Packet';
                }
                
                const bubble = document.createElement('div');
                bubble.className = `chat-bubble flex ${isOutbound ? 'justify-end' : 'justify-start'}`;
                
                const time = new Date(packet.timestamp * 1000);
                const timeStr = time.toLocaleTimeString() + '.' + Math.floor((packet.timestamp % 1) * 1000).toString().padStart(3, '0');
                const relativeTime = idx > 0 ? ((packet.timestamp - conv.packets[0].timestamp) * 1000).toFixed(3) + 'ms' : '0ms';
                
                const bubbleColor = isOutbound ? '#7c3aed' : '#252526';
                const textColor = isOutbound ? '#ffffff' : '#ffffff';
                const iconColorClass = color === 'green-400' ? 'text-green-400' : 
                                      color === 'blue-400' ? 'text-blue-400' : 'text-obsidian-accent';
                
                const packetId = `packet-${conv.id}-${idx}`;
                
                // Check for issues with this packet
                const isRetransmission = analysis.retransmissions.some(r => r.packetIndex === idx);
                const isTimeout = analysis.timeouts.some(t => t.packetIndex === idx);
                const isDuplicateAck = analysis.duplicateAcks.some(d => d.packetIndex === idx);
                const isZeroWindow = analysis.zeroWindow.some(z => z.packetIndex === idx);
                const isOutOfOrder = analysis.outOfOrder.some(o => o.packetIndex === idx);
                const isFastRetransmit = analysis.fastRetransmit.includes(idx);
                
                let issueBadges = '';
                if (isRetransmission) {
                    const retransInfo = analysis.retransmissions.find(r => r.packetIndex === idx);
                    issueBadges += `<span class="inline-block bg-red-500 text-white text-xs px-2 py-0.5 rounded mr-1" title="Retransmission after ${retransInfo.timeSince.toFixed(0)}ms">RETRANS</span>`;
                }
                if (isFastRetransmit) {
                    issueBadges += `<span class="inline-block bg-orange-500 text-white text-xs px-2 py-0.5 rounded mr-1">FAST-RETRANS</span>`;
                }
                if (isTimeout) {
                    const timeoutInfo = analysis.timeouts.find(t => t.packetIndex === idx);
                    issueBadges += `<span class="inline-block bg-yellow-500 text-white text-xs px-2 py-0.5 rounded mr-1" title="Timeout: ${timeoutInfo.gap.toFixed(0)}ms gap">TIMEOUT</span>`;
                }
                if (isDuplicateAck) {
                    const dupInfo = analysis.duplicateAcks.find(d => d.packetIndex === idx);
                    issueBadges += `<span class="inline-block bg-purple-500 text-white text-xs px-2 py-0.5 rounded mr-1" title="Duplicate ACK #${dupInfo.count}">DUP-ACK</span>`;
                }
                if (isZeroWindow) {
                    issueBadges += `<span class="inline-block bg-red-600 text-white text-xs px-2 py-0.5 rounded mr-1">ZERO-WIN</span>`;
                }
                if (isOutOfOrder) {
                    issueBadges += `<span class="inline-block bg-blue-500 text-white text-xs px-2 py-0.5 rounded mr-1">OUT-OF-ORDER</span>`;
                }
                
                bubble.innerHTML = `
                    <div class="max-w-3xl ${isOutbound ? 'order-2' : ''}">
                        <div class="flex items-center gap-2 mb-1 ${isOutbound ? 'justify-end' : ''}">
                            <span class="text-xs text-gray-500">#${idx + 1}</span>
                            <span class="text-xs text-gray-500">${timeStr}</span>
                            <span class="text-xs text-gray-600">+${relativeTime}</span>
                            <i class="fa-solid ${icon} ${iconColorClass} text-xs"></i>
                        </div>
                        <div class="rounded-lg px-4 py-3 shadow-lg ${isRetransmission || isTimeout || isZeroWindow ? 'ring-2 ring-red-500' : ''}" style="background-color: ${bubbleColor}; color: ${textColor};">
                            <div class="flex items-start justify-between mb-2">
                                <div class="font-semibold">${message}</div>
                                ${issueBadges ? `<div class="ml-2">${issueBadges}</div>` : ''}
                            </div>
                            ${transport ? `
                                <div class="text-xs opacity-80 mt-2 space-y-1 border-t ${isOutbound ? 'border-white/20' : 'border-white/10'} pt-2">
                                    ${transport.type === 'ICMP' ? `
                                        ${transport.details && transport.details.identifier !== undefined ? `<div><strong>ID:</strong> ${transport.details.identifier}</div>` : ''}
                                        ${transport.details && transport.details.sequence !== undefined ? `<div><strong>Sequence:</strong> ${transport.details.sequence}</div>` : ''}
                                        <div><strong>Code:</strong> ${transport.code}</div>
                                    ` : transport.flags ? `
                                        <div class="grid grid-cols-2 gap-x-4">
                                            <div><strong>Seq:</strong> ${transport.seqNum || 'N/A'}</div>
                                            ${transport.ackNum ? `<div><strong>Ack:</strong> ${transport.ackNum}</div>` : ''}
                                            <div><strong>Flags:</strong> ${transport.flags}</div>
                                            <div><strong>Win:</strong> ${transport.window || 'N/A'}</div>
                                            ${payloadSize > 0 ? `<div><strong>Len:</strong> ${payloadSize}</div>` : ''}
                                            <div><strong>Size:</strong> ${packet.length}</div>
                                        </div>
                                    ` : ''}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                
                container.appendChild(bubble);
            });
            
            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        function showSummary(packets, grouped) {
            if (!packets || !grouped) {
                if (!pcapData) return;
                packets = pcapData.packets;
                const tempGrouped = groupConversations(packets);
                grouped = tempGrouped;
            }
            
            document.getElementById('summaryView').classList.remove('hidden');
            document.getElementById('conversationView').classList.add('hidden');
            
            const container = document.getElementById('summaryContent');
            container.innerHTML = '';
            
            // Overall Statistics
            const statsCard = document.createElement('div');
            statsCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
            statsCard.innerHTML = `
                <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                    <i class="fa-solid fa-chart-line text-obsidian-accent"></i>
                    Overall Statistics
                </h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="bg-[#111827] rounded p-3">
                        <div class="text-xs text-gray-500 mb-1">Total Packets</div>
                        <div class="text-2xl font-bold text-white">${packets.length.toLocaleString()}</div>
                    </div>
                    <div class="bg-[#111827] rounded p-3">
                        <div class="text-xs text-gray-500 mb-1">Conversations</div>
                        <div class="text-2xl font-bold text-white">${grouped.conversations.length}</div>
                    </div>
                    <div class="bg-[#111827] rounded p-3">
                        <div class="text-xs text-gray-500 mb-1">Duration</div>
                        <div class="text-2xl font-bold text-obsidian-accent">${packets.length > 0 ? ((packets[packets.length - 1].timestamp - packets[0].timestamp).toFixed(3)) : '0'}s</div>
                    </div>
                    <div class="bg-[#111827] rounded p-3">
                        <div class="text-xs text-gray-500 mb-1">Packet Rate</div>
                        <div class="text-2xl font-bold text-green-400">${packets.length > 0 && (packets[packets.length - 1].timestamp - packets[0].timestamp) > 0 ? (packets.length / (packets[packets.length - 1].timestamp - packets[0].timestamp)).toFixed(1) : '0'} pps</div>
                    </div>
                </div>
            `;
            container.appendChild(statsCard);
            
            // Top Talkers
            const topTalkers = calculateTopTalkers(packets);
            if (topTalkers.length > 0) {
                const talkersCard = document.createElement('div');
                talkersCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
                talkersCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-network-wired text-obsidian-accent"></i>
                        Top Talkers (by Bytes)
                    </h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="border-b border-obsidian-border">
                                    <th class="text-left py-2 text-gray-400 font-semibold">IP Address</th>
                                    <th class="text-right py-2 text-gray-400 font-semibold">Packets</th>
                                    <th class="text-right py-2 text-gray-400 font-semibold">Bytes Sent</th>
                                    <th class="text-right py-2 text-gray-400 font-semibold">Bytes Received</th>
                                    <th class="text-right py-2 text-gray-400 font-semibold">Total</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${topTalkers.slice(0, 10).map(t => `
                                    <tr class="border-b border-obsidian-border/50 hover:bg-white/5">
                                        <td class="py-2 font-mono text-white">${t.ip}</td>
                                        <td class="py-2 text-right font-mono text-gray-300">${t.packets}</td>
                                        <td class="py-2 text-right font-mono text-blue-400">${formatBytes(t.sent)}</td>
                                        <td class="py-2 text-right font-mono text-green-400">${formatBytes(t.received)}</td>
                                        <td class="py-2 text-right font-mono font-bold text-white">${formatBytes(t.total)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                container.appendChild(talkersCard);
            }
            
            // Protocol Distribution
            const protocolDist = calculateProtocolDistribution(packets);
            if (Object.keys(protocolDist).length > 0) {
                const protoCard = document.createElement('div');
                protoCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
                protoCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-layer-group text-obsidian-accent"></i>
                        Protocol Distribution
                    </h3>
                    <div class="space-y-2">
                        ${Object.entries(protocolDist).sort((a, b) => b[1].packets - a[1].packets).map(([proto, data]) => `
                            <div class="flex items-center justify-between bg-[#111827] rounded p-3">
                                <div class="flex items-center gap-3">
                                    <span class="font-semibold text-white w-20">${proto}</span>
                                    <div class="flex-1 bg-obsidian-border rounded-full h-2 overflow-hidden">
                                        <div class="bg-obsidian-accent h-full" style="width: ${(data.packets / packets.length * 100)}%"></div>
                                    </div>
                                </div>
                                <div class="text-right ml-4">
                                    <div class="text-sm font-mono text-white">${data.packets} (${(data.packets / packets.length * 100).toFixed(1)}%)</div>
                                    <div class="text-xs text-gray-400">${formatBytes(data.bytes)}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                container.appendChild(protoCard);
            }
            
            // DHCP DORA Health Check
            const dhcpAnalysis = analyzeDHCP(packets);
            if (dhcpAnalysis.totalTransactions > 0) {
                const dhcpCard = document.createElement('div');
                dhcpCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
                dhcpCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-network-wired text-obsidian-accent"></i>
                        DHCP DORA Health Check
                    </h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Transactions</div>
                            <div class="text-2xl font-bold text-white">${dhcpAnalysis.totalTransactions}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">NAKs</div>
                            <div class="text-2xl font-bold ${dhcpAnalysis.naks > 0 ? 'text-red-400' : 'text-green-400'}">${dhcpAnalysis.naks}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Avg DO Time</div>
                            <div class="text-2xl font-bold text-obsidian-accent">${dhcpAnalysis.avgDiscoverOfferTime > 0 ? dhcpAnalysis.avgDiscoverOfferTime.toFixed(1) : 'N/A'}ms</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Option 82</div>
                            <div class="text-2xl font-bold ${dhcpAnalysis.option82Present ? 'text-green-400' : 'text-yellow-400'}">${dhcpAnalysis.option82Present ? 'Yes' : 'No'}</div>
                        </div>
                    </div>
                    ${dhcpAnalysis.naks > 0 ? `
                        <div class="bg-red-900/30 border border-red-600 rounded p-3 mb-4">
                            <div class="text-red-400 font-semibold mb-2"> DHCP NAKs Detected</div>
                            <div class="text-sm text-red-200">${dhcpAnalysis.naks} NAK packet(s) found. This indicates server rejection (IP conflicts or scope exhaustion).</div>
                        </div>
                    ` : ''}
                    ${dhcpAnalysis.slowTransactions.length > 0 ? `
                        <div class="bg-yellow-900/30 border border-yellow-600 rounded p-3">
                            <div class="text-yellow-400 font-semibold mb-2"> Slow DHCP Responses</div>
                            <div class="text-sm text-yellow-200">${dhcpAnalysis.slowTransactions.length} transaction(s) with DiscoverOffer time > 200ms</div>
                        </div>
                    ` : ''}
                `;
                container.appendChild(dhcpCard);
            }

            // Multicast & Broadcast Analysis
            const multicastAnalysis = analyzeMulticastBroadcast(packets);
            if (multicastAnalysis.totalMulticast > 0 || multicastAnalysis.totalBroadcast > 0) {
                const mcastCard = document.createElement('div');
                mcastCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
                mcastCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-broadcast-tower text-obsidian-accent"></i>
                        Multicast & Broadcast Analysis
                    </h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Multicast Packets</div>
                            <div class="text-2xl font-bold text-white">${multicastAnalysis.totalMulticast}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Broadcast Packets</div>
                            <div class="text-2xl font-bold text-white">${multicastAnalysis.totalBroadcast}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">IGMP Queries</div>
                            <div class="text-2xl font-bold text-obsidian-accent">${multicastAnalysis.igmpQueries}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">IGMP Reports</div>
                            <div class="text-2xl font-bold text-green-400">${multicastAnalysis.igmpReports}</div>
                        </div>
                    </div>
                    ${multicastAnalysis.ttl1Multicast > 0 ? `
                        <div class="bg-yellow-900/30 border border-yellow-600 rounded p-3 mb-4">
                            <div class="text-yellow-400 font-semibold mb-2"> TTL=1 Multicast Detected</div>
                            <div class="text-sm text-yellow-200">${multicastAnalysis.ttl1Multicast} multicast packet(s) with TTL=1. These will not route across VLANs.</div>
                        </div>
                    ` : ''}
                    ${multicastAnalysis.mdnsPackets > 0 ? `
                        <div class="bg-blue-900/30 border border-blue-600 rounded p-3 mb-4">
                            <div class="text-blue-400 font-semibold mb-2"> mDNS Traffic</div>
                            <div class="text-sm text-blue-200">${multicastAnalysis.mdnsPackets} mDNS packet(s) detected (UDP 5353). High volume can impact WiFi APs.</div>
                        </div>
                    ` : ''}
                    ${multicastAnalysis.igmpQueries === 0 && multicastAnalysis.igmpReports > 0 ? `
                        <div class="bg-red-900/30 border border-red-600 rounded p-3 mb-4">
                            <div class="text-red-400 font-semibold mb-2"> IGMP Issue Detected</div>
                            <div class="text-sm text-red-200">Reports found but no Queries. Multicast groups may timeout without a Querier.</div>
                        </div>
                    ` : ''}
                    ${multicastAnalysis.topMulticastDestinations.length > 0 ? `
                        <div class="mt-4">
                            <div class="text-sm font-semibold text-white mb-2">Top Multicast Destinations</div>
                            <div class="overflow-x-auto">
                                <table class="w-full text-sm">
                                    <thead>
                                        <tr class="border-b border-obsidian-border">
                                            <th class="text-left py-2 text-gray-400 font-semibold">Multicast Group</th>
                                            <th class="text-right py-2 text-gray-400 font-semibold">Packets</th>
                                            <th class="text-right py-2 text-gray-400 font-semibold">Bytes</th>
                                            <th class="text-right py-2 text-gray-400 font-semibold">Rate</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${multicastAnalysis.topMulticastDestinations.slice(0, 10).map(d => `
                                            <tr class="border-b border-obsidian-border/50 hover:bg-white/5">
                                                <td class="py-2 font-mono text-white">${d.group}</td>
                                                <td class="py-2 text-right font-mono text-gray-300">${d.packets}</td>
                                                <td class="py-2 text-right font-mono text-gray-300">${formatBytes(d.bytes)}</td>
                                                <td class="py-2 text-right font-mono text-obsidian-accent">${d.rate.toFixed(1)} pps</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    ` : ''}
                `;
                container.appendChild(mcastCard);
            }

            // DNS Latency Analysis
            const dnsAnalysis = analyzeDNS(packets);
            if (dnsAnalysis.totalQueries > 0) {
                const dnsCard = document.createElement('div');
                dnsCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
                dnsCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-globe text-obsidian-accent"></i>
                        DNS Latency Analysis
                    </h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Total Queries</div>
                            <div class="text-2xl font-bold text-white">${dnsAnalysis.totalQueries}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Avg Response</div>
                            <div class="text-2xl font-bold text-obsidian-accent">${dnsAnalysis.avgResponseTime > 0 ? dnsAnalysis.avgResponseTime.toFixed(1) : 'N/A'}ms</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Slow (>200ms)</div>
                            <div class="text-2xl font-bold ${dnsAnalysis.slowQueries > 0 ? 'text-red-400' : 'text-green-400'}">${dnsAnalysis.slowQueries}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">SERVFAIL</div>
                            <div class="text-2xl font-bold ${dnsAnalysis.servfailCount > 0 ? 'text-red-400' : 'text-green-400'}">${dnsAnalysis.servfailCount}</div>
                        </div>
                    </div>
                    ${dnsAnalysis.slowQueries > 0 ? `
                        <div class="bg-yellow-900/30 border border-yellow-600 rounded p-3 mb-4">
                            <div class="text-yellow-400 font-semibold mb-2"> Slow DNS Responses</div>
                            <div class="text-sm text-yellow-200">${dnsAnalysis.slowQueries} query/queries with response time > 200ms</div>
                        </div>
                    ` : ''}
                    ${dnsAnalysis.servfailCount > 0 ? `
                        <div class="bg-red-900/30 border border-red-600 rounded p-3">
                            <div class="text-red-400 font-semibold mb-2"> DNS SERVFAIL Detected</div>
                            <div class="text-sm text-red-200">${dnsAnalysis.servfailCount} SERVFAIL response(s). This indicates upstream DNS issues (not user typos).</div>
                        </div>
                    ` : ''}
                `;
                container.appendChild(dnsCard);
            }

            // TCP RST Analysis
            const tcpRstAnalysis = analyzeTCPRST(grouped.conversations);
            if (tcpRstAnalysis.totalRSTs > 0 || tcpRstAnalysis.zeroWindows > 0 || tcpRstAnalysis.retransRate > 0) {
                const rstCard = document.createElement('div');
                rstCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
                rstCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-exclamation-triangle text-obsidian-accent"></i>
                        TCP Connection Analysis
                    </h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">TCP RSTs</div>
                            <div class="text-2xl font-bold ${tcpRstAnalysis.totalRSTs > 0 ? 'text-red-400' : 'text-green-400'}">${tcpRstAnalysis.totalRSTs}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Zero Windows</div>
                            <div class="text-2xl font-bold ${tcpRstAnalysis.zeroWindows > 0 ? 'text-red-400' : 'text-green-400'}">${tcpRstAnalysis.zeroWindows}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Retrans Rate</div>
                            <div class="text-2xl font-bold ${tcpRstAnalysis.retransRate > 2 ? 'text-red-400' : tcpRstAnalysis.retransRate > 1 ? 'text-yellow-400' : 'text-green-400'}">${tcpRstAnalysis.retransRate.toFixed(2)}%</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Dup ACKs</div>
                            <div class="text-2xl font-bold ${tcpRstAnalysis.dupAcks > 0 ? 'text-yellow-400' : 'text-green-400'}">${tcpRstAnalysis.dupAcks}</div>
                        </div>
                    </div>
                    ${tcpRstAnalysis.totalRSTs > 0 ? `
                        <div class="bg-red-900/30 border border-red-600 rounded p-3 mb-4">
                            <div class="text-red-400 font-semibold mb-2"> TCP RST Packets Detected</div>
                            <div class="text-sm text-red-200">${tcpRstAnalysis.totalRSTs} RST packet(s) found. Check which side sent RST to identify if firewall killed connection or server crashed.</div>
                        </div>
                    ` : ''}
                    ${tcpRstAnalysis.zeroWindows > 0 ? `
                        <div class="bg-red-900/30 border border-red-600 rounded p-3 mb-4">
                            <div class="text-red-400 font-semibold mb-2"> TCP Zero Window Detected</div>
                            <div class="text-sm text-red-200">${tcpRstAnalysis.zeroWindows} zero window condition(s). Receiver is overwhelmed - not a network issue.</div>
                        </div>
                    ` : ''}
                    ${tcpRstAnalysis.retransRate > 2 ? `
                        <div class="bg-red-900/30 border border-red-600 rounded p-3">
                            <div class="text-red-400 font-semibold mb-2"> High Retransmission Rate</div>
                            <div class="text-sm text-red-200">Retransmission rate: ${tcpRstAnalysis.retransRate.toFixed(2)}%. Anything over 1-2% on LAN indicates packet loss.</div>
                        </div>
                    ` : ''}
                `;
                container.appendChild(rstCard);
            }

            // EAPOL Analysis
            const eapolAnalysis = analyzeEAPOL(packets);
            if (eapolAnalysis.totalEAPOL > 0) {
                const eapolCard = document.createElement('div');
                eapolCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
                eapolCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-wifi text-obsidian-accent"></i>
                        Wireless EAPOL Analysis (802.1X/WPA)
                    </h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">EAPOL Packets</div>
                            <div class="text-2xl font-bold text-white">${eapolAnalysis.totalEAPOL}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">4-Way Handshakes</div>
                            <div class="text-2xl font-bold text-obsidian-accent">${eapolAnalysis.completeHandshakes}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Failed Handshakes</div>
                            <div class="text-2xl font-bold ${eapolAnalysis.failedHandshakes > 0 ? 'text-red-400' : 'text-green-400'}">${eapolAnalysis.failedHandshakes}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Message 1 Retries</div>
                            <div class="text-2xl font-bold ${eapolAnalysis.message1Retries > 0 ? 'text-yellow-400' : 'text-green-400'}">${eapolAnalysis.message1Retries}</div>
                        </div>
                    </div>
                    ${eapolAnalysis.failedHandshakes > 0 ? `
                        <div class="bg-red-900/30 border border-red-600 rounded p-3 mb-4">
                            <div class="text-red-400 font-semibold mb-2"> EAPOL Handshake Failures</div>
                            <div class="text-sm text-red-200">${eapolAnalysis.failedHandshakes} incomplete 4-way handshake(s) detected.</div>
                        </div>
                    ` : ''}
                    ${eapolAnalysis.message1Retries > 0 ? `
                        <div class="bg-yellow-900/30 border border-yellow-600 rounded p-3">
                            <div class="text-yellow-400 font-semibold mb-2"> Message 1 Retries</div>
                            <div class="text-sm text-yellow-200">${eapolAnalysis.message1Retries} retry(ies) of Message 1. Usually indicates PSK error or signal interference.</div>
                        </div>
                    ` : ''}
                `;
                container.appendChild(eapolCard);
            }

            // TCP Analysis Summary
            const tcpAnalysis = analyzeAllTCP(grouped.conversations);
            if (tcpAnalysis.totalConnections > 0) {
                const tcpCard = document.createElement('div');
                tcpCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
                tcpCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-network-wired text-obsidian-accent"></i>
                        TCP Analysis Summary
                    </h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 mb-4">
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">TCP Connections</div>
                            <div class="text-2xl font-bold text-white">${tcpAnalysis.totalConnections}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Avg RTT</div>
                            <div class="text-2xl font-bold text-obsidian-accent">${tcpAnalysis.avgRTT > 0 ? tcpAnalysis.avgRTT.toFixed(1) : 'N/A'}ms</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Total Retrans</div>
                            <div class="text-2xl font-bold ${tcpAnalysis.totalRetrans > 0 ? 'text-red-400' : 'text-green-400'}">${tcpAnalysis.totalRetrans}</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Avg Throughput</div>
                            <div class="text-2xl font-bold text-green-400">${tcpAnalysis.avgThroughput < 1024 ? tcpAnalysis.avgThroughput.toFixed(2) + ' B' : formatBytes(tcpAnalysis.avgThroughput)}/s</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Avg Jitter</div>
                            <div class="text-2xl font-bold text-blue-400">${tcpAnalysis.avgJitter > 0 ? tcpAnalysis.avgJitter.toFixed(1) : 'N/A'}ms</div>
                        </div>
                        <div class="bg-[#111827] rounded p-3">
                            <div class="text-xs text-gray-500 mb-1">Loss Rate</div>
                            <div class="text-2xl font-bold ${tcpAnalysis.avgLossRate > 1 ? 'text-red-400' : 'text-green-400'}">${tcpAnalysis.avgLossRate.toFixed(2)}%</div>
                        </div>
                    </div>
                `;
                container.appendChild(tcpCard);
            }

            // Conversations List
            const convsCard = document.createElement('div');
            convsCard.className = 'bg-obsidian-pane border border-obsidian-border rounded-lg p-6';
            convsCard.innerHTML = `
                <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                    <i class="fa-solid fa-comments text-obsidian-accent"></i>
                    Conversations
                </h3>
                <div class="space-y-2">
                    ${grouped.conversations.slice(0, 20).map((conv, idx) => {
                        const analysis = analyzeConversation(conv);
                        const hasIssues = analysis.issues.length > 0;
                        const title = conv.srcPort 
                            ? `${conv.srcIP}:${conv.srcPort}  ${conv.dstIP}:${conv.dstPort}`
                            : `${conv.srcIP}  ${conv.dstIP}`;
                        return `
                            <div class="bg-[#111827] border ${hasIssues ? 'border-red-500/50' : 'border-obsidian-border'} rounded p-3 cursor-pointer hover:bg-white/5 transition-colors" onclick="showConversationByIndex(${idx})">
                                <div class="flex items-center justify-between">
                                    <div class="flex-1">
                                        <div class="font-mono text-sm text-white">${title}</div>
                                        <div class="text-xs text-gray-400 mt-1">
                                            ${conv.protocol}  ${conv.packets.length} packets  ${((conv.endTime - conv.startTime) * 1000).toFixed(0)}ms
                                        </div>
                                    </div>
                                    ${hasIssues ? `<span class="text-xs bg-red-500 text-white px-2 py-1 rounded ml-2">${analysis.issues.length} issue${analysis.issues.length !== 1 ? 's' : ''}</span>` : ''}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            container.appendChild(convsCard);
        }

        function calculateTopTalkers(packets) {
            const talkers = {};
            
            packets.forEach(p => {
                if (!p.ethernet || !p.ethernet.ip) return;
                
                const srcIP = p.ethernet.ip.srcIP;
                const dstIP = p.ethernet.ip.dstIP;
                
                if (!talkers[srcIP]) {
                    talkers[srcIP] = { ip: srcIP, packets: 0, sent: 0, received: 0, total: 0 };
                }
                if (!talkers[dstIP]) {
                    talkers[dstIP] = { ip: dstIP, packets: 0, sent: 0, received: 0, total: 0 };
                }
                
                talkers[srcIP].packets++;
                talkers[srcIP].sent += p.length;
                talkers[srcIP].total += p.length;
                
                talkers[dstIP].packets++;
                talkers[dstIP].received += p.length;
                talkers[dstIP].total += p.length;
            });
            
            return Object.values(talkers).sort((a, b) => b.total - a.total);
        }

        function calculateProtocolDistribution(packets) {
            const dist = {};
            
            packets.forEach(p => {
                if (!p.ethernet || !p.ethernet.ip) {
                    const proto = 'Other';
                    if (!dist[proto]) dist[proto] = { packets: 0, bytes: 0 };
                    dist[proto].packets++;
                    dist[proto].bytes += p.length;
                    return;
                }
                
                const proto = p.ethernet.ip.protocol || 'Unknown';
                if (!dist[proto]) dist[proto] = { packets: 0, bytes: 0 };
                dist[proto].packets++;
                dist[proto].bytes += p.length;
            });
            
            return dist;
        }

        function analyzeMulticast(packets) {
            const groups = {};
            let totalPackets = 0;
            let totalBytes = 0;
            
            packets.forEach(p => {
                if (!p.ethernet || !p.ethernet.ip) return;
                
                const dstIP = p.ethernet.ip.dstIP;
                if (!dstIP) return;
                
                const parts = dstIP.split('.');
                if (parts.length === 4) {
                    const firstOctet = parseInt(parts[0]);
                    if (firstOctet >= 224 && firstOctet <= 239) {
                        // Multicast address
                        if (!groups[dstIP]) {
                            groups[dstIP] = {
                                group: dstIP,
                                sources: new Set(),
                                packets: 0,
                                bytes: 0,
                                startTime: p.timestamp,
                                endTime: p.timestamp
                            };
                        }
                        
                        groups[dstIP].sources.add(p.ethernet.ip.srcIP);
                        groups[dstIP].packets++;
                        groups[dstIP].bytes += p.length;
                        groups[dstIP].endTime = Math.max(groups[dstIP].endTime, p.timestamp);
                        
                        totalPackets++;
                        totalBytes += p.length;
                    }
                }
            });
            
            // Convert to array and calculate rates
            const groupArray = Object.values(groups).map(g => ({
                ...g,
                sources: Array.from(g.sources),
                rate: g.packets / (g.endTime - g.startTime) || 0
            })).sort((a, b) => b.packets - a.packets);
            
            return {
                groups: groupArray,
                totalPackets,
                totalBytes
            };
        }

        function analyzeDHCP(packets) {
            const transactions = new Map(); // xid -> transaction
            let naks = 0;
            let option82Present = false;
            const slowTransactions = [];
            const discoverOfferTimes = [];

            packets.forEach(p => {
                if (!p.ethernet || !p.ethernet.ip || !p.ethernet.ip.transport) return;
                const transport = p.ethernet.ip.transport;
                const app = transport.application;
                
                if (!app || app.type !== 'DHCP') return;

                const xid = app.xid;
                if (!transactions.has(xid)) {
                    transactions.set(xid, {
                        xid: xid,
                        discover: null,
                        offer: null,
                        request: null,
                        ack: null,
                        nak: null
                    });
                }

                const trans = transactions.get(xid);
                if (app.messageType === 'Discover') {
                    trans.discover = p;
                } else if (app.messageType === 'Offer') {
                    trans.offer = p;
                    if (trans.discover) {
                        const time = (p.timestamp - trans.discover.timestamp) * 1000;
                        discoverOfferTimes.push(time);
                        if (time > 200) {
                            slowTransactions.push({ xid, time });
                        }
                    }
                } else if (app.messageType === 'Request') {
                    trans.request = p;
                } else if (app.messageType === 'ACK') {
                    trans.ack = p;
                } else if (app.messageType === 'NAK') {
                    trans.nak = p;
                    naks++;
                }

                if (app.option82) {
                    option82Present = true;
                }
            });

            return {
                totalTransactions: transactions.size,
                naks: naks,
                avgDiscoverOfferTime: discoverOfferTimes.length > 0 
                    ? discoverOfferTimes.reduce((a, b) => a + b, 0) / discoverOfferTimes.length 
                    : 0,
                slowTransactions: slowTransactions,
                option82Present: option82Present
            };
        }

        function analyzeMulticastBroadcast(packets) {
            const multicastGroups = {};
            let totalMulticast = 0;
            let totalBroadcast = 0;
            let igmpQueries = 0;
            let igmpReports = 0;
            let ttl1Multicast = 0;
            let mdnsPackets = 0;

            packets.forEach(p => {
                if (!p.ethernet || !p.ethernet.ip) return;
                const ip = p.ethernet.ip;

                if (ip.isMulticast) {
                    totalMulticast++;
                    if (ip.ttl === 1) {
                        ttl1Multicast++;
                    }

                    if (!multicastGroups[ip.dstIP]) {
                        multicastGroups[ip.dstIP] = {
                            group: ip.dstIP,
                            packets: 0,
                            bytes: 0,
                            startTime: p.timestamp,
                            endTime: p.timestamp
                        };
                    }
                    multicastGroups[ip.dstIP].packets++;
                    multicastGroups[ip.dstIP].bytes += p.length;
                    multicastGroups[ip.dstIP].endTime = Math.max(multicastGroups[ip.dstIP].endTime, p.timestamp);
                }

                if (ip.isBroadcast) {
                    totalBroadcast++;
                }

                if (ip.protocol === 'IGMP' && ip.transport) {
                    if (ip.transport.isQuery) {
                        igmpQueries++;
                    } else if (ip.transport.isReport) {
                        igmpReports++;
                    }
                }

                // Check for mDNS
                if (ip.transport && ip.transport.application && ip.transport.application.type === 'mDNS') {
                    mdnsPackets++;
                }
            });

            const topMulticastDestinations = Object.values(multicastGroups)
                .map(g => ({
                    ...g,
                    rate: g.packets / (g.endTime - g.startTime) || 0
                }))
                .sort((a, b) => b.packets - a.packets);

            return {
                totalMulticast,
                totalBroadcast,
                igmpQueries,
                igmpReports,
                ttl1Multicast,
                mdnsPackets,
                topMulticastDestinations
            };
        }

        function analyzeDNS(packets) {
            const dnsTransactions = new Map(); // transactionId -> {query, response}
            let totalQueries = 0;
            let totalResponses = 0;
            const responseTimes = [];
            let slowQueries = 0;
            let servfailCount = 0;

            packets.forEach(p => {
                if (!p.ethernet || !p.ethernet.ip || !p.ethernet.ip.transport) return;
                const transport = p.ethernet.ip.transport;
                const app = transport.application;

                if (!app || app.type !== 'DNS') return;

                const transId = app.transactionId;

                if (app.isQuery) {
                    totalQueries++;
                    if (!dnsTransactions.has(transId)) {
                        dnsTransactions.set(transId, { query: p, response: null });
                    }
                } else if (app.isResponse) {
                    totalResponses++;
                    if (dnsTransactions.has(transId)) {
                        const trans = dnsTransactions.get(transId);
                        trans.response = p;
                        const responseTime = (p.timestamp - trans.query.timestamp) * 1000;
                        responseTimes.push(responseTime);
                        if (responseTime > 200) {
                            slowQueries++;
                        }
                    } else {
                        dnsTransactions.set(transId, { query: null, response: p });
                    }
                }

                if (app.isSERVFAIL) {
                    servfailCount++;
                }
            });

            return {
                totalQueries,
                totalResponses,
                avgResponseTime: responseTimes.length > 0 
                    ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length 
                    : 0,
                slowQueries,
                servfailCount
            };
        }

        function analyzeTCPRST(conversations) {
            let totalRSTs = 0;
            let zeroWindows = 0;
            let totalRetrans = 0;
            let totalPackets = 0;
            let dupAcks = 0;

            conversations.forEach(conv => {
                if (conv.protocol !== 'TCP') return;

                const analysis = analyzeConversation(conv);
                totalRetrans += analysis.retransmissions.length;
                dupAcks += analysis.duplicateAcks.length;
                zeroWindows += analysis.zeroWindow.length;

                conv.packets.forEach(p => {
                    totalPackets++;
                    const transport = p.ethernet?.ip?.transport;
                    if (transport && transport.hasRST) {
                        totalRSTs++;
                    }
                });
            });

            return {
                totalRSTs,
                zeroWindows,
                retransRate: totalPackets > 0 ? (totalRetrans / totalPackets * 100) : 0,
                dupAcks
            };
        }

        function analyzeEAPOL(packets) {
            const handshakes = new Map(); // client MAC -> handshake state
            let totalEAPOL = 0;
            let completeHandshakes = 0;
            let failedHandshakes = 0;
            let message1Retries = 0;
            const message1Seen = new Map(); // MAC -> [packets]

            packets.forEach(p => {
                if (!p.ethernet) return;
                
                // EAPOL uses EtherType 0x888E
                const etherType = p.ethernet.etherType;
                const isEAPOL = etherType === '0x888e' || etherType === 0x888E || 
                               (typeof etherType === 'number' && etherType === 0x888E) ||
                               (typeof etherType === 'string' && etherType.toLowerCase() === '0x888e');
                
                if (isEAPOL) {
                    totalEAPOL++;
                    const srcMac = p.ethernet.srcMac;
                    
                    // Try to parse EAPOL packet type (simplified)
                    // EAPOL frame structure: Version (1) + Type (1) + Length (2) + Body
                    // For EAPOL-Key, body starts with: Descriptor Type (1) + Key Info (2) + ...
                    if (p.raw && p.raw.length > 20) {
                        try {
                            // Skip Ethernet header (14 bytes) to get to EAPOL frame
                            const eapolStart = 14;
                            if (p.raw.length > eapolStart + 4) {
                                const eapolReader = new BinaryReader(p.raw.buffer.slice(p.raw.byteOffset + eapolStart, p.raw.byteOffset + p.raw.length));
                                const version = eapolReader.readUInt8();
                                const packetType = eapolReader.readUInt8();
                                const length = eapolReader.readUInt16(false);
                                
                                // EAPOL packet types: 0=EAP-Packet, 1=EAPOL-Start, 2=EAPOL-Logoff, 3=EAPOL-Key
                                // For 4-way handshake, we look for EAPOL-Key (type 3)
                                if (packetType === 3 && length > 0 && eapolReader.remaining() >= length) {
                                    const keyType = eapolReader.readUInt8();
                                    // Key descriptor type: 1 = RSN/WPA2, 2 = WPA
                                    // Key info bits indicate message number (bits 3-5)
                                    if (eapolReader.remaining() >= 2) {
                                        const keyInfo = eapolReader.readUInt16(false);
                                        const messageNum = (keyInfo >> 3) & 0x07; // Bits 3-5
                                        
                                        if (messageNum >= 1 && messageNum <= 4) {
                                            if (messageNum === 1) {
                                                if (!message1Seen.has(srcMac)) {
                                                    message1Seen.set(srcMac, []);
                                                }
                                                message1Seen.get(srcMac).push(p);
                                                if (message1Seen.get(srcMac).length > 1) {
                                                    message1Retries++;
                                                }
                                            }

                                            if (!handshakes.has(srcMac)) {
                                                handshakes.set(srcMac, { messages: new Set() });
                                            }
                                            handshakes.get(srcMac).messages.add(messageNum);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            // EAPOL parsing error, skip - still count as EAPOL packet
                        }
                    }
                }
            });

            // Check for complete 4-way handshakes (messages 1, 2, 3, 4)
            handshakes.forEach((handshake, mac) => {
                if (handshake.messages.has(1) && handshake.messages.has(2) && 
                    handshake.messages.has(3) && handshake.messages.has(4)) {
                    completeHandshakes++;
                } else if (handshake.messages.size > 0) {
                    failedHandshakes++;
                }
            });

            return {
                totalEAPOL,
                completeHandshakes,
                failedHandshakes,
                message1Retries
            };
        }

        function analyzeAllTCP(conversations) {
            let totalConnections = 0;
            let totalRetrans = 0;
            let totalRTT = 0;
            let rttCount = 0;
            let totalBytes = 0;
            let totalDuration = 0;
            let totalJitter = 0;
            let jitterCount = 0;
            let totalLossRate = 0;
            let lossRateCount = 0;
            
            conversations.forEach(conv => {
                if (conv.protocol !== 'TCP') return;
                
                totalConnections++;
                const analysis = analyzeConversation(conv);
                totalRetrans += analysis.retransmissions.length;
                
                if (analysis.jitter !== undefined) {
                    totalJitter += analysis.jitter;
                    jitterCount++;
                }
                
                if (analysis.packetLossRate !== undefined) {
                    totalLossRate += analysis.packetLossRate;
                    lossRateCount++;
                }
                
                // Calculate RTT from SYN-ACK
                if (conv.packets.length >= 2) {
                    const synPacket = conv.packets.find(p => {
                        const t = p.ethernet?.ip?.transport;
                        return t && t.flags && t.flags.includes('SYN') && !t.flags.includes('ACK');
                    });
                    const synAckPacket = conv.packets.find(p => {
                        const t = p.ethernet?.ip?.transport;
                        return t && t.flags && t.flags.includes('SYN') && t.flags.includes('ACK');
                    });
                    
                    if (synPacket && synAckPacket && synAckPacket.timestamp > synPacket.timestamp) {
                        const rtt = (synAckPacket.timestamp - synPacket.timestamp) * 1000;
                        totalRTT += rtt;
                        rttCount++;
                    }
                }
                
                // Calculate throughput
                conv.packets.forEach(p => totalBytes += p.length);
                totalDuration += (conv.endTime - conv.startTime);
            });
            
            return {
                totalConnections,
                totalRetrans,
                avgRTT: rttCount > 0 ? totalRTT / rttCount : 0,
                avgThroughput: totalDuration > 0 ? totalBytes / totalDuration : 0,
                avgJitter: jitterCount > 0 ? totalJitter / jitterCount : 0,
                avgLossRate: lossRateCount > 0 ? totalLossRate / lossRateCount : 0
            };
        }

        function clearPCAP() {
            pcapData = null;
            conversations = [];
            currentConversation = null;
            
            document.getElementById('emptyState').classList.remove('hidden');
            document.getElementById('statsBar').classList.add('hidden');
            document.getElementById('sidebar').classList.add('hidden');
            document.getElementById('conversationView').classList.add('hidden');
            document.getElementById('summaryView').classList.add('hidden');
            document.getElementById('fileInput').value = '';
        }

        function calculateRTT(conv) {
            if (conv.protocol !== 'TCP' || conv.packets.length < 2) return 0;
            
            // Find SYN and SYN-ACK
            const synPacket = conv.packets.find(p => {
                const t = p.ethernet?.ip?.transport;
                return t && t.flags && t.flags.includes('SYN') && !t.flags.includes('ACK');
            });
            const synAckPacket = conv.packets.find(p => {
                const t = p.ethernet?.ip?.transport;
                return t && t.flags && t.flags.includes('SYN') && t.flags.includes('ACK');
            });
            
            if (synPacket && synAckPacket && synAckPacket.timestamp > synPacket.timestamp) {
                return (synAckPacket.timestamp - synPacket.timestamp) * 1000;
            }
            
            return 0;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
